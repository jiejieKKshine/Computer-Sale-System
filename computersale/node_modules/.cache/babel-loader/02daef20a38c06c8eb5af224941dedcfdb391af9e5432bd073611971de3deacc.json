{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.find.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\n/**\n * tdesign v1.10.5\n * (c) 2024 tdesign\n * @license MIT\n */\n\nimport { _ as _toConsumableArray } from '../../../_chunks/dep-4a990ea3.mjs';\nimport { _ as _classCallCheck, a as _createClass } from '../../../_chunks/dep-f909a041.mjs';\nimport { _ as _defineProperty } from '../../../_chunks/dep-fa52aa21.mjs';\nimport { i as isUndefined_1 } from '../../../_chunks/dep-58a62202.mjs';\nimport { g as get_1 } from '../../../_chunks/dep-ae202bc0.mjs';\nimport { s as set_1 } from '../../../_chunks/dep-ed41e004.mjs';\nimport { isRowSelectedDisabled } from './utils.mjs';\nimport '../log/index.mjs';\nimport log from '../log/log.mjs';\nimport '../../../_chunks/dep-593f2b67.mjs';\nimport '../../../_chunks/dep-4659d73b.mjs';\nimport '../../../_chunks/dep-eca422c3.mjs';\nimport '../../../_chunks/dep-aeaef131.mjs';\nimport '../../../_chunks/dep-eae2a67e.mjs';\nimport '../../../_chunks/dep-626c497d.mjs';\nimport '../../../_chunks/dep-ab4bb9b8.mjs';\nimport '../../../_chunks/dep-bf7257e7.mjs';\nimport '../../../_chunks/dep-29ef8419.mjs';\nimport '../../../_chunks/dep-6ab5363f.mjs';\nimport '../../../_chunks/dep-6dc3d0e1.mjs';\nimport '../../../_chunks/dep-06dcbf4c.mjs';\nimport '../../../_chunks/dep-2b09875b.mjs';\nimport '../../../_chunks/dep-cda4f568.mjs';\nimport '../../../_chunks/dep-76958824.mjs';\nimport '../../../_chunks/dep-e9841b9e.mjs';\nimport '../../../_chunks/dep-7932c2e8.mjs';\nimport '../../../_chunks/dep-0e581ac0.mjs';\nimport '../../../_chunks/dep-49aeee3c.mjs';\nimport '../../../_chunks/dep-b5bf85f5.mjs';\nimport '../../../_chunks/dep-ec0bbd9f.mjs';\nimport '../../../_chunks/dep-889e457b.mjs';\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nvar TABLE_TREE_ERROR_CODE_NOT_SAME_LEVEL = {\n  code: 1001,\n  reason: \"The same level of rows can not be swapped.\"\n};\nfunction getUniqueRowValue(row, colKey) {\n  var rowIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var level = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var rowValue = get_1(row, colKey);\n  return rowIndex || level ? \"\".concat(rowValue, \"_\").concat(rowIndex || 0, \"_\").concat(level || 0, \"}\") : rowValue;\n}\nvar TableTreeStore = /*#__PURE__*/function () {\n  function TableTreeStore() {\n    _classCallCheck(this, TableTreeStore);\n    _defineProperty(this, \"treeDataMap\", /* @__PURE__ */new Map());\n    _defineProperty(this, \"expandAllRowIndex\", void 0);\n    this.treeDataMap = /* @__PURE__ */new Map();\n  }\n  return _createClass(TableTreeStore, [{\n    key: \"initialTreeStore\",\n    value: function initialTreeStore(dataSource, columns, keys) {\n      var _this$treeDataMap;\n      (_this$treeDataMap = this.treeDataMap) === null || _this$treeDataMap === void 0 || _this$treeDataMap.clear();\n      this.initialTreeDataMap(this.treeDataMap, dataSource, columns.find(function (col) {\n        return col.colKey === \"row-select\";\n      }), keys);\n    }\n  }, {\n    key: \"getAllUniqueKeys\",\n    value: function getAllUniqueKeys(data, keys) {\n      var arr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      for (var i = 0, len = data.length; i < len; i++) {\n        var item = data[i];\n        arr.push(getUniqueRowValue(item, keys.rowKey));\n        var children = get_1(item, keys.childrenKey);\n        if (children !== null && children !== void 0 && children.length) {\n          this.getAllUniqueKeys(children, keys, arr);\n        }\n      }\n      return arr;\n    }\n  }, {\n    key: \"getExpandedChildrenKeys\",\n    value: function getExpandedChildrenKeys(data, keys) {\n      var arr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      for (var i = 0, len = data.length; i < len; i++) {\n        var item = data[i];\n        var rowValue = getUniqueRowValue(item, keys.rowKey);\n        var rowState = this.treeDataMap.get(rowValue);\n        if (rowState.expanded) {\n          arr.push(rowValue);\n        }\n        var children = get_1(item, keys.childrenKey);\n        if (children !== null && children !== void 0 && children.length) {\n          this.getExpandedChildrenKeys(children, keys, arr);\n        }\n      }\n      return arr;\n    }\n  }, {\n    key: \"expandTreeNode\",\n    value: function expandTreeNode(rowList, dataSource, keys) {\n      var _this = this;\n      if (!rowList.length) return dataSource;\n      rowList.forEach(function (rowValue) {\n        var rowState = _this.treeDataMap.get(rowValue);\n        if (!rowState) return;\n        _this.toggleExpandData({\n          row: rowState.row,\n          rowIndex: rowState.rowIndex\n        }, dataSource, keys, \"expand\");\n      });\n      return dataSource;\n    }\n  }, {\n    key: \"foldTreeNode\",\n    value: function foldTreeNode(rowList, dataSource, keys) {\n      var _this2 = this;\n      if (!rowList.length) return dataSource;\n      rowList.forEach(function (rowValue) {\n        var rowState = _this2.treeDataMap.get(rowValue);\n        if (!rowState) return;\n        _this2.toggleExpandData({\n          row: rowState.row,\n          rowIndex: rowState.rowIndex\n        }, dataSource, keys, \"fold\");\n      });\n      return dataSource;\n    }\n  }, {\n    key: \"toggleExpandData\",\n    value: function toggleExpandData(p, dataSource, keys, type) {\n      var _r$rowIndex;\n      if (!p) {\n        log.error(\"EnhancedTable\", \"the node toggleExpanded doest not exist in `data`\");\n        return dataSource;\n      }\n      var rowValue = get_1(p.row, keys.rowKey);\n      if (isUndefined_1(rowValue)) {\n        log.error(\"EnhancedTable\", \"`rowKey` could be wrong, can not get rowValue from `data` by `rowKey`.\");\n        return [];\n      }\n      var childrenNodes = get_1(p.row, keys.childrenKey);\n      if (childrenNodes === true) return dataSource;\n      var r = this.treeDataMap.get(rowValue);\n      if (type === \"expand\" && r.expanded) return dataSource;\n      if (type === \"fold\" && !r.expanded) return dataSource;\n      r.rowIndex = (_r$rowIndex = r.rowIndex) !== null && _r$rowIndex !== void 0 ? _r$rowIndex : p.rowIndex;\n      r.expanded = !r.expanded;\n      this.treeDataMap.set(rowValue, r);\n      return this.updateExpandRow(r, dataSource, keys);\n    }\n  }, {\n    key: \"updateExpandRow\",\n    value: function updateExpandRow(changeRow, dataSource, keys) {\n      var row = changeRow.row,\n        rowIndex = changeRow.rowIndex,\n        expanded = changeRow.expanded;\n      var treeDataMap = this.treeDataMap;\n      var childrenNodes = get_1(row, keys.childrenKey);\n      if (!row || !childrenNodes) return dataSource;\n      if (expanded) {\n        updateChildrenRowState(treeDataMap, changeRow, expanded, keys);\n        updateRowExpandLength(treeDataMap, row, childrenNodes.length, \"expand\", keys);\n        dataSource.splice.apply(dataSource, [rowIndex + 1, 0].concat(childrenNodes));\n      } else {\n        updateChildrenRowState(treeDataMap, changeRow, expanded, keys);\n        var len = changeRow.expandChildrenLength || childrenNodes.length;\n        updateRowExpandLength(treeDataMap, row, -1 * len, \"fold\", keys);\n        dataSource.splice(rowIndex + 1, len);\n      }\n      updateRowIndex(treeDataMap, dataSource, {\n        rowKey: keys.rowKey,\n        minRowIndex: rowIndex + 1\n      });\n      return dataSource;\n    }\n  }, {\n    key: \"getData\",\n    value: function getData(key) {\n      return this.treeDataMap.get(key);\n    }\n  }, {\n    key: \"updateData\",\n    value: function updateData(rowValue, newRowData, dataSource, keys) {\n      var newRowValue = getUniqueRowValue(newRowData, keys.rowKey);\n      var rowState = this.treeDataMap.get(rowValue);\n      if (!rowState || rowState.rowIndex === -1) {\n        updateRowData(dataSource, rowValue, newRowData, {\n          rowKey: keys.rowKey,\n          childrenKey: keys.childrenKey\n        });\n        return -1;\n      }\n      if (get_1(newRowData, keys.childrenKey) === true) {\n        var oldChildren = get_1(rowState.row, keys.childrenKey);\n        if (oldChildren !== null && oldChildren !== void 0 && oldChildren.length) {\n          for (var i = 0, len = oldChildren.length; i < len; i++) {\n            var rowValue2 = getUniqueRowValue(oldChildren[i], keys.rowKey);\n            var state = this.treeDataMap.get(rowValue2);\n            if (state) {\n              this.treeDataMap[\"delete\"](rowValue2);\n            }\n          }\n        }\n      }\n      var currentRowIndex = rowState.rowIndex;\n      rowState.row = newRowData;\n      rowState.id = newRowValue;\n      if (rowState.parent) {\n        var siblings = get_1(rowState.parent.row, keys.childrenKey);\n        var index = siblings.findIndex(function (item) {\n          return getUniqueRowValue(item, keys.rowKey) === rowValue;\n        });\n        siblings[index] = newRowData;\n      }\n      this.treeDataMap.set(newRowValue, rowState);\n      if (rowValue !== newRowValue) {\n        this.treeDataMap[\"delete\"](rowValue);\n      }\n      return currentRowIndex;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(key, dataSource, keys) {\n      var r = this.treeDataMap.get(key);\n      if (r && r.rowIndex >= 0) {\n        var removeNumber = (r.expandChildrenLength || 0) + 1;\n        dataSource.splice(r.rowIndex, removeNumber);\n        if (r.parent) {\n          var siblings = get_1(r.parent.row, keys.childrenKey);\n          var index = siblings.findIndex(function (item) {\n            return get_1(item, keys.rowKey) === key;\n          });\n          siblings.splice(index, 1);\n          updateRowExpandLength(this.treeDataMap, r.parent.row, -1 * removeNumber, \"delete\", keys);\n        }\n        this.treeDataMap[\"delete\"](key);\n        updateRowIndex(this.treeDataMap, dataSource, {\n          minRowIndex: r.rowIndex,\n          rowKey: keys.rowKey,\n          type: \"remove\"\n        });\n      } else {\n        log.warn(\"EnhancedTable\", \"Can not remove this node, which is not appeared.\");\n      }\n      return dataSource;\n    }\n  }, {\n    key: \"removeChildren\",\n    value: function removeChildren(key, dataSource, keys) {\n      var r = this.treeDataMap.get(key);\n      if (r && r.rowIndex >= 0) {\n        var removeNumber = r.expandChildrenLength || 0;\n        if (removeNumber) {\n          dataSource.splice(r.rowIndex + 1, removeNumber);\n        }\n        if (r.parent) {\n          updateRowExpandLength(this.treeDataMap, r.parent.row, -1 * removeNumber, \"delete\", keys);\n        }\n        r.expandChildrenLength = 0;\n        r.expanded = false;\n        set_1(r.row, keys.childrenKey, void 0);\n        this.treeDataMap.set(key, r);\n        if (removeNumber) {\n          updateRowIndex(this.treeDataMap, dataSource, {\n            minRowIndex: r.rowIndex + 1,\n            rowKey: keys.rowKey,\n            type: \"remove\"\n          });\n        }\n      } else {\n        log.warn(\"EnhancedTable\", \"Can not remove this node's children, which is not appeared.\");\n      }\n      return dataSource;\n    }\n  }, {\n    key: \"appendTo\",\n    value: function appendTo(rowValue, newData, dataSource, keys) {\n      var state = this.treeDataMap.get(rowValue);\n      if (!this.validateDataExist(state, rowValue)) return dataSource;\n      var children = get_1(state.row, keys.childrenKey);\n      var isShowNewNode = state.expanded || !(children !== null && children !== void 0 && children.length);\n      var tmpData = newData instanceof Array ? newData : [newData];\n      var newChildrenData = [];\n      var newChildrenStates = [];\n      var firstNewChildrenIndex = -1;\n      for (var i = 0, len = tmpData.length; i < len; i++) {\n        var oneData = tmpData[i];\n        var newRowValue = getUniqueRowValue(oneData, keys.rowKey);\n        var mapState = this.treeDataMap.get(newRowValue);\n        if (!this.validateDataDoubleExist(mapState, newRowValue)) {\n          log.warn(\"Table\", \"Duplicated Data `\".concat(newRowValue, \"` has been removed.\"));\n        } else {\n          var rowIndex = isShowNewNode ? state.rowIndex + (state.expandChildrenLength || 0) + (i + 1) : -1;\n          if (i === 0) {\n            firstNewChildrenIndex = rowIndex;\n          }\n          var newState = {\n            id: newRowValue,\n            row: oneData,\n            rowIndex: rowIndex,\n            level: state.level + 1,\n            expanded: false,\n            expandChildrenLength: 0,\n            disabled: false,\n            path: _toConsumableArray(state.path),\n            parent: state\n          };\n          newState.path = newState.path.concat(newState);\n          newChildrenData.push(oneData);\n          newChildrenStates.push(newState);\n          this.treeDataMap.set(newRowValue, newState);\n        }\n      }\n      if (!newChildrenData.length) return dataSource;\n      if (children !== null && children !== void 0 && children.length) {\n        state.row[keys.childrenKey] = state.row[keys.childrenKey].concat(newChildrenData);\n      } else {\n        state.row[keys.childrenKey] = newChildrenData;\n        state.expanded = true;\n      }\n      if (isShowNewNode) {\n        dataSource.splice.apply(dataSource, [firstNewChildrenIndex, 0].concat(newChildrenData));\n        var newChildrenCount = newChildrenData.length || 1;\n        updateRowExpandLength(this.treeDataMap, state.row, newChildrenCount, \"insert\", {\n          rowKey: keys.rowKey,\n          childrenKey: keys.childrenKey\n        });\n        updateRowIndex(this.treeDataMap, dataSource, {\n          minRowIndex: firstNewChildrenIndex + newChildrenData.length - 1,\n          rowKey: keys.rowKey,\n          type: \"add\",\n          count: 1\n        });\n      }\n      return dataSource;\n    }\n  }, {\n    key: \"appendToRoot\",\n    value: function appendToRoot(newData, dataSource, keys) {\n      var newDataSource = dataSource.concat(newData);\n      var tmpNewData = newData instanceof Array ? newData : [newData];\n      var dataSourceLen = dataSource.length;\n      for (var i = 0, len = tmpNewData.length; i < len; i++) {\n        var rowValue = get_1(tmpNewData[i], keys.rowKey);\n        if (!rowValue) {\n          log.error(\"Table\", \"`rowKey` could be wrong, can not get rowValue from `data` by `rowKey`.\");\n          continue;\n        }\n        var state = {\n          id: rowValue,\n          row: tmpNewData[i],\n          rowIndex: dataSourceLen + i,\n          level: 0,\n          expanded: false,\n          expandChildrenLength: 0,\n          disabled: false\n        };\n        state.path = [state];\n        this.treeDataMap.set(rowValue, state);\n      }\n      return newDataSource;\n    }\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(rowValue, newData, dataSource, keys) {\n      return this.insert(rowValue, newData, dataSource, keys, \"after\");\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(rowValue, newData, dataSource, keys) {\n      return this.insert(rowValue, newData, dataSource, keys, \"before\");\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(rowValue, newData, dataSource, keys, type) {\n      var state = this.treeDataMap.get(rowValue);\n      if (!this.validateDataExist(state, rowValue)) return dataSource;\n      var newRowValue = get_1(newData, keys.rowKey);\n      var mapState = this.treeDataMap.get(newRowValue);\n      if (!this.validateDataDoubleExist(mapState, newRowValue)) return dataSource;\n      var rowIndex = type === \"after\" ? state.rowIndex + 1 : state.rowIndex;\n      var newState = {\n        id: newRowValue,\n        row: newData,\n        rowIndex: rowIndex,\n        level: state.level,\n        expanded: false,\n        expandChildrenLength: 0,\n        disabled: false,\n        path: state.path.slice(0, -1),\n        parent: state.parent\n      };\n      newState.path = newState.path.concat(newState);\n      var dataIndex = type === \"after\" ? state.rowIndex + (state.expandChildrenLength + 1) : state.rowIndex;\n      dataSource.splice(dataIndex, 0, newData);\n      var distance = type === \"after\" ? 1 : 0;\n      if (state.parent) {\n        var childrenIndex = state.parent.row[keys.childrenKey].findIndex(function (t) {\n          return rowValue === get_1(t, keys.rowKey);\n        });\n        state.parent.row[keys.childrenKey].splice(childrenIndex + distance, 0, newData);\n        updateRowExpandLength(this.treeDataMap, state.parent.row, 1, \"insert\", keys);\n      }\n      this.treeDataMap.set(newRowValue, newState);\n      updateRowIndex(this.treeDataMap, dataSource, {\n        rowKey: keys.rowKey,\n        minRowIndex: state.rowIndex + 1,\n        type: \"add\"\n      });\n      return dataSource;\n    }\n  }, {\n    key: \"swapData\",\n    value: function swapData(dataSource, params, keys) {\n      var startIndex = params.currentIndex;\n      var endIndex = params.targetIndex;\n      if (startIndex === endIndex) return {\n        dataSource: dataSource,\n        result: true\n      };\n      var startRowValue = get_1(params.current, keys.rowKey);\n      var endRowValue = get_1(params.target, keys.rowKey);\n      var startState = this.treeDataMap.get(startRowValue);\n      var endState = this.treeDataMap.get(endRowValue);\n      if (startState.level !== endState.level) {\n        return {\n          dataSource: dataSource,\n          result: false,\n          code: TABLE_TREE_ERROR_CODE_NOT_SAME_LEVEL.code,\n          reason: TABLE_TREE_ERROR_CODE_NOT_SAME_LEVEL.reason\n        };\n      }\n      var startLastIndex = startIndex + startState.expandChildrenLength + 1;\n      var endLastIndex = endIndex + endState.expandChildrenLength + 1;\n      var startRowList = dataSource.slice(startIndex, startLastIndex);\n      var endRowList = dataSource.slice(endIndex, endLastIndex);\n      if (startIndex > endIndex) {\n        var middleRowList = dataSource.slice(endLastIndex, startIndex);\n        var allSwapList = startRowList.concat(endRowList, middleRowList);\n        dataSource.splice(endIndex, allSwapList.length);\n        dataSource.splice.apply(dataSource, [endIndex, 0].concat(_toConsumableArray(allSwapList)));\n        updateRowIndex(this.treeDataMap, dataSource, {\n          rowKey: keys.rowKey,\n          minRowIndex: endIndex,\n          maxRowIndex: startLastIndex\n        });\n      } else {\n        var _middleRowList = dataSource.slice(startLastIndex, endIndex);\n        var _allSwapList = _middleRowList.concat(endRowList, startRowList);\n        dataSource.splice(startIndex, _allSwapList.length);\n        dataSource.splice.apply(dataSource, [startIndex, 0].concat(_toConsumableArray(_allSwapList)));\n        updateRowIndex(this.treeDataMap, dataSource, {\n          rowKey: keys.rowKey,\n          minRowIndex: startIndex,\n          maxRowIndex: endLastIndex\n        });\n      }\n      if (startState.parent) {\n        var children = startState.parent.row[keys.childrenKey];\n        var count = 0;\n        var targetIndex = -1;\n        var currentIndex = -1;\n        for (var i = 0, len = children.length; i < len; i++) {\n          if (get_1(children[i], keys.rowKey) === startRowValue) {\n            currentIndex = i;\n            count += 1;\n          }\n          if (get_1(children[i], keys.rowKey) === endRowValue) {\n            targetIndex = i;\n            count += 1;\n          }\n          if (count >= 2) break;\n        }\n        if (currentIndex < targetIndex) {\n          children.splice(targetIndex + 1, 0, params.current);\n          children.splice(currentIndex, 1);\n        } else {\n          children.splice(currentIndex, 1);\n          children.splice(targetIndex, 0, params.current);\n        }\n      }\n      return {\n        dataSource: dataSource,\n        result: true\n      };\n    }\n  }, {\n    key: \"expandAll\",\n    value: function expandAll(dataSource, keys) {\n      var _this3 = this;\n      this.expandAllRowIndex = 0;\n      var newData = [];\n      var _expandLoop = function expandLoop(dataSource2, keys2) {\n        var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        for (var i = 0, len = dataSource2.length; i < len; i++) {\n          var item = dataSource2[i];\n          var rowValue = get_1(item, keys2.rowKey);\n          var state = _this3.treeDataMap.get(rowValue);\n          var children = get_1(item, keys2.childrenKey);\n          state.rowIndex = _this3.expandAllRowIndex;\n          if (children !== true && children !== null && children !== void 0 && children.length) {\n            state.expanded = true;\n          }\n          state.expandChildrenLength = (children === null || children === void 0 ? void 0 : children.length) || 0;\n          _this3.expandAllRowIndex += 1;\n          newData.push(item);\n          _this3.treeDataMap.set(rowValue, state);\n          if (children !== null && children !== void 0 && children.length) {\n            var tmpParent = parent;\n            while ((_tmpParent = tmpParent) !== null && _tmpParent !== void 0 && _tmpParent.row) {\n              var _tmpParent;\n              tmpParent.expandChildrenLength += children.length;\n              _this3.treeDataMap.set(tmpParent.id, tmpParent);\n              tmpParent = tmpParent.parent;\n            }\n            _expandLoop(children, keys2, state);\n          }\n        }\n      };\n      _expandLoop(dataSource, keys);\n      return newData;\n    }\n  }, {\n    key: \"foldAll\",\n    value: function foldAll(dataSource, keys) {\n      var newData = [];\n      var index = 0;\n      for (var i = 0, len = dataSource.length; i < len; i++) {\n        var item = dataSource[i];\n        var rowValue = get_1(item, keys.rowKey);\n        var state = this.treeDataMap.get(rowValue);\n        state.rowIndex = state.level === 0 ? index : -1;\n        state.expanded = false;\n        state.expandChildrenLength = 0;\n        if (state.level === 0) {\n          newData.push(item);\n          index += 1;\n        }\n        var children = get_1(item, keys.childrenKey);\n        if (children !== null && children !== void 0 && children.length) {\n          this.foldAll(children, keys);\n        }\n      }\n      return newData;\n    }\n  }, {\n    key: \"getTreeNode\",\n    value: function getTreeNode(dataSource, keys) {\n      var treeData = [];\n      for (var i = 0, len = dataSource.length; i < len; i++) {\n        var item = dataSource[i];\n        var rowValue = get_1(item, keys.rowKey);\n        var state = this.treeDataMap.get(rowValue);\n        if (state.level === 0) {\n          treeData.push(item);\n        }\n      }\n      return treeData;\n    }\n  }, {\n    key: \"getTreeExpandedRow\",\n    value: function getTreeExpandedRow(dataSource, keys) {\n      var _this4 = this;\n      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"data\";\n      var arr = [];\n      dataSource.forEach(function (item) {\n        var rowValue = get_1(item, keys.rowKey);\n        var rowState = _this4.treeDataMap.get(rowValue);\n        if (!rowState.expanded) return;\n        if (type === \"unique\") {\n          arr.push(rowValue);\n        } else if (type === \"data\") {\n          arr.push(item);\n        } else {\n          arr.push(rowState);\n        }\n      });\n      return arr;\n    }\n  }, {\n    key: \"initialTreeDataMap\",\n    value: function initialTreeDataMap(treeDataMap, dataSource, column, keys) {\n      var level = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var parent = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n      for (var i = 0, len = dataSource.length; i < len; i++) {\n        var item = dataSource[i];\n        var rowValue = getUniqueRowValue(item, keys.rowKey);\n        if (isUndefined_1(rowValue)) {\n          log.error(\"EnhancedTable\", \"`rowKey` could be wrong, can not get rowValue from `data` by `rowKey`.\");\n          return;\n        }\n        var children = get_1(item, keys.childrenKey);\n        var state = {\n          id: rowValue,\n          row: item,\n          rowIndex: level === 0 ? i : -1,\n          level: level,\n          expanded: false,\n          expandChildrenLength: 0,\n          disabled: isRowSelectedDisabled(column, item, i),\n          parent: parent\n        };\n        state.path = parent ? parent.path.concat(state) : [state];\n        treeDataMap.set(rowValue, state);\n        if (children !== null && children !== void 0 && children.length) {\n          this.initialTreeDataMap(treeDataMap, children, column, keys, level + 1, state);\n        }\n      }\n    }\n  }, {\n    key: \"updateDisabledState\",\n    value: function updateDisabledState(dataSource, column, keys) {\n      for (var i = 0, len = dataSource.length; i < len; i++) {\n        var item = dataSource[i];\n        var rowValue = get_1(item, keys.rowKey);\n        if (isUndefined_1(rowValue)) {\n          log.error(\"EnhancedTable\", \"`rowKey` could be wrong, can not get rowValue from `data` by `rowKey`.\");\n          return;\n        }\n        var state = this.treeDataMap.get(rowValue);\n        state.disabled = isRowSelectedDisabled(column, item, i);\n        this.treeDataMap.set(rowValue, state);\n        var children = get_1(item, keys.childrenKey);\n        if (children !== null && children !== void 0 && children.length) {\n          this.updateDisabledState(children, column, keys);\n        }\n      }\n    }\n  }, {\n    key: \"validateDataExist\",\n    value: function validateDataExist(state, rowValue) {\n      if (!state) {\n        log.warn(\"EnhancedTable\", \"\".concat(rowValue, \" does not exist.\"));\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"validateDataDoubleExist\",\n    value: function validateDataDoubleExist(state, rowValue) {\n      if (state) {\n        log.warn(\"EnhancedTable\", \"Duplicated Key. \".concat(rowValue, \" already exists.\"));\n        return false;\n      }\n      return true;\n    }\n  }]);\n}();\nfunction updateRowExpandLength(treeDataMap, row, distance, type, keys) {\n  var tmp = row;\n  while (tmp) {\n    var _state$parent;\n    var state = treeDataMap.get(get_1(tmp, keys.rowKey));\n    var expandLen = (state.expandChildrenLength || 0) + distance;\n    state.expandChildrenLength = Math.max(0, expandLen);\n    tmp = state === null || state === void 0 || (_state$parent = state.parent) === null || _state$parent === void 0 ? void 0 : _state$parent.row;\n  }\n  if (type === \"fold\") {\n    clearRowExpandLength(treeDataMap, row, keys);\n  }\n}\nfunction clearRowExpandLength(treeDataMap, row, keys) {\n  var children = get_1(row, keys.childrenKey);\n  if (children !== null && children !== void 0 && children.length) {\n    children.forEach(function (item) {\n      var state = treeDataMap.get(get_1(item, keys.rowKey));\n      if (!state) return;\n      state.expandChildrenLength = 0;\n      clearRowExpandLength(treeDataMap, state.row, keys);\n    });\n  }\n}\nfunction updateChildrenRowState(treeDataMap, rowState, expanded, keys) {\n  var row = rowState.row,\n    rowIndex = rowState.rowIndex;\n  var childrenNodes = get_1(row, keys.childrenKey);\n  childrenNodes.forEach(function (item, kidRowIndex) {\n    var rowValue = get_1(item, keys.rowKey);\n    var index = expanded ? rowIndex + 1 + kidRowIndex : -1;\n    var curState = treeDataMap.get(rowValue);\n    var newState = _objectSpread(_objectSpread({}, curState), {}, {\n      row: item,\n      rowIndex: index,\n      expanded: false,\n      parent: rowState\n    });\n    treeDataMap.set(rowValue, newState);\n    if (!expanded) {\n      var children = get_1(item, keys.childrenKey);\n      if (children !== null && children !== void 0 && children.length) {\n        updateChildrenRowState(treeDataMap, _objectSpread(_objectSpread({}, newState), {}, {\n          rowIndex: -1,\n          expanded: false\n        }), expanded, keys);\n      }\n    }\n  });\n}\nfunction updateRowData(data, key, newData, keys) {\n  for (var i = 0, len = data.length; i < len; i++) {\n    var item = data[i];\n    if (get_1(item, keys.rowKey) === key) {\n      data[i] = newData;\n      return;\n    }\n    var children = get_1(item, keys.childrenKey) || [];\n    if (children !== null && children !== void 0 && children.length) {\n      updateRowData(children, key, newData, keys);\n    }\n  }\n}\nfunction updateRowIndex(treeDataMap, dataSource, extra) {\n  var start = extra.minRowIndex || 0;\n  var end = extra.maxRowIndex || dataSource.length;\n  for (var rowIndex = start; rowIndex < end; rowIndex++) {\n    var item = dataSource[rowIndex];\n    var state = treeDataMap.get(get_1(item, extra.rowKey));\n    if (!state) {\n      log.warn(\"Table\", \"tree map went wrong\");\n    }\n    state.rowIndex = rowIndex + ((extra === null || extra === void 0 ? void 0 : extra.count) || 1) - 1;\n  }\n}\nfunction diffExpandedTreeNode() {\n  var newExpandedNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var oldExpandedNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var removedList = [];\n  var addedList = [];\n  var newExpandedNodeMap = /* @__PURE__ */new Map();\n  var oldExpandedNodeMap = /* @__PURE__ */new Map();\n  for (var i = 0, len = newExpandedNode.length; i < len; i++) {\n    newExpandedNodeMap.set(newExpandedNode[i], true);\n  }\n  for (var _i = 0, _len = oldExpandedNode.length; _i < _len; _i++) {\n    oldExpandedNodeMap.set(oldExpandedNode[_i], true);\n  }\n  for (var _i2 = 0, _len2 = newExpandedNode.length; _i2 < _len2; _i2++) {\n    if (!oldExpandedNodeMap.get(newExpandedNode[_i2])) {\n      addedList.push(newExpandedNode[_i2]);\n    }\n  }\n  for (var _i3 = 0, _len3 = oldExpandedNode.length; _i3 < _len3; _i3++) {\n    if (!newExpandedNodeMap.get(oldExpandedNode[_i3])) {\n      removedList.push(oldExpandedNode[_i3]);\n    }\n  }\n  return {\n    removedList: removedList,\n    addedList: addedList\n  };\n}\nexport { TABLE_TREE_ERROR_CODE_NOT_SAME_LEVEL, clearRowExpandLength, TableTreeStore as default, diffExpandedTreeNode, getUniqueRowValue, updateChildrenRowState, updateRowData, updateRowExpandLength, updateRowIndex };","map":{"version":3,"names":["TABLE_TREE_ERROR_CODE_NOT_SAME_LEVEL","code","reason","getUniqueRowValue","row","colKey","rowIndex","arguments","length","undefined","level","rowValue","get_1","concat","TableTreeStore","_classCallCheck","_defineProperty","Map","treeDataMap","_createClass","key","value","initialTreeStore","dataSource","columns","keys","_this$treeDataMap","clear","initialTreeDataMap","find","col","getAllUniqueKeys","data","arr","i","len","item","push","rowKey","children","childrenKey","getExpandedChildrenKeys","rowState","get","expanded","expandTreeNode","rowList","_this","forEach","toggleExpandData","foldTreeNode","_this2","p","type","_r$rowIndex","log","error","isUndefined_1","childrenNodes","r","set","updateExpandRow","changeRow","updateChildrenRowState","updateRowExpandLength","splice","apply","expandChildrenLength","updateRowIndex","minRowIndex","getData","updateData","newRowData","newRowValue","updateRowData","oldChildren","rowValue2","state","currentRowIndex","id","parent","siblings","index","findIndex","remove","removeNumber","warn","removeChildren","set_1","appendTo","newData","validateDataExist","isShowNewNode","tmpData","Array","newChildrenData","newChildrenStates","firstNewChildrenIndex","oneData","mapState","validateDataDoubleExist","newState","disabled","path","_toConsumableArray","newChildrenCount","count","appendToRoot","newDataSource","tmpNewData","dataSourceLen","insertAfter","insert","insertBefore","slice","dataIndex","distance","childrenIndex","t","swapData","params","startIndex","currentIndex","endIndex","targetIndex","result","startRowValue","current","endRowValue","target","startState","endState","startLastIndex","endLastIndex","startRowList","endRowList","middleRowList","allSwapList","maxRowIndex","_middleRowList","_allSwapList","expandAll","_this3","expandAllRowIndex","_expandLoop","expandLoop","dataSource2","keys2","tmpParent","_tmpParent","foldAll","getTreeNode","treeData","getTreeExpandedRow","_this4","column","isRowSelectedDisabled","updateDisabledState","tmp","_state$parent","expandLen","Math","max","clearRowExpandLength","kidRowIndex","curState","_objectSpread","extra","start","end","diffExpandedTreeNode","newExpandedNode","oldExpandedNode","removedList","addedList","newExpandedNodeMap","oldExpandedNodeMap","_i","_len","_i2","_len2","_i3","_len3"],"sources":["../../../../src/_common/js/table/tree-store.ts"],"sourcesContent":["import isUndefined from 'lodash/isUndefined';\n/* eslint-disable class-methods-use-this */\n/* eslint-disable no-param-reassign */\n/* eslint-disable no-use-before-define */\nimport get from 'lodash/get';\nimport set from 'lodash/set';\nimport { isRowSelectedDisabled } from './utils';\nimport { PrimaryTableCol, TableRowState, TableRowValue, TableRowData } from './types';\nimport log from '../log';\n\nexport type TableTreeDataMap = Map<string | number, TableRowState>;\n\nexport interface TableRowModel<T> extends TableRowState<T> {\n  setData?: (key: string | number, data: T) => void;\n}\n\nexport interface KeysType {\n  rowKey: string;\n  childrenKey: string;\n}\n\nexport interface SwapParams<T> {\n  current: T;\n  target: T;\n  currentIndex: number;\n  targetIndex: number;\n}\n\nexport const TABLE_TREE_ERROR_CODE_NOT_SAME_LEVEL = {\n  code: 1001,\n  reason: 'The same level of rows can not be swapped.',\n};\n\n/**\n * 获取行唯一标识\n * @param row 行数据\n * @param colKey 列字段\n * @param rowIndex 行下标\n * @param level 层级\n */\nexport function getUniqueRowValue(row: TableRowData, colKey: string, rowIndex: number = 0, level: number = 0) {\n  const rowValue = get(row, colKey);\n  return rowIndex || level ? `${rowValue}_${rowIndex || 0}_${level || 0}}` : rowValue;\n}\n\n/**\n * 表格树形结构处理器\n * Vue 和 React 可以通用\n * 关键函数有以下几个\n * @toggleExpandData 处理树形结构展开收起\n * @setData 更新当行数据\n * @getData 获取单行数据\n * @remove 移除行数据，及其子节点\n * @appendTo 追加子节点到末尾\n */\nclass TableTreeStore<T extends TableRowData = TableRowData> {\n  /** 树形结构 Map 存储 */\n  treeDataMap: TableTreeDataMap = new Map();\n\n  expandAllRowIndex: 0;\n\n  constructor() {\n    this.treeDataMap = new Map();\n  }\n\n  /**\n   * 初始化 treeDataMap，不会改变 dataSource\n   * @param dataSource 树形数据源\n   * @param columns 列配置\n   * @param keys 字段别名\n   */\n  initialTreeStore(dataSource: T[], columns: PrimaryTableCol[], keys: KeysType) {\n    this.treeDataMap?.clear();\n    this.initialTreeDataMap(this.treeDataMap, dataSource, columns.find((col) => col.colKey === 'row-select'), keys);\n  }\n\n  /**\n   * 获取所有节点的唯一标识\n   */\n  getAllUniqueKeys(data: T[], keys: KeysType, arr: T[] = []) {\n    for (let i = 0, len = data.length; i < len; i++) {\n      const item = data[i];\n      arr.push(getUniqueRowValue(item, keys.rowKey));\n      const children = get(item, keys.childrenKey);\n      if (children?.length) {\n        this.getAllUniqueKeys(children, keys, arr);\n      }\n    }\n    return arr;\n  }\n\n  getExpandedChildrenKeys(data: T[], keys: KeysType, arr: (string | number)[] = []) {\n    for (let i = 0, len = data.length; i < len; i++) {\n      const item = data[i];\n      const rowValue = getUniqueRowValue(item, keys.rowKey);\n      const rowState = this.treeDataMap.get(rowValue);\n      if (rowState.expanded) {\n        arr.push(rowValue);\n      }\n      const children = get(item, keys.childrenKey);\n      if (children?.length) {\n        this.getExpandedChildrenKeys(children, keys, arr);\n      }\n    }\n    return arr;\n  }\n\n  expandTreeNode(rowList: (string | number)[], dataSource: T[], keys: KeysType) {\n    if (!rowList.length) return dataSource;\n    rowList.forEach((rowValue) => {\n      const rowState = this.treeDataMap.get(rowValue);\n      if (!rowState) return;\n      this.toggleExpandData({ row: rowState.row as T, rowIndex: rowState.rowIndex }, dataSource, keys, 'expand');\n    });\n    return dataSource;\n  }\n\n  foldTreeNode(rowList: (string | number)[], dataSource: T[], keys: KeysType) {\n    if (!rowList.length) return dataSource;\n    rowList.forEach((rowValue) => {\n      const rowState = this.treeDataMap.get(rowValue);\n      if (!rowState) return;\n      this.toggleExpandData({ row: rowState.row as T, rowIndex: rowState.rowIndex }, dataSource, keys, 'fold');\n    });\n    return dataSource;\n  }\n\n  toggleExpandData(p: { rowIndex: number; row: T }, dataSource: T[], keys: KeysType, type?: 'expand' | 'fold') {\n    if (!p) {\n      log.error('EnhancedTable', 'the node toggleExpanded doest not exist in `data`');\n      return dataSource;\n    }\n    const rowValue = get(p.row, keys.rowKey);\n    if (isUndefined(rowValue)) {\n      log.error('EnhancedTable', '`rowKey` could be wrong, can not get rowValue from `data` by `rowKey`.');\n      return [];\n    }\n    const childrenNodes = get(p.row, keys.childrenKey);\n    // childrenNodes = true，表示懒加载，直接返回，暂时不做展开处理\n    if (childrenNodes === true) return dataSource;\n    const r = this.treeDataMap.get(rowValue);\n    if (type === 'expand' && r.expanded) return dataSource;\n    if (type === 'fold' && !r.expanded) return dataSource;\n    r.rowIndex = r.rowIndex ?? p.rowIndex;\n    r.expanded = !r.expanded;\n    this.treeDataMap.set(rowValue, r);\n    return this.updateExpandRow(r, dataSource, keys);\n  }\n\n  updateExpandRow(changeRow: TableRowState, dataSource: T[], keys: KeysType): T[] {\n    const { row, rowIndex, expanded } = changeRow;\n    const { treeDataMap } = this;\n    const childrenNodes = get(row, keys.childrenKey);\n    if (!row || !childrenNodes) return dataSource;\n    if (expanded) {\n      updateChildrenRowState(treeDataMap, changeRow, expanded, keys);\n      updateRowExpandLength(treeDataMap, row, childrenNodes.length, 'expand', keys);\n      // eslint-disable-next-line\n      dataSource.splice.apply(dataSource, [rowIndex + 1, 0].concat(childrenNodes));\n    } else {\n      updateChildrenRowState<T>(treeDataMap, changeRow, expanded, keys);\n      const len = changeRow.expandChildrenLength || childrenNodes.length;\n      updateRowExpandLength(treeDataMap, row, -1 * len, 'fold', keys);\n      dataSource.splice(rowIndex + 1, len);\n    }\n    // 展开或收起后，会影响后续节点的 rowIndex，需同步更新\n    updateRowIndex(treeDataMap, dataSource, {\n      rowKey: keys.rowKey,\n      minRowIndex: rowIndex + 1,\n    });\n    return dataSource;\n  }\n\n  /**\n   * 获取当前行全部数据\n   * @param key 行唯一标识\n   * @returns {TableRowState} 当前行数据\n   */\n  getData(key: TableRowValue): TableRowState {\n    return this.treeDataMap.get(key);\n  }\n\n  /**\n   * 更新当前行数据，并返回当前行下标\n   * @param rowValue 当前行唯一标识值\n   * @param newRowData 新行数据\n   * @returns {number} rowIndex 设置的行下标\n   */\n  updateData(rowValue: TableRowValue, newRowData: T, dataSource: T[], keys: KeysType): number {\n    const newRowValue = getUniqueRowValue(newRowData, keys.rowKey);\n    const rowState = this.treeDataMap.get(rowValue);\n    // Map 没有查询到，或者查询到的 rowIndex 值为 -1，均表示当前数据不在 dataSource 列表中，未显示在页面中\n    if (!rowState || rowState.rowIndex === -1) {\n      updateRowData(dataSource, rowValue, newRowData, {\n        rowKey: keys.rowKey,\n        childrenKey: keys.childrenKey,\n      });\n      return -1;\n    }\n\n    // 懒加载处理：children 为 true，则需清空子元素在 map 中的值，而后方便重新加载\n    if (get(newRowData, keys.childrenKey) === true) {\n      const oldChildren = get(rowState.row, keys.childrenKey);\n      if (oldChildren?.length) {\n        for (let i = 0, len = oldChildren.length; i < len; i++) {\n          const rowValue = getUniqueRowValue(oldChildren[i], keys.rowKey);\n          const state = this.treeDataMap.get(rowValue);\n          if (state) {\n            this.treeDataMap.delete(rowValue);\n          }\n        }\n      }\n    }\n\n    const currentRowIndex = rowState.rowIndex;\n    rowState.row = newRowData;\n    rowState.id = newRowValue;\n\n    // 更新父元素中存储的当前元素值\n    if (rowState.parent) {\n      // 更新直接子元素数组\n      const siblings = get(rowState.parent.row, keys.childrenKey);\n      const index = siblings.findIndex((item: T) => getUniqueRowValue(item, keys.rowKey) === rowValue);\n      siblings[index] = newRowData;\n    }\n\n    this.treeDataMap.set(newRowValue, rowState);\n    // rowValue 也发生了变化，需移除 旧 rowValue 数据\n    if (rowValue !== newRowValue) {\n      this.treeDataMap.delete(rowValue);\n    }\n    return currentRowIndex;\n  }\n\n  /**\n   * 移除指定节点\n   * @param key 行唯一标识\n   */\n  remove(key: TableRowValue, dataSource: T[], keys: KeysType): T[] {\n    const r = this.treeDataMap.get(key);\n    if (r && r.rowIndex >= 0) {\n      // 移除当前节点时，展开的节点的子节点需同步移除\n      const removeNumber = (r.expandChildrenLength || 0) + 1;\n      dataSource.splice(r.rowIndex, removeNumber);\n\n      if (r.parent) {\n        const siblings = get(r.parent.row, keys.childrenKey);\n        const index = siblings.findIndex((item: TableRowData) => get(item, keys.rowKey) === key);\n        siblings.splice(index, 1);\n        updateRowExpandLength(this.treeDataMap, r.parent.row, -1 * removeNumber, 'delete', keys);\n      }\n\n      this.treeDataMap.delete(key);\n\n      // 更新 rowIndex 之后的下标\n      updateRowIndex(this.treeDataMap, dataSource, {\n        minRowIndex: r.rowIndex,\n        rowKey: keys.rowKey,\n        type: 'remove',\n      });\n    } else {\n      log.warn('EnhancedTable', 'Can not remove this node, which is not appeared.');\n    }\n    return dataSource;\n  }\n\n  /**\n   * 清除子节点\n   * @param key\n   * @param dataSource\n   * @param keys\n   */\n  removeChildren(key: TableRowValue, dataSource: T[], keys: KeysType): T[] {\n    const r = this.treeDataMap.get(key);\n    if (r && r.rowIndex >= 0) {\n      const removeNumber = r.expandChildrenLength || 0;\n      if (removeNumber) {\n        dataSource.splice(r.rowIndex + 1, removeNumber);\n      }\n      if (r.parent) {\n        updateRowExpandLength(this.treeDataMap, r.parent.row, -1 * removeNumber, 'delete', keys);\n      }\n      r.expandChildrenLength = 0;\n      r.expanded = false;\n      set(r.row, keys.childrenKey, undefined);\n      this.treeDataMap.set(key, r);\n      // 更新 rowIndex 之后的下标\n      if (removeNumber) {\n        updateRowIndex(this.treeDataMap, dataSource, {\n          minRowIndex: r.rowIndex + 1,\n          rowKey: keys.rowKey,\n          type: 'remove',\n        });\n      }\n    } else {\n      log.warn('EnhancedTable', 'Can not remove this node\\'s children, which is not appeared.');\n    }\n    return dataSource;\n  }\n\n  /**\n   * 为当前节点添加子节点，默认添加到最后一个节点。允许添加单个或多个\n   * @param rowValue 当前节点唯一标识\n   * @param newData 待添加的新节点\n   */\n  appendTo(rowValue: string | number, newData: T | T[], dataSource: T[], keys: KeysType): T[] {\n    const state = this.treeDataMap.get(rowValue);\n    if (!this.validateDataExist(state, rowValue)) return dataSource;\n    const children: T[] = get(state.row, keys.childrenKey);\n    // 子节点不存在，则表示为叶子节点\n    const isShowNewNode = state.expanded || !children?.length;\n    // 添加多个子节点时，需去除重复子节点\n    const tmpData = newData instanceof Array ? newData : [newData];\n    const newChildrenData: T[] = [];\n    const newChildrenStates: TableRowState[] = [];\n    let firstNewChildrenIndex = -1;\n    for (let i = 0, len = tmpData.length; i < len; i++) {\n      const oneData = tmpData[i];\n      const newRowValue = getUniqueRowValue(oneData, keys.rowKey);\n      const mapState = this.treeDataMap.get(newRowValue);\n      if (!this.validateDataDoubleExist(mapState, newRowValue)) {\n        log.warn('Table', `Duplicated Data \\`${newRowValue}\\` has been removed.`);\n      } else {\n        const rowIndex = isShowNewNode ? state.rowIndex + (state.expandChildrenLength || 0) + (i + 1) : -1;\n        if (i === 0) {\n          firstNewChildrenIndex = rowIndex;\n        }\n        const newState = {\n          id: newRowValue,\n          row: oneData,\n          rowIndex,\n          level: state.level + 1,\n          expanded: false,\n          expandChildrenLength: 0,\n          disabled: false,\n          path: [...state.path],\n          parent: state,\n        };\n        newState.path = newState.path.concat(newState);\n        newChildrenData.push(oneData);\n        newChildrenStates.push(newState);\n        this.treeDataMap.set(newRowValue, newState);\n      }\n    }\n    if (!newChildrenData.length) return dataSource;\n\n    if (children?.length) {\n      state.row[keys.childrenKey] = state.row[keys.childrenKey].concat(newChildrenData);\n    } else {\n      state.row[keys.childrenKey] = newChildrenData;\n      state.expanded = true;\n    }\n\n    // 如果当前节点为展开状态，则需要继续处理\n    if (isShowNewNode) {\n      dataSource.splice(firstNewChildrenIndex, 0, ...newChildrenData);\n      // 更新父元素及祖先元素展开子节点的数量\n      const newChildrenCount = newChildrenData.length || 1;\n      updateRowExpandLength(this.treeDataMap, state.row, newChildrenCount, 'insert', {\n        rowKey: keys.rowKey,\n        childrenKey: keys.childrenKey,\n      });\n      // 更新 rowIndex 之后的下标\n      updateRowIndex(this.treeDataMap, dataSource, {\n        minRowIndex: firstNewChildrenIndex + newChildrenData.length - 1,\n        rowKey: keys.rowKey,\n        type: 'add',\n        count: 1,\n      });\n    }\n\n    return dataSource;\n  }\n\n  appendToRoot(newData: T | T[], dataSource: T[], keys: KeysType) {\n    const newDataSource = dataSource.concat(newData);\n    const tmpNewData = newData instanceof Array ? newData : [newData];\n    const dataSourceLen = dataSource.length;\n    for (let i = 0, len = tmpNewData.length; i < len; i++) {\n      const rowValue = get(tmpNewData[i], keys.rowKey);\n      if (!rowValue) {\n        log.error('Table', '`rowKey` could be wrong, can not get rowValue from `data` by `rowKey`.');\n        continue;\n      }\n      const state: TableRowState = {\n        id: rowValue,\n        row: tmpNewData[i],\n        rowIndex: dataSourceLen + i,\n        level: 0,\n        expanded: false,\n        expandChildrenLength: 0,\n        disabled: false,\n      };\n      state.path = [state];\n      this.treeDataMap.set(rowValue, state);\n    }\n    return newDataSource;\n  }\n\n  /**\n   * 在当前节点后，插入一个兄弟节点\n   * @param rowValue 当前节点唯一标识\n   * @param newData 待添加的新节点\n   */\n  insertAfter(rowValue: string | number, newData: T, dataSource: T[], keys: KeysType): T[] {\n    return this.insert(rowValue, newData, dataSource, keys, 'after');\n  }\n\n  /**\n   * 在当前节点前，插入一个兄弟节点\n   * @param rowValue 当前节点唯一标识\n   * @param newData 待添加的新节点\n   */\n  insertBefore(rowValue: string | number, newData: T, dataSource: T[], keys: KeysType): T[] {\n    return this.insert(rowValue, newData, dataSource, keys, 'before');\n  }\n\n  insert(rowValue: string | number, newData: T, dataSource: T[], keys: KeysType, type: 'before' | 'after') {\n    const state = this.treeDataMap.get(rowValue);\n    if (!this.validateDataExist(state, rowValue)) return dataSource;\n    const newRowValue = get(newData, keys.rowKey);\n    const mapState = this.treeDataMap.get(newRowValue);\n    if (!this.validateDataDoubleExist(mapState, newRowValue)) return dataSource;\n    const rowIndex = type === 'after' ? state.rowIndex + 1 : state.rowIndex;\n    const newState = {\n      id: newRowValue,\n      row: newData,\n      rowIndex,\n      level: state.level,\n      expanded: false,\n      expandChildrenLength: 0,\n      disabled: false,\n      path: state.path.slice(0, -1),\n      parent: state.parent,\n    };\n    newState.path = newState.path.concat(newState);\n    const dataIndex = type === 'after' ? state.rowIndex + (state.expandChildrenLength + 1) : state.rowIndex;\n    dataSource.splice(dataIndex, 0, newData);\n    const distance = type === 'after' ? 1 : 0;\n    if (state.parent) {\n      const childrenIndex = state.parent.row[keys.childrenKey].findIndex(\n        (t: TableRowData) => rowValue === get(t, keys.rowKey),\n      );\n      state.parent.row[keys.childrenKey].splice(childrenIndex + distance, 0, newData);\n      updateRowExpandLength(this.treeDataMap, state.parent.row, 1, 'insert', keys);\n    }\n    this.treeDataMap.set(newRowValue, newState);\n\n    // 更新 rowIndex 之后的下标\n    updateRowIndex(this.treeDataMap, dataSource, {\n      rowKey: keys.rowKey,\n      minRowIndex: state.rowIndex + 1,\n      type: 'add',\n    });\n\n    return dataSource;\n  }\n\n  /**\n   * 交换数据行\n   * @returns 交换失败返回 false\n   */\n  swapData(\n    dataSource: T[],\n    params: SwapParams<T>,\n    keys: KeysType,\n  ): { dataSource: T[]; result: boolean; code?: number; reason?: string } {\n    const startIndex = params.currentIndex;\n    const endIndex = params.targetIndex;\n    if (startIndex === endIndex) return { dataSource, result: true };\n    const startRowValue = get(params.current, keys.rowKey);\n    const endRowValue = get(params.target, keys.rowKey);\n    const startState = this.treeDataMap.get(startRowValue);\n    const endState = this.treeDataMap.get(endRowValue);\n    if (startState.level !== endState.level) {\n      return {\n        dataSource,\n        result: false,\n        code: TABLE_TREE_ERROR_CODE_NOT_SAME_LEVEL.code,\n        reason: TABLE_TREE_ERROR_CODE_NOT_SAME_LEVEL.reason,\n      };\n    }\n    const startLastIndex = startIndex + startState.expandChildrenLength + 1;\n    const endLastIndex = endIndex + endState.expandChildrenLength + 1;\n    const startRowList = dataSource.slice(startIndex, startLastIndex);\n    const endRowList = dataSource.slice(endIndex, endLastIndex);\n    if (startIndex > endIndex) {\n      const middleRowList = dataSource.slice(endLastIndex, startIndex);\n      const allSwapList = startRowList.concat(endRowList, middleRowList);\n      dataSource.splice(endIndex, allSwapList.length);\n      dataSource.splice(endIndex, 0, ...allSwapList);\n      updateRowIndex(this.treeDataMap, dataSource, {\n        rowKey: keys.rowKey,\n        minRowIndex: endIndex,\n        maxRowIndex: startLastIndex,\n      });\n    } else {\n      const middleRowList = dataSource.slice(startLastIndex, endIndex);\n      const allSwapList = middleRowList.concat(endRowList, startRowList);\n      dataSource.splice(startIndex, allSwapList.length);\n      dataSource.splice(startIndex, 0, ...allSwapList);\n      updateRowIndex(this.treeDataMap, dataSource, {\n        rowKey: keys.rowKey,\n        minRowIndex: startIndex,\n        maxRowIndex: endLastIndex,\n      });\n    }\n\n    // 交换父元素中的两个元素位置\n    if (startState.parent) {\n      const children = startState.parent.row[keys.childrenKey];\n      let count = 0;\n      let targetIndex = -1;\n      let currentIndex = -1;\n      for (let i = 0, len = children.length; i < len; i++) {\n        if (get(children[i], keys.rowKey) === startRowValue) {\n          currentIndex = i;\n          count += 1;\n        }\n        if (get(children[i], keys.rowKey) === endRowValue) {\n          targetIndex = i;\n          count += 1;\n        }\n        if (count >= 2) break;\n      }\n      // 向后拖拽\n      if (currentIndex < targetIndex) {\n        children.splice(targetIndex + 1, 0, params.current);\n        children.splice(currentIndex, 1);\n      } else {\n        // 向前拖拽\n        children.splice(currentIndex, 1);\n        children.splice(targetIndex, 0, params.current);\n      }\n    }\n\n    return { dataSource, result: true };\n  }\n\n  /**\n   * 展开所有节点\n   */\n  expandAll(dataSource: T[], keys: KeysType) {\n    this.expandAllRowIndex = 0;\n    const newData: T[] = [];\n    const expandLoop = (\n      dataSource: T[],\n      keys: KeysType,\n      parent: TableRowState = null,\n    ) => {\n      for (let i = 0, len = dataSource.length; i < len; i++) {\n        const item = dataSource[i];\n        const rowValue = get(item, keys.rowKey);\n        const state = this.treeDataMap.get(rowValue);\n        const children = get(item, keys.childrenKey);\n        state.rowIndex = this.expandAllRowIndex;\n        // children = true is async load\n        if (children !== true && children?.length) {\n          state.expanded = true;\n        }\n        state.expandChildrenLength = children?.length || 0;\n        this.expandAllRowIndex += 1;\n        newData.push(item);\n        this.treeDataMap.set(rowValue, state);\n        if (children?.length) {\n          // 同步更新父元素的展开数量\n          let tmpParent = parent;\n          while (tmpParent?.row) {\n            tmpParent.expandChildrenLength += children.length;\n            this.treeDataMap.set(tmpParent.id, tmpParent);\n            tmpParent = tmpParent.parent;\n          }\n          // 继续子元素\n          expandLoop(children, keys, state);\n        }\n      }\n    };\n    expandLoop(dataSource, keys);\n    return newData;\n  }\n\n  /**\n   * 收起所有节点\n   */\n  foldAll(dataSource: T[], keys: KeysType) {\n    const newData: T[] = [];\n    let index = 0;\n    for (let i = 0, len = dataSource.length; i < len; i++) {\n      const item = dataSource[i];\n      const rowValue = get(item, keys.rowKey);\n      const state = this.treeDataMap.get(rowValue);\n      state.rowIndex = state.level === 0 ? index : -1;\n      state.expanded = false;\n      state.expandChildrenLength = 0;\n      if (state.level === 0) {\n        newData.push(item);\n        index += 1;\n      }\n      const children = get(item, keys.childrenKey);\n      if (children?.length) {\n        this.foldAll(children, keys);\n      }\n    }\n    return newData;\n  }\n\n  /** 获取整个树形结构 */\n  getTreeNode(dataSource: T[], keys: KeysType): T[] {\n    // let isStarted = false;\n    const treeData: T[] = [];\n    for (let i = 0, len = dataSource.length; i < len; i++) {\n      const item = dataSource[i];\n      const rowValue = get(item, keys.rowKey);\n      const state = this.treeDataMap.get(rowValue);\n      // 只需要压入第一层数据\n      if (state.level === 0) {\n        treeData.push(item);\n      }\n    }\n    return treeData;\n  }\n\n  /**\n   * 获取展开的树形节点\n   * @param dataSource 平铺的树形结构数据\n   * @param keys 行唯一标识和子节点的字段名\n   * @param type 'unique' 标识获取展开节点的行唯一标识值，'data' 表示获取展开节点的数据，'all' 表示获取行节点包含展开状态的全部数据\n   * @returns 展开的树形节点\n   */\n  getTreeExpandedRow(dataSource: T[], keys: KeysType, type: 'unique' | 'data' | 'all' = 'data') {\n    const arr: (T | any)[] = [];\n    dataSource.forEach((item) => {\n      const rowValue = get(item, keys.rowKey);\n      const rowState = this.treeDataMap.get(rowValue);\n      if (!rowState.expanded) return;\n      if (type === 'unique') {\n        arr.push(rowValue);\n      } else if (type === 'data') {\n        arr.push(item);\n      } else {\n        arr.push(rowState);\n      }\n    });\n    return arr;\n  }\n\n  /**\n   * 初始化树形结构 Map\n   * @param treeDataMap 树形结构 Map\n   * @param dataSource 数据源\n   * @param column 树形结构列\n   * @param keys 字段映射关系\n   * @param level 层级\n   * @param parent 父元素\n   * @returns void\n   */\n  initialTreeDataMap(\n    treeDataMap: TableTreeDataMap,\n    dataSource: T[],\n    column: PrimaryTableCol,\n    keys: KeysType,\n    level = 0,\n    parent: TableRowState = null,\n  ) {\n    for (let i = 0, len = dataSource.length; i < len; i++) {\n      const item = dataSource[i];\n      const rowValue = getUniqueRowValue(item, keys.rowKey);\n      if (isUndefined(rowValue)) {\n        log.error('EnhancedTable', '`rowKey` could be wrong, can not get rowValue from `data` by `rowKey`.');\n        return;\n      }\n      const children = get(item, keys.childrenKey);\n      const state: TableRowState = {\n        id: rowValue,\n        row: item,\n        rowIndex: level === 0 ? i : -1,\n        level,\n        expanded: false,\n        expandChildrenLength: 0,\n        disabled: isRowSelectedDisabled(column, item, i),\n        parent,\n      };\n      state.path = parent ? parent.path.concat(state) : [state];\n      treeDataMap.set(rowValue, state);\n      if (children?.length) {\n        this.initialTreeDataMap(treeDataMap, children, column, keys, level + 1, state);\n      }\n    }\n  }\n\n  // column.checkProps 和 column.disabled 会影响行的禁用状态，因此当列发生变化时，需要重置禁用状态\n  updateDisabledState(dataSource: T[], column: PrimaryTableCol, keys: KeysType) {\n    for (let i = 0, len = dataSource.length; i < len; i++) {\n      const item = dataSource[i];\n      const rowValue = get(item, keys.rowKey);\n      if (isUndefined(rowValue)) {\n        log.error('EnhancedTable', '`rowKey` could be wrong, can not get rowValue from `data` by `rowKey`.');\n        return;\n      }\n      const state = this.treeDataMap.get(rowValue);\n      state.disabled = isRowSelectedDisabled(column, item, i);\n      this.treeDataMap.set(rowValue, state);\n      const children = get(item, keys.childrenKey);\n      if (children?.length) {\n        this.updateDisabledState(children, column, keys);\n      }\n    }\n  }\n\n  /**\n   * 校验数据合法性\n   */\n  validateDataExist(state: TableRowState, rowValue: string | number) {\n    if (!state) {\n      log.warn('EnhancedTable', `${rowValue} does not exist.`);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * 校验数据是否已存在\n   */\n  validateDataDoubleExist(state: TableRowState, rowValue: string | number) {\n    if (state) {\n      log.warn('EnhancedTable', `Duplicated Key. ${rowValue} already exists.`);\n      return false;\n    }\n    return true;\n  }\n}\n\nexport default TableTreeStore;\n\n/**\n * 更新展开的子节点数量\n * @param rowSate 行数据和状态\n * @param distance 需要调整的展开子节点长度数量，展开时增加，收起时减少。值为负数，表示减\n * @param expanded 展开/收起\n */\nexport function updateRowExpandLength(\n  treeDataMap: TableTreeDataMap,\n  row: TableRowData,\n  distance: number,\n  type: 'expand' | 'fold' | 'delete' | 'insert',\n  keys: KeysType,\n) {\n  let tmp = row;\n  while (tmp) {\n    const state = treeDataMap.get(get(tmp, keys.rowKey));\n    const expandLen = (state.expandChildrenLength || 0) + distance;\n    state.expandChildrenLength = Math.max(0, expandLen);\n    tmp = state?.parent?.row;\n  }\n  // 如果是收起状态，子节点需全部收起，清空子节点展开行数量，设置 expandChildrenLength 为 0\n  if (type === 'fold') {\n    clearRowExpandLength(treeDataMap, row, keys);\n  }\n}\n\nexport function clearRowExpandLength<T>(treeDataMap: TableTreeDataMap, row: T, keys: KeysType) {\n  const children = get(row, keys.childrenKey);\n  if (children?.length) {\n    children.forEach((item: T[]) => {\n      const state = treeDataMap.get(get(item, keys.rowKey));\n      if (!state) return;\n      state.expandChildrenLength = 0;\n      clearRowExpandLength(treeDataMap, state.row, keys);\n    });\n  }\n}\n\n/**\n * 更新子节点行状态，行数据、父节点、层级、路径等数据\n * @param rowState 行状态数据\n * @param expanded 展开或收起\n * @param keys\n */\nexport function updateChildrenRowState<T>(\n  treeDataMap: TableTreeDataMap,\n  rowState: TableRowState,\n  expanded: boolean,\n  keys: KeysType,\n) {\n  const { row, rowIndex } = rowState;\n  const childrenNodes = get(row, keys.childrenKey);\n  childrenNodes.forEach((item: T, kidRowIndex: number) => {\n    const rowValue = get(item, keys.rowKey);\n    const index = expanded ? rowIndex + 1 + kidRowIndex : -1;\n    const curState = treeDataMap.get(rowValue);\n    const newState: TableRowState = {\n      ...curState,\n      row: item,\n      rowIndex: index,\n      expanded: false,\n      parent: rowState,\n    };\n    treeDataMap.set(rowValue, newState);\n    // 父节点展开，子节点不一定展开；父节点收起，则所有子节点收起\n    if (!expanded) {\n      const children = get(item, keys.childrenKey);\n      if (children?.length) {\n        updateChildrenRowState(\n          treeDataMap,\n          {\n            ...newState,\n            rowIndex: -1,\n            expanded: false,\n          } as any,\n          expanded,\n          keys,\n        );\n      }\n    }\n  });\n}\n\nexport function updateRowData<T extends TableRowData = TableRowData>(\n  data: T[],\n  key: string | number,\n  newData: T,\n  keys: KeysType,\n) {\n  for (let i = 0, len = data.length; i < len; i++) {\n    const item = data[i];\n    if (get(item, keys.rowKey) === key) {\n      // eslint-disable-next-line no-param-reassign\n      data[i] = newData;\n      return;\n    }\n    const children: T[] = get(item, keys.childrenKey) || [];\n    if (children?.length) {\n      updateRowData(children, key, newData, keys);\n    }\n  }\n}\n\nexport function updateRowIndex<T>(\n  treeDataMap: TableTreeDataMap,\n  dataSource: T[],\n  extra: {\n    rowKey: string;\n    minRowIndex?: number;\n    maxRowIndex?: number;\n    type?: 'add' | 'remove';\n    count?: number;\n  },\n) {\n  const start = extra.minRowIndex || 0;\n  const end = extra.maxRowIndex || dataSource.length;\n  for (let rowIndex = start; rowIndex < end; rowIndex++) {\n    const item = dataSource[rowIndex];\n    const state = treeDataMap.get(get(item, extra.rowKey));\n    if (!state) {\n      log.warn('Table', 'tree map went wrong');\n    }\n    state.rowIndex = rowIndex + (extra?.count || 1) - 1;\n  }\n}\n\nexport function diffExpandedTreeNode(\n  newExpandedNode: (number | string)[] = [],\n  oldExpandedNode: (number | string)[] = [],\n) {\n  const removedList: (number | string)[] = [];\n  const addedList: (number | string)[] = [];\n  const newExpandedNodeMap: Map<any, boolean> = new Map();\n  const oldExpandedNodeMap: Map<any, boolean> = new Map();\n  for (let i = 0, len = newExpandedNode.length; i < len; i++) {\n    newExpandedNodeMap.set(newExpandedNode[i], true);\n  }\n  for (let i = 0, len = oldExpandedNode.length; i < len; i++) {\n    oldExpandedNodeMap.set(oldExpandedNode[i], true);\n  }\n  for (let i = 0, len = newExpandedNode.length; i < len; i++) {\n    if (!oldExpandedNodeMap.get(newExpandedNode[i])) {\n      addedList.push(newExpandedNode[i]);\n    }\n  }\n  for (let i = 0, len = oldExpandedNode.length; i < len; i++) {\n    if (!newExpandedNodeMap.get(oldExpandedNode[i])) {\n      removedList.push(oldExpandedNode[i]);\n    }\n  }\n  return {\n    removedList,\n    addedList,\n  };\n}\n\nexport type TreeDataMapType = InstanceType<typeof TableTreeStore>['treeDataMap'];\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}