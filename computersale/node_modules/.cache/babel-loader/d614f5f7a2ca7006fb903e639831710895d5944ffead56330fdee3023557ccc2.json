{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.every.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/esnext.iterator.some.js\";\n/**\n * tdesign v1.10.5\n * (c) 2024 tdesign\n * @license MIT\n */\n\nimport { _ as _asyncToGenerator, r as regenerator } from '../../../_chunks/dep-0d047dce.mjs';\nimport { _ as _toConsumableArray } from '../../../_chunks/dep-4a990ea3.mjs';\nimport { _ as _classCallCheck, a as _createClass } from '../../../_chunks/dep-f909a041.mjs';\nimport { _ as _defineProperty } from '../../../_chunks/dep-fa52aa21.mjs';\nimport { i as isNull_1 } from '../../../_chunks/dep-73384992.mjs';\nimport { i as isFunction_1 } from '../../../_chunks/dep-06dcbf4c.mjs';\nimport { i as isNumber_1 } from '../../../_chunks/dep-889e457b.mjs';\nimport { u as uniqueId_1 } from '../../../_chunks/dep-e4a8ef7d.mjs';\nimport { i as isBoolean_1 } from '../../../_chunks/dep-df472119.mjs';\nimport { i as isNil_1 } from '../../../_chunks/dep-d2f4e062.mjs';\nimport { g as get_1 } from '../../../_chunks/dep-ae202bc0.mjs';\nimport { createNodeModel } from './tree-node-model.mjs';\nimport '../log/index.mjs';\nimport log from '../log/log.mjs';\nimport '../../../_chunks/dep-4659d73b.mjs';\nimport '../../../_chunks/dep-eca422c3.mjs';\nimport '../../../_chunks/dep-593f2b67.mjs';\nimport '../../../_chunks/dep-bf7257e7.mjs';\nimport '../../../_chunks/dep-2b09875b.mjs';\nimport '../../../_chunks/dep-cda4f568.mjs';\nimport '../../../_chunks/dep-29ef8419.mjs';\nimport '../../../_chunks/dep-7932c2e8.mjs';\nimport '../../../_chunks/dep-eae2a67e.mjs';\nimport '../../../_chunks/dep-626c497d.mjs';\nimport '../../../_chunks/dep-ab4bb9b8.mjs';\nimport '../../../_chunks/dep-aeaef131.mjs';\nimport '../../../_chunks/dep-6ab5363f.mjs';\nimport '../../../_chunks/dep-6dc3d0e1.mjs';\nimport '../../../_chunks/dep-76958824.mjs';\nimport '../../../_chunks/dep-e9841b9e.mjs';\nimport '../../../_chunks/dep-58a62202.mjs';\nimport '../../../_chunks/dep-88ae49da.mjs';\nimport '../../../_chunks/dep-5922c8f3.mjs';\nimport '../../../_chunks/dep-92f86d1d.mjs';\nimport '../../../_chunks/dep-1a4bb2f2.mjs';\nimport '../../../_chunks/dep-cc8ebcde.mjs';\nimport '../../../_chunks/dep-f5579c03.mjs';\nimport '../../../_chunks/dep-49aeee3c.mjs';\nimport '../../../_chunks/dep-b5bf85f5.mjs';\nimport '../../../_chunks/dep-3c65fae8.mjs';\nimport '../../../_chunks/dep-ec0bbd9f.mjs';\nimport '../../../_chunks/dep-1b78414a.mjs';\nimport '../../../_chunks/dep-d84f19b3.mjs';\nimport '../../../_chunks/dep-732f0b7d.mjs';\nimport '../../../_chunks/dep-88c8d9ed.mjs';\nimport '../../../_chunks/dep-2f6e28a0.mjs';\nimport '../../../_chunks/dep-1725b1c7.mjs';\nimport '../../../_chunks/dep-4ec29b23.mjs';\nimport '../../../_chunks/dep-02f9394e.mjs';\nimport '../../../_chunks/dep-400ec705.mjs';\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar setableStatus = {\n  expandMutex: null,\n  activable: null,\n  checkable: null,\n  draggable: null,\n  loading: false\n};\nvar setableProps = Object.keys(setableStatus);\nvar syncableProps = [].concat(setableProps, [\"actived\", \"expanded\", \"checked\"]);\nvar privateKey = \"__tdesign_id__\";\nvar TreeNode = /*#__PURE__*/function () {\n  function TreeNode(tree, data, parent) {\n    var _this = this;\n    _classCallCheck(this, TreeNode);\n    _defineProperty(this, \"tree\", void 0);\n    _defineProperty(this, privateKey, void 0);\n    _defineProperty(this, \"value\", void 0);\n    _defineProperty(this, \"label\", void 0);\n    _defineProperty(this, \"data\", void 0);\n    _defineProperty(this, \"parent\", void 0);\n    _defineProperty(this, \"children\", void 0);\n    _defineProperty(this, \"model\", void 0);\n    _defineProperty(this, \"vmIsLeaf\", void 0);\n    _defineProperty(this, \"vmIsFirst\", void 0);\n    _defineProperty(this, \"vmIsLast\", void 0);\n    _defineProperty(this, \"vmIsRest\", void 0);\n    _defineProperty(this, \"vmIsLocked\", void 0);\n    _defineProperty(this, \"expanded\", void 0);\n    _defineProperty(this, \"expandMutex\", void 0);\n    _defineProperty(this, \"actived\", void 0);\n    _defineProperty(this, \"activable\", void 0);\n    _defineProperty(this, \"checkable\", void 0);\n    _defineProperty(this, \"vmCheckable\", void 0);\n    _defineProperty(this, \"checked\", void 0);\n    _defineProperty(this, \"indeterminate\", void 0);\n    _defineProperty(this, \"disabled\", void 0);\n    _defineProperty(this, \"draggable\", void 0);\n    _defineProperty(this, \"visible\", void 0);\n    _defineProperty(this, \"level\", void 0);\n    _defineProperty(this, \"loading\", void 0);\n    this.data = data;\n    this.tree = tree;\n    var config = tree.config || {};\n    var prefix = config.prefix || \"t\";\n    var keys = config.keys || {};\n    var propChildren = keys.children || \"children\";\n    var propLabel = keys.label || \"label\";\n    var propValue = keys.value || \"value\";\n    var propDisabled = keys.disabled || \"disabled\";\n    this.model = null;\n    this.children = null;\n    this.level = 0;\n    this.vmCheckable = false;\n    this.vmIsLeaf = false;\n    this.vmIsFirst = false;\n    this.vmIsLast = false;\n    this.vmIsRest = false;\n    this.vmIsLocked = false;\n    this.visible = false;\n    this.actived = false;\n    this.checked = false;\n    this.indeterminate = false;\n    this.loading = false;\n    this.expanded = config.expandAll;\n    this.activable = null;\n    this.checkable = null;\n    this.expandMutex = null;\n    this.draggable = null;\n    this[privateKey] = uniqueId_1(prefix);\n    this.value = isNil_1(get_1(data, propValue)) ? this[privateKey] : get_1(data, propValue);\n    var nodeMap = tree.nodeMap,\n      privateMap = tree.privateMap;\n    if (nodeMap.get(this.value)) {\n      log.warn(\"Tree\", \"Dulplicate value: \".concat(this.value));\n    }\n    nodeMap.set(this.value, this);\n    privateMap.set(this[privateKey], this);\n    this.label = get_1(data, propLabel) || \"\";\n    this.disabled = get_1(data, propDisabled) || false;\n    var children = data[propChildren];\n    if (children === true) {\n      this.children = children;\n    }\n    if (parent && parent instanceof TreeNode) {\n      this.parent = parent;\n    } else {\n      this.parent = null;\n    }\n    syncableProps.forEach(function (prop) {\n      if (typeof data[prop] !== \"undefined\") {\n        _this[prop] = data[prop];\n      }\n    });\n    this.initActived();\n    this.initExpanded();\n    if (Array.isArray(children)) {\n      this.append(children);\n    } else if (children === true && !config.lazy) {\n      this.loadChildren();\n    }\n    this.initChecked();\n    this.updateChecked();\n    this.update();\n    tree.reflow(this);\n  }\n  return _createClass(TreeNode, [{\n    key: \"initChecked\",\n    value: function initChecked() {\n      var tree = this.tree,\n        value = this.value,\n        parent = this.parent;\n      var checkedMap = tree.checkedMap;\n      var checkStrictly = tree.config.checkStrictly;\n      if (this.checked) {\n        checkedMap.set(value, true);\n      }\n      if (!checkStrictly && parent !== null && parent !== void 0 && parent.checked) {\n        checkedMap.set(value, true);\n      }\n    }\n  }, {\n    key: \"initExpanded\",\n    value: function initExpanded() {\n      var tree = this.tree;\n      var expanded = this.expanded;\n      var config = tree.config;\n      if (isNumber_1(config.expandLevel) && this.getLevel() < config.expandLevel) {\n        tree.expandedMap.set(this.value, true);\n        expanded = true;\n      }\n      if (this.children === true && config.lazy) {\n        expanded = false;\n      }\n      if (expanded) {\n        tree.expandedMap.set(this.value, true);\n      } else {\n        tree.expandedMap[\"delete\"](this.value);\n      }\n      this.expanded = expanded;\n    }\n  }, {\n    key: \"initActived\",\n    value: function initActived() {\n      var tree = this.tree,\n        actived = this.actived;\n      if (actived && this.isActivable()) {\n        tree.activedMap.set(this.value, true);\n      }\n    }\n  }, {\n    key: \"append\",\n    value: function append(data) {\n      var _this2 = this;\n      var list = [];\n      if (!Array.isArray(data)) {\n        list.push(data);\n      } else {\n        list.push.apply(list, _toConsumableArray(data));\n      }\n      if (list.length <= 0) {\n        return;\n      }\n      if (!Array.isArray(this.children)) {\n        this.children = [];\n      }\n      var children = this.children,\n        tree = this.tree;\n      list.forEach(function (item) {\n        var node = null;\n        if (item instanceof TreeNode) {\n          node = item;\n          node.appendTo(_this2.tree, _this2);\n        } else {\n          node = new TreeNode(_this2.tree, item, _this2);\n          children.push(node);\n        }\n      });\n      tree.reflow(this);\n      this.updateRelated();\n    }\n  }, {\n    key: \"appendTo\",\n    value: function appendTo(tree, parent, index) {\n      var _this3 = this;\n      var parentNode = parent;\n      var targetIndex = -1;\n      if (isNumber_1(index)) {\n        targetIndex = index;\n      }\n      var targetParents = (parentNode === null || parentNode === void 0 ? void 0 : parentNode.getParents()) || [];\n      var includeCurrent = targetParents.some(function (pnode) {\n        return pnode === _this3;\n      });\n      if (includeCurrent) {\n        throw new Error(\"\\u65E0\\u6CD5\\u5C06\\u7236\\u8282\\u70B9\\u63D2\\u5165\\u5230\\u5B50\\u8282\\u70B9\");\n      }\n      if (parentNode === this) {\n        throw new Error(\"\\u65E0\\u6CD5\\u5C06\\u8282\\u70B9\\u63D2\\u5165\\u5230\\u672C\\u8282\\u70B9\");\n      }\n      if (Array.isArray(parentNode === null || parentNode === void 0 ? void 0 : parentNode.children)) {\n        var targetPosNode = parentNode === null || parentNode === void 0 ? void 0 : parentNode.children[targetIndex];\n        if (targetPosNode && targetPosNode === this) {\n          return;\n        }\n      }\n      var siblings = null;\n      if (parentNode instanceof TreeNode) {\n        if (!Array.isArray(parentNode === null || parentNode === void 0 ? void 0 : parentNode.children)) {\n          parentNode.children = [];\n        }\n        siblings = parent.children;\n      } else {\n        siblings = tree.children;\n      }\n      if (!Array.isArray(siblings)) {\n        throw new Error(\"\\u65E0\\u6CD5\\u63D2\\u5165\\u5230\\u76EE\\u6807\\u4F4D\\u7F6E\\uFF0C\\u53EF\\u63D2\\u5165\\u7684\\u8282\\u70B9\\u5217\\u8868\\u4E0D\\u5B58\\u5728\");\n      }\n      var prevLength = siblings.length;\n      var prevIndex = this.getIndex();\n      this.remove();\n      if (isNumber_1(index)) {\n        var targetIndex2 = index;\n        if (parentNode === this.parent) {\n          var curLength = siblings.length;\n          if (curLength < prevLength && prevIndex <= targetIndex2) {\n            targetIndex2 -= 1;\n          }\n        }\n        siblings.splice(targetIndex2, 0, this);\n      } else {\n        siblings.push(this);\n      }\n      this.parent = parentNode;\n      var nodes = this.walk();\n      nodes.forEach(function (item) {\n        var node = item;\n        node.tree = tree;\n        tree.nodeMap.set(node.value, node);\n        tree.privateMap.set(node[privateKey], node);\n        if (node.expanded) {\n          tree.expandedMap.set(node.value, true);\n        }\n      });\n      var updateNodes = (parentNode === null || parentNode === void 0 ? void 0 : parentNode.walk()) || tree.children.map(function (item) {\n        return item.walk();\n      }).flat();\n      updateNodes.forEach(function (node) {\n        node.update();\n        node.updateChecked();\n      });\n      tree.reflow();\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(item, index) {\n      var tree = this.tree,\n        parent = this.parent;\n      var siblings = this.getSiblings();\n      var node = null;\n      if (item instanceof TreeNode) {\n        node = item;\n        node.appendTo(tree, parent, index);\n      } else if (item) {\n        node = new TreeNode(tree, item, parent);\n        if (isNumber_1(index)) {\n          siblings.splice(index, 0, node);\n        }\n        siblings.forEach(function (sibling) {\n          sibling.update();\n        });\n      }\n      tree.reflow();\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(newData) {\n      var index = this.getIndex();\n      this.insert(newData, index);\n    }\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(newData) {\n      var index = this.getIndex();\n      this.insert(newData, index + 1);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var tree = this.tree;\n      var nodes = this.walk();\n      var siblings = this.getSiblings();\n      var index = this.getIndex();\n      if (Array.isArray(siblings)) {\n        siblings.splice(index, 1);\n      }\n      nodes.forEach(function (node) {\n        node.clean();\n      });\n      siblings.forEach(function (node) {\n        node.update();\n      });\n      this.updateParents();\n      tree.reflow();\n    }\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      var tree = this.tree,\n        value = this.value;\n      tree.activedMap[\"delete\"](value);\n      tree.checkedMap[\"delete\"](value);\n      tree.expandedMap[\"delete\"](value);\n      tree.nodeMap[\"delete\"](value);\n      tree.filterMap[\"delete\"](value);\n      tree.privateMap[\"delete\"](this[privateKey]);\n    }\n  }, {\n    key: \"loadChildren\",\n    value: function () {\n      var _loadChildren = _asyncToGenerator(/*#__PURE__*/regenerator.mark(function _callee() {\n        var config, list;\n        return regenerator.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              config = get_1(this, \"tree.config\") || {};\n              if (!(this.children === true && !this.loading)) {\n                _context.next = 13;\n                break;\n              }\n              if (!isFunction_1(config.load)) {\n                _context.next = 13;\n                break;\n              }\n              this.loading = true;\n              this.update();\n              list = [];\n              _context.next = 8;\n              return config.load(this);\n            case 8:\n              list = _context.sent;\n              this.tree.emit(\"load\", {\n                node: this,\n                data: list\n              });\n              this.loading = false;\n              if (Array.isArray(list) && list.length > 0) {\n                this.append(list);\n              } else {\n                this.children = false;\n              }\n              this.update();\n            case 13:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function loadChildren() {\n        return _loadChildren.apply(this, arguments);\n      }\n      return loadChildren;\n    }()\n  }, {\n    key: \"set\",\n    value: function set(item) {\n      var _this4 = this;\n      var tree = this.tree;\n      var keys = Object.keys(item);\n      keys.forEach(function (key) {\n        if (hasOwnProperty.call(setableStatus, key) || key === \"label\") {\n          _this4[key] = item[key];\n        }\n        if (key === \"disabled\") {\n          _this4.setDisabled(item[key]);\n        }\n      });\n      tree.updated(this);\n    }\n  }, {\n    key: \"getParent\",\n    value: function getParent() {\n      return this.parent;\n    }\n  }, {\n    key: \"getParents\",\n    value: function getParents() {\n      var parents = [];\n      var node = this.parent;\n      while (node) {\n        parents.push(node);\n        node = node.parent;\n      }\n      return parents;\n    }\n  }, {\n    key: \"getSiblings\",\n    value: function getSiblings() {\n      var parent = this.parent,\n        tree = this.tree;\n      var list = [];\n      if (parent) {\n        if (Array.isArray(parent.children)) {\n          list = parent.children;\n        }\n      } else if (tree) {\n        list = tree.children;\n      }\n      return list;\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren(deep) {\n      var childrenModel = false;\n      var children = this.children;\n      if (Array.isArray(children)) {\n        if (children.length > 0) {\n          if (deep) {\n            var nodes = this.walk();\n            nodes.shift();\n            childrenModel = nodes.map(function (item) {\n              return item.getModel();\n            });\n          } else {\n            childrenModel = children.map(function (item) {\n              return item.getModel();\n            });\n          }\n        } else {\n          childrenModel = false;\n        }\n      } else if (isBoolean_1(children)) {\n        childrenModel = children;\n      }\n      return childrenModel;\n    }\n  }, {\n    key: \"getRoot\",\n    value: function getRoot() {\n      var parents = this.getParents();\n      return parents[parents.length - 1] || null;\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex() {\n      var list = this.getSiblings();\n      return list.indexOf(this);\n    }\n  }, {\n    key: \"getPath\",\n    value: function getPath() {\n      var nodes = this.getParents();\n      nodes.unshift(this);\n      return nodes.reverse();\n    }\n  }, {\n    key: \"getLevel\",\n    value: function getLevel() {\n      var parents = this.getParents();\n      return parents.length;\n    }\n  }, {\n    key: \"isRest\",\n    value: function isRest() {\n      var _this$tree = this.tree,\n        config = _this$tree.config,\n        filterMap = _this$tree.filterMap,\n        hasFilter = _this$tree.hasFilter;\n      var rest = false;\n      if (hasFilter) {\n        var nodeModel = this.getModel();\n        rest = config.filter(nodeModel);\n      }\n      if (rest) {\n        filterMap.set(this.value, true);\n      } else if (filterMap.get(this.value)) {\n        filterMap[\"delete\"](this.value);\n      }\n      return rest;\n    }\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      var _this$tree2 = this.tree,\n        nodeMap = _this$tree2.nodeMap,\n        hasFilter = _this$tree2.hasFilter,\n        config = _this$tree2.config;\n      var allowFoldNodeOnFilter = config.allowFoldNodeOnFilter;\n      var visible = true;\n      if (!nodeMap.get(this.value)) {\n        return false;\n      }\n      if (hasFilter && !allowFoldNodeOnFilter) {\n        visible = this.vmIsLocked || this.vmIsRest;\n        return visible;\n      }\n      var expandVisible = true;\n      var parents = this.getParents();\n      if (parents.length > 0) {\n        expandVisible = parents.every(function (node) {\n          return node.expanded;\n        });\n      }\n      if (hasFilter) {\n        visible = expandVisible && (this.vmIsRest || this.vmIsLocked);\n      } else {\n        visible = expandVisible;\n      }\n      return visible;\n    }\n  }, {\n    key: \"isDisabledState\",\n    value: function isDisabledState() {\n      var tree = this.tree,\n        parent = this.parent;\n      var config = tree.config;\n      var disabled = config.disabled,\n        disableCheck = config.disableCheck,\n        checkStrictly = config.checkStrictly;\n      var state = disabled || false;\n      if (this.disabled) {\n        state = true;\n      }\n      if (!checkStrictly && parent !== null && parent !== void 0 && parent.isDisabledState()) {\n        state = true;\n      }\n      if (typeof disableCheck === \"boolean\") {\n        if (disableCheck) {\n          state = true;\n        }\n      } else if (typeof disableCheck === \"function\") {\n        if (disableCheck(this.getModel())) {\n          state = true;\n        }\n      }\n      return state;\n    }\n  }, {\n    key: \"isDisabled\",\n    value: function isDisabled() {\n      var tree = this.tree;\n      var hasFilter = tree.hasFilter,\n        config = tree.config;\n      var allowFoldNodeOnFilter = config.allowFoldNodeOnFilter;\n      if (hasFilter && !allowFoldNodeOnFilter && this.vmIsLocked && !this.vmIsRest) {\n        return true;\n      }\n      return this.isDisabledState();\n    }\n  }, {\n    key: \"isDraggable\",\n    value: function isDraggable() {\n      var state = !!get_1(this, \"tree.config.draggable\");\n      if (typeof this.draggable === \"boolean\") {\n        state = this.draggable;\n      }\n      return state;\n    }\n  }, {\n    key: \"isExpandMutex\",\n    value: function isExpandMutex() {\n      var state = !!get_1(this, \"tree.config.expandMutex\");\n      if (typeof this.expandMutex === \"boolean\") {\n        state = this.expandMutex;\n      }\n      return state;\n    }\n  }, {\n    key: \"isActivable\",\n    value: function isActivable() {\n      var state = !!get_1(this, \"tree.config.activable\");\n      if (typeof this.activable === \"boolean\") {\n        state = this.activable;\n      }\n      return state;\n    }\n  }, {\n    key: \"isCheckable\",\n    value: function isCheckable() {\n      var state = !!get_1(this, \"tree.config.checkable\");\n      if (typeof this.checkable === \"boolean\") {\n        state = this.checkable;\n      }\n      return state;\n    }\n  }, {\n    key: \"isActived\",\n    value: function isActived(map) {\n      var tree = this.tree,\n        value = this.value;\n      var activedMap = map || tree.activedMap;\n      return !!(tree.nodeMap.get(value) && activedMap.get(value));\n    }\n  }, {\n    key: \"isExpanded\",\n    value: function isExpanded(map) {\n      var tree = this.tree,\n        value = this.value,\n        vmIsLocked = this.vmIsLocked;\n      var hasFilter = tree.hasFilter,\n        config = tree.config;\n      var allowFoldNodeOnFilter = config.allowFoldNodeOnFilter;\n      if (hasFilter && !allowFoldNodeOnFilter && vmIsLocked) return true;\n      var expandedMap = map || tree.expandedMap;\n      return !!(tree.nodeMap.get(value) && expandedMap.get(value));\n    }\n  }, {\n    key: \"isChecked\",\n    value: function isChecked(map) {\n      var children = this.children,\n        tree = this.tree,\n        value = this.value;\n      var _tree$config = tree.config,\n        checkStrictly = _tree$config.checkStrictly,\n        valueMode = _tree$config.valueMode;\n      if (!tree.nodeMap.get(value)) return false;\n      if (!this.isCheckable()) return false;\n      var checkedMap = map || tree.checkedMap;\n      if (checkStrictly) {\n        return !!checkedMap.get(value);\n      }\n      var checked = false;\n      if (checkedMap.get(value) && (valueMode !== \"onlyLeaf\" || this.isLeaf())) {\n        return true;\n      }\n      if (Array.isArray(children) && children.length > 0) {\n        checked = children.every(function (node) {\n          var childIsChecked = node.isChecked(checkedMap);\n          return childIsChecked;\n        });\n      } else {\n        var parents = this.getParents();\n        checked = parents.some(function (node) {\n          return checkedMap.get(node.value);\n        });\n      }\n      return checked;\n    }\n  }, {\n    key: \"isIndeterminate\",\n    value: function isIndeterminate() {\n      var children = this.children,\n        tree = this.tree,\n        value = this.value;\n      var checkStrictly = tree.config.checkStrictly;\n      if (!tree.nodeMap.get(value)) return false;\n      if (!this.isCheckable()) return false;\n      if (checkStrictly) return false;\n      if (!Array.isArray(children)) return false;\n      var childChecked = null;\n      var indeterminate = children.some(function (node) {\n        if (node.isIndeterminate()) {\n          return true;\n        }\n        if (isNull_1(childChecked)) {\n          childChecked = node.isChecked();\n        }\n        if (childChecked !== node.isChecked()) {\n          return true;\n        }\n        return false;\n      });\n      return indeterminate;\n    }\n  }, {\n    key: \"isFirst\",\n    value: function isFirst() {\n      var siblings = this.getSiblings();\n      return siblings[0] === this;\n    }\n  }, {\n    key: \"isLast\",\n    value: function isLast() {\n      var siblings = this.getSiblings();\n      return siblings[siblings.length - 1] === this;\n    }\n  }, {\n    key: \"isLeaf\",\n    value: function isLeaf() {\n      var isLeaf = false;\n      if (Array.isArray(this.children)) {\n        isLeaf = this.children.length <= 0;\n      } else {\n        isLeaf = !this.children;\n      }\n      return isLeaf;\n    }\n  }, {\n    key: \"lock\",\n    value: function lock(lockState) {\n      this.vmIsLocked = lockState;\n      this.expanded = this.isExpanded();\n      this.visible = this.isVisible();\n    }\n  }, {\n    key: \"afterExpanded\",\n    value: function afterExpanded() {\n      this.update();\n      if (this.expanded && this.children === true) {\n        this.loadChildren();\n      }\n      this.updateChildren();\n    }\n  }, {\n    key: \"toggleExpanded\",\n    value: function toggleExpanded(opts) {\n      return this.setExpanded(!this.isExpanded(), opts);\n    }\n  }, {\n    key: \"setExpanded\",\n    value: function setExpanded(expanded, opts) {\n      var tree = this.tree;\n      var config = tree.config;\n      var options = _objectSpread({\n        directly: false\n      }, opts);\n      var map = tree.expandedMap;\n      if (!options.directly) {\n        map = new Map(tree.expandedMap);\n      }\n      if (expanded) {\n        var shouldExpandNodes = [];\n        shouldExpandNodes.push(this);\n        if (config.expandParent) {\n          this.getParents().forEach(function (node) {\n            shouldExpandNodes.push(node);\n          });\n        }\n        shouldExpandNodes.forEach(function (node) {\n          var isExpandMutex = false;\n          if (node.parent) {\n            isExpandMutex = node.parent.isExpandMutex();\n          } else {\n            var _tree$config2;\n            isExpandMutex = tree === null || tree === void 0 || (_tree$config2 = tree.config) === null || _tree$config2 === void 0 ? void 0 : _tree$config2.expandMutex;\n          }\n          if (isExpandMutex) {\n            var siblings = node.getSiblings();\n            siblings.forEach(function (snode) {\n              map[\"delete\"](snode.value);\n              snode.update();\n              snode.updateChildren();\n            });\n          }\n          map.set(node.value, true);\n          node.update();\n          node.updateChildren();\n        });\n      } else {\n        map[\"delete\"](this.value);\n      }\n      if (options.directly) {\n        this.afterExpanded();\n      }\n      return tree.getExpanded(map);\n    }\n  }, {\n    key: \"toggleActived\",\n    value: function toggleActived(opts) {\n      return this.setActived(!this.isActived(), opts);\n    }\n  }, {\n    key: \"setActived\",\n    value: function setActived(actived, opts) {\n      var tree = this.tree;\n      var options = _objectSpread({\n        isAction: true,\n        directly: false\n      }, opts);\n      var config = tree.config || {};\n      var map = tree.activedMap;\n      if (!options.directly) {\n        map = new Map(tree.activedMap);\n      }\n      if (options.isAction && this.isDisabledState()) {\n        return tree.getActived(map);\n      }\n      if (this.isActivable()) {\n        if (actived) {\n          var prevKeys = Array.from(map.keys());\n          if (!config.activeMultiple) {\n            map.clear();\n          }\n          prevKeys.forEach(function (value) {\n            var node = tree.getNode(value);\n            node === null || node === void 0 || node.update();\n          });\n          map.set(this.value, true);\n        } else {\n          map[\"delete\"](this.value);\n        }\n      }\n      this.update();\n      return tree.getActived(map);\n    }\n  }, {\n    key: \"hasEnableUnCheckedChild\",\n    value: function hasEnableUnCheckedChild() {\n      var children = this.children;\n      if (!Array.isArray(children) || children.length <= 0) {\n        return false;\n      }\n      var state = false;\n      children.some(function (child) {\n        if (child.isDisabledState()) return false;\n        if (child.isChecked()) return false;\n        if (child.isIndeterminate()) {\n          if (child.hasEnableUnCheckedChild()) {\n            state = true;\n            return true;\n          }\n          return false;\n        }\n        state = true;\n        return true;\n      });\n      return state;\n    }\n  }, {\n    key: \"toggleChecked\",\n    value: function toggleChecked(opts) {\n      if (this.isIndeterminate()) {\n        var expectState = this.hasEnableUnCheckedChild();\n        return this.setChecked(expectState, opts);\n      }\n      return this.setChecked(!this.isChecked(), opts);\n    }\n  }, {\n    key: \"setChecked\",\n    value: function setChecked(checked, opts) {\n      var tree = this.tree;\n      var config = tree.config || {};\n      var options = _objectSpread({\n        isAction: true,\n        directly: false\n      }, opts);\n      var map = tree.checkedMap;\n      if (!options.directly) {\n        map = new Map(tree.checkedMap);\n      }\n      if (!this.isCheckable()) {\n        return tree.getChecked(map);\n      }\n      if (options.isAction && this.isDisabledState()) {\n        return tree.getChecked(map);\n      }\n      if (checked === this.isChecked()) {\n        var shouldSet = this.isIndeterminate() && !this.hasEnableUnCheckedChild();\n        if (!shouldSet) {\n          return tree.getChecked(map);\n        }\n      }\n      if (checked) {\n        map.set(this.value, true);\n      } else {\n        map[\"delete\"](this.value);\n      }\n      if (config.checkStrictly) {\n        if (options.directly) {\n          this.updateChecked();\n        }\n      } else {\n        this.spreadChildrenChecked(checked, map, options);\n        this.spreadParentChecked(checked, map, options);\n        if (options.directly) {\n          var relatedNodes = tree.getRelatedNodes([this.value], {\n            reverse: true\n          });\n          relatedNodes.forEach(function (node) {\n            node.updateChecked();\n          });\n        }\n      }\n      return tree.getChecked(map);\n    }\n  }, {\n    key: \"spreadParentChecked\",\n    value: function spreadParentChecked(checked, map, opts) {\n      var options = _objectSpread({\n        isAction: true,\n        directly: false\n      }, opts);\n      if (!this.isCheckable()) return;\n      var children = this.children;\n      if (Array.isArray(children) && children.length > 0) {\n        map[\"delete\"](this.value);\n      }\n      var parent = this.parent;\n      if (!parent) return;\n      parent.spreadParentChecked(checked, map, options);\n    }\n  }, {\n    key: \"spreadChildrenChecked\",\n    value: function spreadChildrenChecked(checked, map, opts) {\n      var options = _objectSpread({\n        isAction: true,\n        directly: false\n      }, opts);\n      if (!this.isCheckable()) return;\n      if (options.isAction && this.isDisabledState()) return;\n      var children = this.children;\n      if (!Array.isArray(children)) return;\n      if (children.length <= 0) return;\n      map[\"delete\"](this.value);\n      children.forEach(function (node) {\n        if (options.isAction && node.isDisabledState()) return;\n        if (checked) {\n          map.set(node.value, true);\n        } else {\n          map[\"delete\"](node.value);\n        }\n        node.spreadChildrenChecked(checked, map, options);\n      });\n    }\n  }, {\n    key: \"setDisabled\",\n    value: function setDisabled(disabled) {\n      this.disabled = disabled;\n      this.update();\n      this.updateChildren();\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.level = this.getLevel();\n      this.vmIsFirst = this.isFirst();\n      this.vmIsLast = this.isLast();\n      this.vmIsLeaf = this.isLeaf();\n      this.vmCheckable = this.isCheckable();\n      this.vmIsRest = this.isRest();\n      this.actived = this.isActived();\n      this.expanded = this.isExpanded();\n      this.visible = this.isVisible();\n      this.tree.updated(this);\n    }\n  }, {\n    key: \"updateChecked\",\n    value: function updateChecked() {\n      var tree = this.tree,\n        value = this.value;\n      var checkedMap = tree.checkedMap;\n      this.checked = this.isChecked();\n      this.indeterminate = this.isIndeterminate();\n      if (this.checked) {\n        checkedMap.set(value, true);\n      }\n      tree.updated(this);\n    }\n  }, {\n    key: \"updateChildren\",\n    value: function updateChildren() {\n      var _this5 = this;\n      this.spreadChildren(function (node) {\n        if (node === _this5) return;\n        node.update();\n        node.updateChecked();\n      });\n    }\n  }, {\n    key: \"updateParents\",\n    value: function updateParents() {\n      var _this6 = this;\n      this.spreadParents(function (node) {\n        if (node === _this6) return;\n        node.update();\n        node.updateChecked();\n      });\n    }\n  }, {\n    key: \"updateRelated\",\n    value: function updateRelated() {\n      var tree = this.tree;\n      var relatedNodes = tree.getRelatedNodes([this.value]);\n      relatedNodes.forEach(function (node) {\n        node.update();\n        node.updateChecked();\n      });\n    }\n  }, {\n    key: \"walk\",\n    value: function walk() {\n      var list = [];\n      this.spreadChildren(function (node) {\n        list.push(node);\n      });\n      return list;\n    }\n  }, {\n    key: \"spreadChildren\",\n    value: function spreadChildren(fn) {\n      fn(this);\n      var children = this.children;\n      if (Array.isArray(children) && children.length > 0) {\n        children.forEach(function (node) {\n          node === null || node === void 0 || node.spreadChildren(fn);\n        });\n      }\n    }\n  }, {\n    key: \"spreadParents\",\n    value: function spreadParents(fn) {\n      fn(this);\n      var parent = this.parent;\n      if (!parent) return;\n      parent === null || parent === void 0 || parent.spreadParents(fn);\n    }\n  }, {\n    key: \"getModel\",\n    value: function getModel() {\n      var model = this.model;\n      if (!model) {\n        model = createNodeModel(this);\n        this.model = model;\n      }\n      return model;\n    }\n  }]);\n}();\nexport { TreeNode, TreeNode as default, privateKey, setableProps, setableStatus, syncableProps };","map":{"version":3,"names":["hasOwnProperty","Object","prototype","setableStatus","expandMutex","activable","checkable","draggable","loading","setableProps","keys","syncableProps","concat","privateKey","TreeNode","tree","data","parent","_this","_classCallCheck","_defineProperty","config","prefix","propChildren","children","propLabel","label","propValue","value","propDisabled","disabled","model","level","vmCheckable","vmIsLeaf","vmIsFirst","vmIsLast","vmIsRest","vmIsLocked","visible","actived","checked","indeterminate","expanded","expandAll","uniqueId_1","isNil_1","get_1","nodeMap","privateMap","get","log","warn","set","forEach","prop","initActived","initExpanded","Array","isArray","append","lazy","loadChildren","initChecked","updateChecked","update","reflow","_createClass","key","checkedMap","checkStrictly","isNumber_1","expandLevel","getLevel","expandedMap","isActivable","activedMap","_this2","list","push","apply","_toConsumableArray","length","item","node","appendTo","updateRelated","index","_this3","parentNode","targetIndex","targetParents","getParents","includeCurrent","some","pnode","Error","targetPosNode","siblings","prevLength","prevIndex","getIndex","remove","targetIndex2","curLength","splice","nodes","walk","updateNodes","map","flat","insert","getSiblings","sibling","insertBefore","newData","insertAfter","clean","updateParents","filterMap","_loadChildren","_asyncToGenerator","regenerator","mark","_callee","wrap","_callee$","_context","prev","next","isFunction_1","load","sent","emit","stop","arguments","_this4","call","setDisabled","updated","getParent","parents","getChildren","deep","childrenModel","shift","getModel","isBoolean_1","getRoot","indexOf","getPath","unshift","reverse","isRest","_this$tree","hasFilter","rest","nodeModel","filter","isVisible","_this$tree2","allowFoldNodeOnFilter","expandVisible","every","isDisabledState","disableCheck","state","isDisabled","isDraggable","isExpandMutex","isCheckable","isActived","isExpanded","isChecked","_tree$config","valueMode","isLeaf","childIsChecked","isIndeterminate","childChecked","isNull_1","isFirst","isLast","lock","lockState","afterExpanded","updateChildren","toggleExpanded","opts","setExpanded","options","_objectSpread","directly","Map","shouldExpandNodes","expandParent","_tree$config2","snode","getExpanded","toggleActived","setActived","isAction","getActived","prevKeys","from","activeMultiple","clear","getNode","hasEnableUnCheckedChild","child","toggleChecked","expectState","setChecked","getChecked","shouldSet","spreadChildrenChecked","spreadParentChecked","relatedNodes","getRelatedNodes","_this5","spreadChildren","_this6","spreadParents","fn","createNodeModel"],"sources":["../../../../src/_common/js/tree/tree-node.ts"],"sourcesContent":["import isNull from 'lodash/isNull';\nimport isFunction from 'lodash/isFunction';\nimport isNumber from 'lodash/isNumber';\nimport uniqueId from 'lodash/uniqueId';\nimport isBoolean from 'lodash/isBoolean';\nimport isNil from 'lodash/isNil';\nimport get from 'lodash/get';\nimport { TreeStore } from './tree-store';\nimport {\n  TreeNodeValue,\n  TreeNodeState,\n  TypeIdMap,\n  TypeTreeItem,\n  TypeSettingOptions,\n  TypeTreeNodeModel,\n  TypeTreeNodeData,\n  TypeTreeStoreOptions,\n  TypeFnOperation,\n} from './types';\nimport {\n  createNodeModel,\n} from './tree-node-model';\nimport log from '../log';\n\nconst { hasOwnProperty } = Object.prototype;\n\n// 这里的属性为 data 中属性可以同步到 treeNode 实例属性的白名单\n// 仅 label 属性和在列表中的属性可以通过 set 方法配置到 treeNode 实例上\nexport const setableStatus: Record<string, boolean | null> = {\n  expandMutex: null,\n  activable: null,\n  checkable: null,\n  draggable: null,\n  loading: false,\n};\n\nexport const setableProps = Object.keys(setableStatus);\n\nexport const syncableProps = [...setableProps, 'actived', 'expanded', 'checked'];\n\nexport const privateKey = '__tdesign_id__';\n\n// vm 开头为视图属性，不可以外部设置\n// 用于触发视图更新\n// public 方法，在 ui 组件中有可能在使用，会保障其输入输出实现\n// private 方法，可能会改动其输入输出\n\n/**\n * tree 节点数据模型\n * @class TreeNode\n * @param {TreeStore} tree TreeStore 实例\n * @param {object} [data] 节点数据\n * @param {TreeNode} parent 指定的当前 TreeStore 实例中的父节点\n */\nexport class TreeNode {\n  // 节点隶属的树实例\n  public tree: TreeStore;\n\n  // 节点私有 id，不接受外部传入，确保唯一性\n  public [privateKey]: string;\n\n  // 节点 id ，唯一标志\n  public value: string;\n\n  // 节点文本\n  public label: string;\n\n  // 节点数据\n  public data: TypeTreeNodeData;\n\n  // 父节点\n  public parent: TreeNode;\n\n  // 子节点列表\n  public children: TreeNode[] | boolean;\n\n  // 暴露的 treeNodeModel，这个对象的属性和 api 提供给用户使用\n  public model: TypeTreeNodeModel;\n\n  // 是否为叶节点\n  public vmIsLeaf: boolean;\n\n  // 是否为子节点中的第一个\n  public vmIsFirst: boolean;\n\n  // 是否为子节点中的最后\n  public vmIsLast: boolean;\n\n  // 节点是否是经过过滤剩下的\n  public vmIsRest: boolean;\n\n  // 节点是否展示为锁定状态\n  public vmIsLocked: boolean;\n\n  // 节点在视图上实际的展开状态\n  public expanded: boolean;\n\n  // 展开时是否收起同级节点，对子节点生效\n  public expandMutex: null | boolean;\n\n  // 节点在视图上实际的激活状态\n  public actived: boolean;\n\n  // 是否可激活\n  public activable: null | boolean;\n\n  // 是否可选中\n  public checkable: null | boolean;\n\n  // 是否可选中的视图呈现\n  public vmCheckable: boolean;\n\n  // 节点在视图上实际的选中态\n  public checked: boolean;\n\n  // 节点实际是否为半选状态\n  public indeterminate: boolean;\n\n  // 节点是否已禁用\n  public disabled: null | boolean;\n\n  // 节点是否可拖动\n  public draggable: null | boolean;\n\n  // 节点是否可视\n  public visible: boolean;\n\n  // 节点在树中的层级\n  public level: number;\n\n  // 节点是否正在加载数据\n  public loading: boolean;\n\n  public constructor(\n    tree: TreeStore,\n    data?: TypeTreeNodeData,\n    parent?: TreeNode,\n  ) {\n    this.data = data;\n    this.tree = tree;\n\n    const config = tree.config || {};\n    const prefix = config.prefix || 't';\n    const keys = config.keys || {};\n    const propChildren = keys.children || 'children';\n    const propLabel = keys.label || 'label';\n    const propValue = keys.value || 'value';\n    const propDisabled = keys.disabled || 'disabled';\n\n    // 节点自身初始化数据\n    this.model = null;\n    this.children = null;\n    this.level = 0;\n\n    // vm 开头为视图属性，不可以外部设置\n    this.vmCheckable = false;\n    this.vmIsLeaf = false;\n    this.vmIsFirst = false;\n    this.vmIsLast = false;\n    this.vmIsRest = false;\n    this.vmIsLocked = false;\n\n    // 初始化节点基本状态\n    this.visible = false;\n    this.actived = false;\n    this.checked = false;\n    this.indeterminate = false;\n    this.loading = false;\n    this.expanded = config.expandAll;\n\n    // 下面几个属性，节点初始化的时候，可以设置与 treeStore.config 不同的值\n    // 初始化默认值为 null, 则在方法判断时，默认以 treeStore.config 为准\n    // 传递或者设置属性为 boolean 类型的值，则以节点属性值为准\n    // 这种处理方式主要是解决 treeStore.setConfig 方法配置全局属性导致的状态切换与保留的问题\n    this.activable = null;\n    this.checkable = null;\n    this.expandMutex = null;\n    this.draggable = null;\n\n    // 为节点设置唯一 id\n    // tree 数据替换时，value 相同有可能导致节点状态渲染冲突\n    // 用这个 唯一 id 来解决，用于类似 vue 组件的唯一 key 指定场景\n    this[privateKey] = uniqueId(prefix);\n\n    // 设置 value\n    // 没有 value 的时候，value 默认使用自动生成的 唯一 id\n    this.value = isNil(get(data, propValue))\n      ? this[privateKey]\n      : get(data, propValue);\n    const { nodeMap, privateMap } = tree;\n    if (nodeMap.get(this.value)) {\n      log.warn('Tree', `Dulplicate value: ${this.value}`);\n    }\n    nodeMap.set(this.value, this);\n    privateMap.set(this[privateKey], this);\n\n    // 设置标签\n    this.label = get(data, propLabel) || '';\n    // 设置是否禁用\n    this.disabled = get(data, propDisabled) || false;\n\n    // 设置子节点\n    const children = data[propChildren];\n    // 子节点为 true 的状态逻辑需要放到状态计算之前\n    // 初始化加载逻辑需要依据这个来进行\n    if (children === true) {\n      this.children = children;\n    }\n\n    // 设置父节点\n    if (parent && parent instanceof TreeNode) {\n      this.parent = parent;\n    } else {\n      this.parent = null;\n    }\n\n    // 同步数据属性到节点属性\n    // 仅 syncableStatus 列举的属性被同步到 treeNode 实例属性\n    syncableProps.forEach((prop) => {\n      if (typeof data[prop] !== 'undefined') {\n        this[prop] = data[prop];\n      }\n    });\n\n    // 初始化节点激活状态\n    this.initActived();\n    // 展开状态影响了子节点的显示状态，所以要在子节点插入之前初始化展开状态\n    this.initExpanded();\n\n    // 这里的子节点加载逻辑不能放到状态初始化之前\n    // 因为子节点状态计算依赖父节点初始化状态\n    if (Array.isArray(children)) {\n      this.append(children);\n    } else if (children === true && !config.lazy) {\n      this.loadChildren();\n    }\n\n    // 节点的选中状态同时依赖于子节点状态与父节点状态\n    // 因此在子节点插入之后再更新选中状态\n    this.initChecked();\n    this.updateChecked();\n\n    // 标记节点更新\n    this.update();\n    // 创建节点需要回流操作\n    tree.reflow(this);\n  }\n\n  /* ------ 状态初始化 ------ */\n\n  /**\n   * 初始化选中态\n   * @return void\n   */\n  private initChecked(): void {\n    const { tree, value, parent } = this;\n    const { checkedMap } = tree;\n    const { checkStrictly } = tree.config;\n    if (this.checked) {\n      checkedMap.set(value, true);\n    }\n    // 这里不可以使用 parent.isChecked 方法\n    // 因为当前节点创建时尚未插入父节点的 children 数组，可能父节点选中态仅受到之前子节点状态的影响\n    // 这会导致父节点状态计算错误，进而引发子节点变更了选中状态\n    if (!checkStrictly && parent?.checked) {\n      checkedMap.set(value, true);\n    }\n  }\n\n  /**\n   * 初始化节点展开状态\n   * @return void\n   */\n  private initExpanded(): void {\n    const { tree } = this;\n    let { expanded } = this;\n    const { config } = tree;\n    if (isNumber(config.expandLevel) && this.getLevel() < config.expandLevel) {\n      tree.expandedMap.set(this.value, true);\n      expanded = true;\n    }\n    if (this.children === true && config.lazy) {\n      expanded = false;\n    }\n    if (expanded) {\n      tree.expandedMap.set(this.value, true);\n    } else {\n      tree.expandedMap.delete(this.value);\n    }\n    this.expanded = expanded;\n  }\n\n  /**\n   * 初始化节点激活状态\n   * @return void\n   */\n  private initActived(): void {\n    const { tree, actived } = this;\n    if (actived && this.isActivable()) {\n      tree.activedMap.set(this.value, true);\n    }\n  }\n\n  /* ------ 节点操作 ------ */\n\n  /**\n   * 追加节点数据\n   * @param {object | object[]} data 节点数据\n   * @return void\n   */\n  public append(data: TypeTreeNodeData | TypeTreeNodeData[]): void {\n    const list = [];\n    if (!Array.isArray(data)) {\n      list.push(data);\n    } else {\n      list.push(...data);\n    }\n    if (list.length <= 0) {\n      return;\n    }\n    if (!Array.isArray(this.children)) {\n      this.children = [];\n    }\n    const { children, tree } = this;\n    list.forEach((item) => {\n      let node = null;\n      if (item instanceof TreeNode) {\n        node = item;\n        node.appendTo(this.tree, this);\n      } else {\n        node = new TreeNode(this.tree, item, this);\n        children.push(node);\n      }\n    });\n    tree.reflow(this);\n    this.updateRelated();\n  }\n\n  /**\n   * 将当前节点追加到某个父节点的子节点列表中\n   * @param {TreeStore} tree 目标树\n   * @param {TreeNode} [parent] 目标父节点\n   * @param {number} [index] 预期在子节点列表中的位置\n   * @return void\n   */\n  public appendTo(tree: TreeStore, parent?: TreeNode, index?: number): void {\n    const parentNode = parent;\n    let targetIndex = -1;\n    if (isNumber(index)) {\n      targetIndex = index;\n    }\n\n    const targetParents = parentNode?.getParents() || [];\n    const includeCurrent = targetParents.some((pnode) => pnode === this);\n    if (includeCurrent) {\n      throw new Error('无法将父节点插入到子节点');\n    }\n\n    if (parentNode === this) {\n      throw new Error('无法将节点插入到本节点');\n    }\n\n    if (Array.isArray(parentNode?.children)) {\n      const targetPosNode = parentNode?.children[targetIndex];\n      if (targetPosNode && targetPosNode === this) {\n        // 无需将节点插入到原位置\n        return;\n      }\n    }\n\n    // 先要取得 siblings\n    // 因为要应对节点在同一个 siblings 中变换位置的情况\n    let siblings = null;\n    if (parentNode instanceof TreeNode) {\n      if (!Array.isArray(parentNode?.children)) {\n        parentNode.children = [];\n      }\n      siblings = parent.children;\n    } else {\n      siblings = tree.children;\n    }\n\n    // 上面的逻辑其实已经覆盖了所有业务情况\n    // 这里的逻辑报错仅用于极限兜底，防止 treeStore 被误使用\n    if (!Array.isArray(siblings)) {\n      throw new Error('无法插入到目标位置，可插入的节点列表不存在');\n    }\n\n    const prevLength = siblings.length;\n    const prevIndex = this.getIndex();\n\n    this.remove();\n\n    if (isNumber(index)) {\n      let targetIndex = index;\n      if (parentNode === this.parent) {\n        // 前置节点被拔出后再插入到同一个 siblings 时，会引起目标 index 的变化\n        // 因此要相应的变更插入位置\n        // 后置节点被拔出时，目标 index 是不变的\n        const curLength = siblings.length;\n        if (curLength < prevLength && prevIndex <= targetIndex) {\n          targetIndex -= 1;\n        }\n      }\n      siblings.splice(targetIndex, 0, this);\n    } else {\n      siblings.push(this);\n    }\n\n    this.parent = parentNode;\n\n    // 插入节点应当继承展开状态\n    // 但不要继承选中状态和高亮状态\n    const nodes = this.walk();\n    nodes.forEach((item) => {\n      const node = item;\n      node.tree = tree;\n      tree.nodeMap.set(node.value, node);\n      tree.privateMap.set(node[privateKey], node);\n      if (node.expanded) {\n        tree.expandedMap.set(node.value, true);\n      }\n    });\n\n    const updateNodes = parentNode?.walk() || tree.children.map((item) => item.walk()).flat();\n    updateNodes.forEach((node) => {\n      node.update();\n      node.updateChecked();\n    });\n\n    tree.reflow();\n  }\n\n  /**\n   * 插入一个节点或者数据到到同级节点的目标位置\n   * @param {TreeNode | object} item 要插入的节点或者数据\n   * @param {number} [index] 预期在子节点列表中的位置\n   * @return void\n   */\n  private insert(item: TypeTreeItem, index?: number): void {\n    const { tree, parent } = this;\n    const siblings = this.getSiblings();\n    let node = null;\n    if (item instanceof TreeNode) {\n      node = item;\n      node.appendTo(tree, parent, index);\n    } else if (item) {\n      node = new TreeNode(tree, item, parent);\n      if (isNumber(index)) {\n        siblings.splice(index, 0, node);\n      }\n      siblings.forEach((sibling) => {\n        sibling.update();\n      });\n    }\n    tree.reflow();\n  }\n\n  /**\n   * 在当前节点之前插入节点\n   * @param {TreeNode | object} newData 要插入的节点或者数据\n   * @return void\n   */\n  public insertBefore(newData: TypeTreeItem): void {\n    const index = this.getIndex();\n    this.insert(newData, index);\n  }\n\n  /**\n   * 在当前节点之后插入节点\n   * @param {TreeNode | object} newData 要插入的节点或者数据\n   * @return void\n   */\n  public insertAfter(newData: TypeTreeItem): void {\n    const index = this.getIndex();\n    this.insert(newData, index + 1);\n  }\n\n  /**\n   * 从当前树中移除本节点\n   * @return void\n   */\n  public remove(): void {\n    const { tree } = this;\n\n    const nodes = this.walk();\n    const siblings = this.getSiblings();\n    const index = this.getIndex();\n    // 从父节点的子节点列表中移除自己\n    // 但不要将自己的父节点移除，避免渲染与判断失败\n    if (Array.isArray(siblings)) {\n      siblings.splice(index, 1);\n    }\n    // 清理与树的关系，但不清理自身状态\n    nodes.forEach((node) => {\n      node.clean();\n    });\n    // 同级节点的连线状态会受到影响\n    siblings.forEach((node) => {\n      node.update();\n    });\n    // 父节点选中态会受到影响\n    this.updateParents();\n    tree.reflow();\n  }\n\n  /**\n   * 清除本节点与当前树的关系\n   * @return void\n   */\n  private clean(): void {\n    const { tree, value } = this;\n    tree.activedMap.delete(value);\n    tree.checkedMap.delete(value);\n    tree.expandedMap.delete(value);\n    tree.nodeMap.delete(value);\n    tree.filterMap.delete(value);\n    tree.privateMap.delete(this[privateKey]);\n  }\n\n  /**\n   * 异步加载子节点\n   * @return Promise<void>\n   */\n  private async loadChildren(): Promise<void> {\n    const config: TypeTreeStoreOptions = get(this, 'tree.config') || {};\n    if (this.children === true && !this.loading) {\n      if (isFunction(config.load)) {\n        this.loading = true;\n        this.update();\n        let list = [];\n        list = await config.load(this);\n        this.tree.emit('load', {\n          node: this,\n          data: list,\n        });\n        this.loading = false;\n        if (Array.isArray(list) && list.length > 0) {\n          this.append(list);\n        } else {\n          this.children = false;\n        }\n        this.update();\n      }\n    }\n  }\n\n  /**\n   * 设置节点状态\n   * - 为节点设置独立于配置的 disabled 状态: set({ disabled: true })\n   * - 清除独立于配置的 disabled 状态: set({ disabled: null })\n   * @param {object} item 节点状态对象\n   * @return void\n   */\n  public set(item: TreeNodeState): void {\n    const { tree } = this;\n    const keys = Object.keys(item);\n    keys.forEach((key) => {\n      // key, disabled 字段可被 tree.config.keys 定义\n      if (hasOwnProperty.call(setableStatus, key) || key === 'label') {\n        this[key] = item[key];\n      }\n      if (key === 'disabled') {\n        this.setDisabled(item[key]);\n      }\n    });\n    tree.updated(this);\n  }\n\n  /* ------ 节点获取 ------- */\n\n  /**\n   * 获取本节点的父节点\n   * @return TreeNode 父节点\n   */\n  public getParent(): TreeNode {\n    return this.parent;\n  }\n\n  /**\n   * 获取所有父级节点\n   * - 顺序为从当前到根\n   * @return TreeNode[] 父级节点数组\n   */\n  public getParents(): TreeNode[] {\n    const parents = [];\n    let node = this.parent;\n    while (node) {\n      parents.push(node);\n      node = node.parent;\n    }\n    return parents;\n  }\n\n  /**\n   * 获取所有兄弟节点，包含自己在内\n   * @return TreeNode[] 兄弟节点数组\n   */\n  public getSiblings(): TreeNode[] {\n    const { parent, tree } = this;\n    let list: TreeNode[] = [];\n    if (parent) {\n      if (Array.isArray(parent.children)) {\n        list = parent.children;\n      }\n    } else if (tree) {\n      list = tree.children;\n    }\n    return list;\n  }\n\n  /**\n   * 获取当前节点的子节点\n   * @param {boolean} deep 是否获取所有深层子节点\n   * @return TreeNodeModel[] 子节点数组\n   */\n  public getChildren(deep?: boolean): boolean | TypeTreeNodeModel[] {\n    let childrenModel: boolean | TypeTreeNodeModel[] = false;\n    const { children } = this;\n    if (Array.isArray(children)) {\n      if (children.length > 0) {\n        if (deep) {\n          const nodes = this.walk();\n          nodes.shift();\n          childrenModel = nodes.map((item) => item.getModel());\n        } else {\n          childrenModel = children.map((item) => item.getModel());\n        }\n      } else {\n        childrenModel = false;\n      }\n    } else if (isBoolean(children)) {\n      childrenModel = children;\n    }\n    return childrenModel;\n  }\n\n  /**\n   * 获取本节点的根节点\n   * @return TreeNode 根节点\n   */\n  public getRoot(): TreeNode {\n    const parents = this.getParents();\n    return parents[parents.length - 1] || null;\n  }\n\n  /**\n   * 获取节点在父节点的子节点列表中的位置\n   * - 如果没有父节点，则获取节点在根节点列表的位置\n   * @return number 节点位置序号\n   */\n  public getIndex(): number {\n    const list = this.getSiblings();\n    return list.indexOf(this);\n  }\n\n  /**\n   * 返回路径节点\n   * - 路径节点包含自己在内\n   * - 节点顺序与父级节点顺序相反，从根到当前\n   * @return TreeNode[] 路径节点数组\n   */\n  public getPath(): TreeNode[] {\n    const nodes = this.getParents();\n    nodes.unshift(this);\n    return nodes.reverse();\n  }\n\n  /**\n   * 获取节点所在层级\n   * @return number 层级序号\n   */\n  public getLevel(): number {\n    const parents = this.getParents();\n    return parents.length;\n  }\n\n  /* ------ 节点状态判断 ------ */\n\n  /**\n   * 判断节点是否被过滤\n   * @return boolean 是否被过滤方法命中\n   */\n  public isRest(): boolean {\n    const { config, filterMap, hasFilter } = this.tree;\n\n    let rest = false;\n    if (hasFilter) {\n      // 仅在存在过滤条件时，过滤命中才有效\n      const nodeModel = this.getModel();\n      rest = config.filter(nodeModel);\n    }\n\n    if (rest) {\n      filterMap.set(this.value, true);\n    } else if (filterMap.get(this.value)) {\n      filterMap.delete(this.value);\n    }\n\n    return rest;\n  }\n\n  /**\n   * 判断节点是否可见\n   * @return boolean 是否可见\n   */\n  public isVisible(): boolean {\n    const { nodeMap, hasFilter, config } = this.tree;\n    const { allowFoldNodeOnFilter } = config;\n\n    let visible = true;\n\n    if (!nodeMap.get(this.value)) {\n      // 节点不在当前树上，所以不可见\n      return false;\n    }\n\n    if (hasFilter && !allowFoldNodeOnFilter) {\n      // 如果存在过滤条件\n      // 锁定状态和过滤命中状态，直接呈现\n      visible = this.vmIsLocked || this.vmIsRest;\n      return visible;\n    }\n\n    // 标志所有父节点展开导致的可见状态\n    let expandVisible = true;\n    const parents = this.getParents();\n    if (parents.length > 0) {\n      expandVisible = parents.every((node: TreeNode) => node.expanded);\n    }\n\n    if (hasFilter) {\n      visible = expandVisible && (this.vmIsRest || this.vmIsLocked);\n    } else {\n      visible = expandVisible;\n    }\n    return visible;\n  }\n\n  /**\n   * 判断节点为逻辑禁用状态，不包含过滤锁定状态\n   * @return boolean 是否被禁用\n   */\n  public isDisabledState(): boolean {\n    const { tree, parent } = this;\n    const { config } = tree;\n    const { disabled, disableCheck, checkStrictly } = config;\n    let state = disabled || false;\n    if (this.disabled) {\n      // 整个树被禁用，则节点为禁用状态\n      state = true;\n    }\n    if (!checkStrictly && parent?.isDisabledState()) {\n      // 如果 checkStrictly 为 false\n      // 父节点被禁用，则子节点也为禁用状态\n      state = true;\n    }\n    if (typeof disableCheck === 'boolean') {\n      if (disableCheck) {\n        state = true;\n      }\n    } else if (typeof disableCheck === 'function') {\n      // disableCheck 视为禁用节点的过滤函数\n      if (disableCheck(this.getModel())) {\n        state = true;\n      }\n    }\n    return state;\n  }\n\n  /**\n   * 判断节点是否呈现为禁用态，包含过滤锁定状态\n   * @return boolean 是否被禁用\n   */\n  public isDisabled(): boolean {\n    const { tree } = this;\n    const { hasFilter, config } = tree;\n    const { allowFoldNodeOnFilter } = config;\n    if (hasFilter && !allowFoldNodeOnFilter && this.vmIsLocked && !this.vmIsRest) {\n      // 当前树存在过滤条件，允许节点过滤后被折叠，当前节点为锁定节点，并且不是筛选后剩下的节点\n      // 则该节点应当呈现禁用状态\n      return true;\n    }\n    return this.isDisabledState();\n  }\n\n  /**\n   * 判断节点是否能拖拽\n   * @return boolean 是否能拖拽\n   */\n  public isDraggable(): boolean {\n    let state = !!get(this, 'tree.config.draggable');\n    if (typeof this.draggable === 'boolean') {\n      state = this.draggable;\n    }\n    return state;\n  }\n\n  /**\n   * 判断子节点是否互斥展开\n   * @return boolean 子节点是否互斥展开\n   */\n  public isExpandMutex(): boolean {\n    let state = !!get(this, 'tree.config.expandMutex');\n    if (typeof this.expandMutex === 'boolean') {\n      state = this.expandMutex;\n    }\n    return state;\n  }\n\n  /**\n   * 节点是否可被激活\n   * @return boolean 是否可被激活\n   */\n  public isActivable() {\n    let state = !!get(this, 'tree.config.activable');\n    if (typeof this.activable === 'boolean') {\n      state = this.activable;\n    }\n    return state;\n  }\n\n  /**\n   * 节点是否可选\n   * @return boolean 是否可选\n   */\n  public isCheckable() {\n    let state = !!get(this, 'tree.config.checkable');\n    if (typeof this.checkable === 'boolean') {\n      state = this.checkable;\n    }\n    return state;\n  }\n\n  /**\n   * 节点是否被激活\n   * @param {Map} [map] 预设激活节点 map, 用于计算节点在预期环境中的激活状态\n   * @return boolean 是否被激活\n   */\n  public isActived(map?: Map<string, boolean>): boolean {\n    const { tree, value } = this;\n    const activedMap = map || tree.activedMap;\n    return !!(tree.nodeMap.get(value) && activedMap.get(value));\n  }\n\n  /**\n   * 节点是否已展开\n   * @param {Map} [map] 预设展开节点 map, 用于计算节点在预期环境中的展开状态\n   * @return boolean 是否已展开\n   */\n  public isExpanded(map?: Map<string, boolean>): boolean {\n    const { tree, value, vmIsLocked } = this;\n    const { hasFilter, config } = tree;\n    const { allowFoldNodeOnFilter } = config;\n    if (hasFilter && !allowFoldNodeOnFilter && vmIsLocked) return true;\n    const expandedMap = map || tree.expandedMap;\n    return !!(tree.nodeMap.get(value) && expandedMap.get(value));\n  }\n\n  /**\n   * 节点是否被选中\n   * @param {Map} [map] 预设选中节点 map, 用于计算节点在预期环境中的选中态\n   * @return boolean 是否被选中\n   */\n  public isChecked(map?: TypeIdMap): boolean {\n    const { children, tree, value } = this;\n    const { checkStrictly, valueMode } = tree.config;\n    // 节点不在当前树上，视为未选中\n    if (!tree.nodeMap.get(value)) return false;\n    // 节点不可选，视为未选中\n    if (!this.isCheckable()) return false;\n    const checkedMap = map || tree.checkedMap;\n    // 严格模式，则已经可以判定选中状态\n    if (checkStrictly) {\n      return !!checkedMap.get(value);\n    }\n    let checked = false;\n    // 在 checkedMap 中，则根据 valueMode 的值进行判断\n    if (checkedMap.get(value)\n      && (\n        // 如果 valueMode 为 all、parentFirst，则视为选中\n        valueMode !== 'onlyLeaf'\n        // 如果 valueMode 为 onlyLeaf 并且当前节点是叶子节点，则视为选中\n        || this.isLeaf()\n      )\n    ) {\n      return true;\n    }\n    // 如果 valueMode 为 onlyLeaf 并且当前节点是父节点，则进一步判断\n    if (Array.isArray(children) && children.length > 0) {\n      // 子节点全部选中，则当前节点选中\n      checked = children.every((node) => {\n        const childIsChecked = node.isChecked(checkedMap);\n        return childIsChecked;\n      });\n    } else {\n      // 从父节点状态推断子节点状态\n      // 这里再调用 isChecked 会导致死循环\n      const parents = this.getParents();\n      checked = parents.some((node) => checkedMap.get(node.value));\n    }\n    return checked;\n  }\n\n  /**\n   * 是否为半选状态\n   * @return boolean 是否为半选状态\n   */\n  public isIndeterminate(): boolean {\n    const { children, tree, value } = this;\n    const { checkStrictly } = tree.config;\n    // 节点不在当前树上，视为未选中\n    if (!tree.nodeMap.get(value)) return false;\n    // 节点不可选，视为未选中\n    if (!this.isCheckable()) return false;\n    // 严格模式没有半选状态\n    if (checkStrictly) return false;\n    // 叶节点不存在半选状态\n    if (!Array.isArray(children)) return false;\n\n    let childChecked: null | boolean = null;\n    const indeterminate = children.some((node: TreeNode) => {\n      if (node.isIndeterminate()) {\n        // 子节点有任意一个半选，则其为半选状态\n        return true;\n      }\n      if (isNull(childChecked)) {\n        childChecked = node.isChecked();\n      }\n      if (childChecked !== node.isChecked()) {\n        // 子节点选中状态不一致，则其为半选状态\n        return true;\n      }\n      return false;\n    });\n\n    return indeterminate;\n  }\n\n  /**\n   * 是否为兄弟节点中的第一个节点\n   * @return boolean 是否为第一个节点\n   */\n  public isFirst(): boolean {\n    const siblings = this.getSiblings();\n    return siblings[0] === this;\n  }\n\n  /**\n   * 是否为兄弟节点中的最后一个节点\n   * @return boolean 是否为最后一个节点\n   */\n  public isLast(): boolean {\n    const siblings = this.getSiblings();\n    return siblings[siblings.length - 1] === this;\n  }\n\n  /**\n   * 是否为叶子节点，叶子节点没有子节点\n   * @return boolean 是否为叶子节点\n   */\n  public isLeaf(): boolean {\n    let isLeaf = false;\n    if (Array.isArray(this.children)) {\n      isLeaf = this.children.length <= 0;\n    } else {\n      isLeaf = !this.children;\n    }\n    return isLeaf;\n  }\n\n  /* ------ 节点状态切换 ------ */\n\n  /**\n   * 锁定节点，解锁节点\n   * - 搜索过滤节点时，路径节点需要固定呈现，视其为锁定态\n   * @param {boolean} lockState 锁定状态\n   * @return void\n   */\n  public lock(lockState: boolean): void {\n    this.vmIsLocked = lockState;\n    this.expanded = this.isExpanded();\n    this.visible = this.isVisible();\n  }\n\n  /**\n   * 节点展开关闭后需要调用的状态检查函数\n   * @return void\n   */\n  public afterExpanded(): void {\n    this.update();\n    // 节点展开时检查延迟加载的数据\n    if (this.expanded && this.children === true) {\n      this.loadChildren();\n    }\n    this.updateChildren();\n  }\n\n  /**\n   * 切换节点展开状态\n   * - 用于受控逻辑处理\n   * - 仅返回预期状态值数组，不直接操作状态\n   * @return string[] 当前树展开的节点值数组\n   */\n  public toggleExpanded(opts?: TypeSettingOptions): TreeNodeValue[] {\n    return this.setExpanded(!this.isExpanded(), opts);\n  }\n\n  /**\n   * 设置节点展开状态\n   * @param {boolean} expanded 节点展开状态\n   * @param {object} [opts] 操作选项\n   * @param {boolean} [opts.directly=false] 是否直接操作节点状态\n   * @return string[] 当前树展开的节点值数组\n   */\n  public setExpanded(\n    expanded: boolean,\n    opts?: TypeSettingOptions\n  ): TreeNodeValue[] {\n    const { tree } = this;\n    const { config } = tree;\n    const options = {\n      directly: false,\n      ...opts,\n    };\n\n    let map = tree.expandedMap;\n    if (!options.directly) {\n      map = new Map(tree.expandedMap);\n    }\n\n    // 手风琴效果，先折叠同级节点\n    if (expanded) {\n      // 列举需要展开的节点\n      const shouldExpandNodes = [];\n      // 自己一定在展开列表中\n      shouldExpandNodes.push(this);\n      if (config.expandParent) {\n        // expandParent 为 true，则父节点都要展开\n        this.getParents().forEach((node) => {\n          shouldExpandNodes.push(node);\n        });\n      }\n      shouldExpandNodes.forEach((node) => {\n        let isExpandMutex = false;\n        // 对于每一个节点，都需要判断是否启用手风琴效果\n        if (node.parent) {\n          isExpandMutex = node.parent.isExpandMutex();\n        } else {\n          isExpandMutex = tree?.config?.expandMutex;\n        }\n        if (isExpandMutex) {\n          // 折叠列表中，先移除同级节点\n          const siblings = node.getSiblings();\n          siblings.forEach((snode) => {\n            map.delete(snode.value);\n            // 同级节点相关状态更新\n            snode.update();\n            snode.updateChildren();\n          });\n        }\n        // 最后设置自己的折叠状态\n        map.set(node.value, true);\n        node.update();\n        node.updateChildren();\n      });\n    } else {\n      map.delete(this.value);\n    }\n\n    if (options.directly) {\n      this.afterExpanded();\n    }\n\n    return tree.getExpanded(map);\n  }\n\n  /**\n   * 切换节点激活状态\n   * - 用于受控逻辑处理\n   * - 仅返回预期状态值数组，不直接操作状态\n   * @return string[] 当前树激活的节点值数组\n   */\n  public toggleActived(opts?: TypeSettingOptions): TreeNodeValue[] {\n    return this.setActived(!this.isActived(), opts);\n  }\n\n  /**\n   * 设置节点激活状态\n   * @param {boolean} actived 节点激活状态\n   * @param {object} [opts] 操作选项\n   * @param {boolean} [opts.directly=false] 是否直接操作节点状态\n   * @return string[] 当前树激活的节点值数组\n   */\n  public setActived(\n    actived: boolean,\n    opts?: TypeSettingOptions\n  ): TreeNodeValue[] {\n    const { tree } = this;\n    const options = {\n      // 为 true, 为 UI 操作，状态变更受 disabled 影响\n      // 为 false, 为值操作, 状态变更不受 disabled 影响\n      isAction: true,\n      // 为 true, 直接操作节点状态\n      // 为 false, 返回预期状态\n      directly: false,\n      ...opts,\n    };\n    const config = tree.config || {};\n    let map = tree.activedMap;\n    if (!options.directly) {\n      map = new Map(tree.activedMap);\n    }\n    if (options.isAction && this.isDisabledState()) {\n      // 对于 UI 动作，禁用时不可切换激活状态\n      return tree.getActived(map);\n    }\n    if (this.isActivable()) {\n      if (actived) {\n        const prevKeys = Array.from(map.keys());\n        if (!config.activeMultiple) {\n          map.clear();\n        }\n        prevKeys.forEach((value) => {\n          const node = tree.getNode(value);\n          node?.update();\n        });\n        map.set(this.value, true);\n      } else {\n        map.delete(this.value);\n      }\n    }\n    this.update();\n    return tree.getActived(map);\n  }\n\n  /**\n   * 是否存在未选中的未禁用子节点\n   * @return boolean 未选中的未禁用子节点存在与否\n   */\n  public hasEnableUnCheckedChild(): boolean {\n    const { children } = this;\n    if (!Array.isArray(children) || children.length <= 0) {\n      // 没有子节点\n      return false;\n    }\n    let state = false;\n    children.some((child) => {\n      // 不理会禁用节点\n      if (child.isDisabledState()) return false;\n      // 不理会选中节点\n      if (child.isChecked()) return false;\n      if (child.isIndeterminate()) {\n        // 为半选节点则进行递归检查\n        if (child.hasEnableUnCheckedChild()) {\n          state = true;\n          return true;\n        }\n        // 都尽可能选中了，则检查之后的节点\n        return false;\n      }\n      // 子节点为未选中状态，且非半选状态\n      // 则直接返回 true\n      state = true;\n      return true;\n    });\n    return state;\n  }\n\n  /**\n   * 切换节点选中状态\n   * - 用于受控逻辑处理\n   * - 仅返回预期状态值数组，不直接操作状态\n   * @return string[] 当前树选中的节点值数组\n   */\n  public toggleChecked(opts?: TypeSettingOptions): TreeNodeValue[] {\n    if (this.isIndeterminate()) {\n      // 当前节点为半选情况下需要判断子节点是否尽可能全部选中\n      // 存在可操作的未选中的子节点，则应当尽可能选中子节点\n      // 不存在可操作的未选中的子节点，则应取消选中子节点\n      const expectState = this.hasEnableUnCheckedChild();\n      return this.setChecked(expectState, opts);\n    }\n    return this.setChecked(!this.isChecked(), opts);\n  }\n\n  /**\n   * 设置节点选中状态\n   * - 节点 UI 操作时调用这个方法\n   * - 节点设置自身状态时调用这个方法\n   * @param {boolean} checked 节点选中状态\n   * @param {object} [opts] 操作选项\n   * @param {boolean} [opts.isAction=true] 是否为 UI 动作\n   * @param {boolean} [opts.directly=false] 是否直接操作节点状态\n   * @return string[] 当前树选中的节点值数组\n   */\n  public setChecked(\n    checked: boolean,\n    opts?: TypeSettingOptions\n  ): TreeNodeValue[] {\n    const { tree } = this;\n    const config = tree.config || {};\n    const options: TypeSettingOptions = {\n      // 为 true, 为 UI 操作，状态变更受 disabled 影响\n      // 为 false, 为值操作, 状态变更不受 disabled 影响\n      isAction: true,\n      // 为 true, 直接操作节点状态\n      // 为 false, 返回预期状态\n      directly: false,\n      ...opts,\n    };\n    let map = tree.checkedMap;\n    if (!options.directly) {\n      map = new Map(tree.checkedMap);\n    }\n    if (!this.isCheckable()) {\n      // 当前节点非可选节点，则不可设置选中态\n      return tree.getChecked(map);\n    }\n    if (options.isAction && this.isDisabledState()) {\n      // 对于 UI 动作，禁用时不可切换选中态\n      return tree.getChecked(map);\n    }\n\n    if (checked === this.isChecked()) {\n      const shouldSet = this.isIndeterminate() && !this.hasEnableUnCheckedChild();\n      if (!shouldSet) {\n        // 值没有变更, 则选中态无变化\n        return tree.getChecked(map);\n      }\n    }\n\n    if (checked) {\n      map.set(this.value, true);\n    } else {\n      map.delete(this.value);\n    }\n\n    if (config.checkStrictly) {\n      // 严格模式下，选中态不扩散，仅操作节点自身\n      if (options.directly) {\n        // 严格模式值更新节点自身\n        this.updateChecked();\n      }\n    } else {\n      // 先向下游扩散选中态\n      this.spreadChildrenChecked(checked, map, options);\n      // 再计算上游选中态\n      this.spreadParentChecked(checked, map, options);\n      // 状态更新务必放到扩散动作之后\n      // 过早的状态更新会导致后续计算出错\n      if (options.directly) {\n        const relatedNodes = tree.getRelatedNodes([this.value], {\n          reverse: true,\n        });\n        relatedNodes.forEach((node) => {\n          node.updateChecked();\n        });\n      }\n    }\n\n    return tree.getChecked(map);\n  }\n\n  // 选中态向上游扩散\n  private spreadParentChecked(\n    checked: boolean,\n    map?: TypeIdMap,\n    opts?: TypeSettingOptions\n  ) {\n    const options: TypeSettingOptions = {\n      isAction: true,\n      directly: false,\n      ...opts,\n    };\n\n    // 碰到不可选节点，中断扩散\n    if (!this.isCheckable()) return;\n\n    const { children } = this;\n    if (Array.isArray(children) && children.length > 0) {\n      // 有子节点，则选中态由子节点选中态集合来决定\n      map.delete(this.value);\n    }\n\n    const { parent } = this;\n    if (!parent) return;\n    parent.spreadParentChecked(checked, map, options);\n  }\n\n  // 选中态向下游扩散\n  private spreadChildrenChecked(\n    checked: boolean,\n    map?: TypeIdMap,\n    opts?: TypeSettingOptions\n  ) {\n    const options: TypeSettingOptions = {\n      isAction: true,\n      directly: false,\n      ...opts,\n    };\n\n    // 碰到不可选节点，中断扩散\n    if (!this.isCheckable()) return;\n    // 对于 UI 动作操作，节点禁用，中断扩散\n    if (options.isAction && this.isDisabledState()) return;\n\n    const { children } = this;\n    if (!Array.isArray(children)) return;\n    if (children.length <= 0) return;\n    // 有子节点，则选中态由子节点选中态集合来决定\n    map.delete(this.value);\n    children.forEach((node) => {\n      // 对于 UI 动作，向下扩散时，禁用状态会阻止状态切换\n      if (options.isAction && node.isDisabledState()) return;\n      if (checked) {\n        map.set(node.value, true);\n      } else {\n        map.delete(node.value);\n      }\n      node.spreadChildrenChecked(checked, map, options);\n    });\n  }\n\n  /**\n   * 设置节点禁用状态\n   * @return void\n   */\n  public setDisabled(disabled: boolean) {\n    this.disabled = disabled;\n    this.update();\n    this.updateChildren();\n  }\n\n  /* ------ 节点状态更新 ------ */\n\n  /**\n   * 更新节点当前状态，将节点放到延时更新检查队列\n   * @return void\n   */\n  public update(): void {\n    this.level = this.getLevel();\n    this.vmIsFirst = this.isFirst();\n    this.vmIsLast = this.isLast();\n    this.vmIsLeaf = this.isLeaf();\n    this.vmCheckable = this.isCheckable();\n    this.vmIsRest = this.isRest();\n    this.actived = this.isActived();\n    this.expanded = this.isExpanded();\n    this.visible = this.isVisible();\n    this.tree.updated(this);\n  }\n\n  /**\n   * 更新节点选中态\n   * @return void\n   */\n  public updateChecked(): void {\n    const { tree, value } = this;\n    const { checkedMap } = tree;\n    this.checked = this.isChecked();\n    this.indeterminate = this.isIndeterminate();\n    if (this.checked) {\n      checkedMap.set(value, true);\n    }\n    tree.updated(this);\n  }\n\n  /**\n   * 更新所有子节点状态\n   * - 不包含自己\n   * @return void\n   */\n  public updateChildren(): void {\n    this.spreadChildren((node) => {\n      if (node === this) return;\n      node.update();\n      node.updateChecked();\n    });\n  }\n\n  /**\n   * 更新所有父级节点状态\n   * - 不包含自己\n   * @return void\n   */\n  public updateParents(): void {\n    this.spreadParents((node: TreeNode) => {\n      if (node === this) return;\n      node.update();\n      node.updateChecked();\n    });\n  }\n\n  /**\n   * 更新上下游相关节点状态\n   * - 包含自己\n   * @return void\n   */\n  public updateRelated(): void {\n    const { tree } = this;\n    const relatedNodes = tree.getRelatedNodes([this.value]);\n    relatedNodes.forEach((node) => {\n      node.update();\n      node.updateChecked();\n    });\n  }\n\n  /* ------ 节点遍历 ------ */\n\n  /**\n   * 获取包含自己在内所有的子节点\n   * - 包含自己\n   * @return TreeNode[] 遍历结果节点数组\n   */\n  public walk(): TreeNode[] {\n    const list: TreeNode[] = [];\n    this.spreadChildren((node: TreeNode) => {\n      list.push(node);\n    });\n    return list;\n  }\n\n  /**\n   * 向下遍历操作\n   * - 包含自己\n   * @return void\n   */\n  private spreadChildren(fn: TypeFnOperation) {\n    fn(this);\n    const { children } = this;\n    if (Array.isArray(children) && children.length > 0) {\n      children.forEach((node) => {\n        node?.spreadChildren(fn);\n      });\n    }\n  }\n\n  /**\n   * 向上遍历操作\n   * - 包含自己\n   * @return void\n   */\n  private spreadParents(fn: TypeFnOperation) {\n    fn(this);\n    const { parent } = this;\n    if (!parent) return;\n    parent?.spreadParents(fn);\n  }\n\n  /**\n   * 获取节点封装对象\n   * - TreeNode 对象 => TypeTreeNodeModel 对象\n   * - TypeTreeNodeModel 用于封装 treeNode 对外暴露的 api\n   * - 用户仅可操作经过封装的对象，减少了对外暴露的 api，利于代码重构\n   * @return TypeTreeNodeModel 节点封装对象\n   */\n  public getModel(): TypeTreeNodeModel {\n    let { model } = this;\n    if (!model) {\n      model = createNodeModel(this);\n      this.model = model;\n    }\n    return model;\n  }\n}\n\nexport default TreeNode;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}