{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.every.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\n/**\n * tdesign v1.10.5\n * (c) 2024 tdesign\n * @license MIT\n */\n\nimport { _ as _classCallCheck, a as _createClass } from '../../../_chunks/dep-f909a041.mjs';\nimport { _ as _defineProperty } from '../../../_chunks/dep-fa52aa21.mjs';\nimport { i as isArray_1 } from '../../../_chunks/dep-eae2a67e.mjs';\nimport { i as isFunction_1 } from '../../../_chunks/dep-06dcbf4c.mjs';\nimport { i as isNumber_1 } from '../../../_chunks/dep-889e457b.mjs';\nimport { i as isString_1 } from '../../../_chunks/dep-03a7fb6c.mjs';\nimport { d as difference_1 } from '../../../_chunks/dep-33c61f2b.mjs';\nimport { c as camelCase_1 } from '../../../_chunks/dep-03ad9cda.mjs';\nimport { i as isPlainObject_1 } from '../../../_chunks/dep-1725b1c7.mjs';\nimport mitt from 'mitt';\nimport { TreeNode, privateKey } from './tree-node.mjs';\nimport '../../../_chunks/dep-4659d73b.mjs';\nimport '../../../_chunks/dep-eca422c3.mjs';\nimport '../../../_chunks/dep-bf7257e7.mjs';\nimport '../../../_chunks/dep-2b09875b.mjs';\nimport '../../../_chunks/dep-cda4f568.mjs';\nimport '../../../_chunks/dep-29ef8419.mjs';\nimport '../../../_chunks/dep-626c497d.mjs';\nimport '../../../_chunks/dep-6a7115de.mjs';\nimport '../../../_chunks/dep-4d4e2af1.mjs';\nimport '../../../_chunks/dep-6ab5363f.mjs';\nimport '../../../_chunks/dep-6dc3d0e1.mjs';\nimport '../../../_chunks/dep-76958824.mjs';\nimport '../../../_chunks/dep-e9841b9e.mjs';\nimport '../../../_chunks/dep-3c4e4325.mjs';\nimport '../../../_chunks/dep-7932c2e8.mjs';\nimport '../../../_chunks/dep-ab4bb9b8.mjs';\nimport '../../../_chunks/dep-f5579c03.mjs';\nimport '../../../_chunks/dep-4ec29b23.mjs';\nimport '../../../_chunks/dep-732f0b7d.mjs';\nimport '../../../_chunks/dep-3c65fae8.mjs';\nimport '../../../_chunks/dep-02f9394e.mjs';\nimport '../../../_chunks/dep-b5bf85f5.mjs';\nimport '../../../_chunks/dep-400ec705.mjs';\nimport '../../../_chunks/dep-e065dc25.mjs';\nimport '../../../_chunks/dep-cc8ebcde.mjs';\nimport '../../../_chunks/dep-d8a34055.mjs';\nimport '../../../_chunks/dep-2f6e28a0.mjs';\nimport '../../../_chunks/dep-5a17bf21.mjs';\nimport '../../../_chunks/dep-92f86d1d.mjs';\nimport '../../../_chunks/dep-1a4bb2f2.mjs';\nimport '../../../_chunks/dep-49aeee3c.mjs';\nimport '../../../_chunks/dep-ec0bbd9f.mjs';\nimport '../../../_chunks/dep-0d047dce.mjs';\nimport '../../../_chunks/dep-4a990ea3.mjs';\nimport '../../../_chunks/dep-593f2b67.mjs';\nimport '../../../_chunks/dep-73384992.mjs';\nimport '../../../_chunks/dep-e4a8ef7d.mjs';\nimport '../../../_chunks/dep-df472119.mjs';\nimport '../../../_chunks/dep-d2f4e062.mjs';\nimport '../../../_chunks/dep-ae202bc0.mjs';\nimport '../../../_chunks/dep-aeaef131.mjs';\nimport './tree-node-model.mjs';\nimport '../../../_chunks/dep-58a62202.mjs';\nimport '../../../_chunks/dep-88ae49da.mjs';\nimport '../../../_chunks/dep-5922c8f3.mjs';\nimport '../../../_chunks/dep-1b78414a.mjs';\nimport '../../../_chunks/dep-d84f19b3.mjs';\nimport '../../../_chunks/dep-88c8d9ed.mjs';\nimport '../log/log.mjs';\nimport '../log/index.mjs';\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction nextTick(fn) {\n  var pm = Promise.resolve();\n  pm.then(fn);\n  return pm;\n}\nvar TreeStore = /*#__PURE__*/function () {\n  function TreeStore(options) {\n    _classCallCheck(this, TreeStore);\n    _defineProperty(this, \"children\", void 0);\n    _defineProperty(this, \"nodes\", void 0);\n    _defineProperty(this, \"nodeMap\", void 0);\n    _defineProperty(this, \"privateMap\", void 0);\n    _defineProperty(this, \"config\", void 0);\n    _defineProperty(this, \"activedMap\", void 0);\n    _defineProperty(this, \"updatedMap\", void 0);\n    _defineProperty(this, \"checkedMap\", void 0);\n    _defineProperty(this, \"expandedMap\", void 0);\n    _defineProperty(this, \"filterMap\", void 0);\n    _defineProperty(this, \"hasFilter\", void 0);\n    _defineProperty(this, \"emitter\", void 0);\n    _defineProperty(this, \"updateTick\", void 0);\n    _defineProperty(this, \"shouldReflow\", void 0);\n    _defineProperty(this, \"prevFilter\", void 0);\n    var config = _objectSpread({\n      prefix: \"t\",\n      keys: {},\n      expandAll: false,\n      expandLevel: 0,\n      expandMutex: false,\n      expandParent: false,\n      activable: false,\n      activeMultiple: false,\n      checkable: false,\n      checkStrictly: false,\n      disabled: false,\n      disableCheck: false,\n      draggable: false,\n      load: null,\n      lazy: false,\n      valueMode: \"onlyLeaf\",\n      filter: null,\n      allowFoldNodeOnFilter: false,\n      onLoad: null,\n      onReflow: null,\n      onUpdate: null\n    }, options);\n    this.config = config;\n    this.nodes = [];\n    this.children = [];\n    this.nodeMap = /* @__PURE__ */new Map();\n    this.privateMap = /* @__PURE__ */new Map();\n    this.activedMap = /* @__PURE__ */new Map();\n    this.expandedMap = /* @__PURE__ */new Map();\n    this.checkedMap = /* @__PURE__ */new Map();\n    this.updatedMap = /* @__PURE__ */new Map();\n    this.filterMap = /* @__PURE__ */new Map();\n    this.prevFilter = null;\n    this.updateTick = null;\n    this.shouldReflow = false;\n    this.hasFilter = isFunction_1(config.filter);\n    this.emitter = mitt();\n  }\n  return _createClass(TreeStore, [{\n    key: \"setConfig\",\n    value: function setConfig(options) {\n      var config = this.config;\n      var hasChanged = false;\n      Object.keys(options).forEach(function (key) {\n        var val = options[key];\n        if (val !== config[key]) {\n          hasChanged = true;\n          config[key] = val;\n        }\n      });\n      this.hasFilter = isFunction_1(config.filter);\n      if (hasChanged) {\n        this.refreshState();\n      }\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren() {\n      return this.children;\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(item) {\n      var node = null;\n      if (isString_1(item) || isNumber_1(item)) {\n        node = this.nodeMap.get(item);\n      } else if (item instanceof TreeNode) {\n        node = this.nodeMap.get(item.value);\n      }\n      if (!node) node = null;\n      return node;\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex(node) {\n      return this.nodes.indexOf(node);\n    }\n  }, {\n    key: \"getParent\",\n    value: function getParent(value) {\n      var parent = null;\n      var node = this.getNode(value);\n      if (node) {\n        parent = node.getParent();\n      }\n      return parent;\n    }\n  }, {\n    key: \"getParents\",\n    value: function getParents(value) {\n      var node = this.getNode(value);\n      var parents = [];\n      if (node) {\n        parents = node.getParents();\n      }\n      return parents;\n    }\n  }, {\n    key: \"getNodeIndex\",\n    value: function getNodeIndex(value) {\n      var node = this.getNode(value);\n      var index = -1;\n      if (node) {\n        index = node.getIndex();\n      }\n      return index;\n    }\n  }, {\n    key: \"getNodes\",\n    value: function getNodes(item, options) {\n      var nodes = [];\n      var val = \"\";\n      if (isString_1(item) || isNumber_1(item)) {\n        val = item;\n      } else if (item instanceof TreeNode) {\n        val = item.value;\n      }\n      if (!val && val !== 0) {\n        nodes = this.nodes.slice(0);\n      } else {\n        var node = this.getNode(val);\n        if (node) {\n          nodes = node.walk();\n        }\n      }\n      if (options) {\n        var conf = _objectSpread({\n          filter: null,\n          level: Infinity\n        }, options);\n        if (isNumber_1(conf.level) && conf.level !== Infinity) {\n          nodes = nodes.filter(function (node) {\n            return node.level <= conf.level;\n          });\n        }\n        if (isFunction_1(conf.filter)) {\n          nodes = nodes.filter(function (node) {\n            var nodeModel = node.getModel();\n            return conf.filter(nodeModel);\n          });\n        }\n        if (isPlainObject_1(conf.props)) {\n          nodes = nodes.filter(function (node) {\n            var result = Object.keys(conf.props).every(function (key) {\n              var propEqual = node[key] === conf.props[key];\n              return propEqual;\n            });\n            return result;\n          });\n        }\n      }\n      return nodes;\n    }\n  }, {\n    key: \"append\",\n    value: function append(list) {\n      var _this = this;\n      list.forEach(function (item) {\n        var node = new TreeNode(_this, item);\n        _this.children.push(node);\n      });\n      this.reflow();\n    }\n  }, {\n    key: \"reload\",\n    value: function reload(list) {\n      this.removeAll();\n      this.append(list);\n    }\n  }, {\n    key: \"parseNodeData\",\n    value: function parseNodeData(para, item) {\n      var value = \"\";\n      var node = null;\n      var data = null;\n      if (isString_1(para) || isNumber_1(para)) {\n        value = para;\n        node = this.getNode(value);\n        data = item;\n      } else if (para instanceof TreeNode) {\n        if (item) {\n          node = para;\n          data = item;\n        } else {\n          data = para;\n        }\n      } else {\n        data = para;\n      }\n      var spec = {\n        node: node,\n        data: data\n      };\n      return spec;\n    }\n  }, {\n    key: \"appendNodes\",\n    value: function appendNodes(para, item) {\n      var spec = this.parseNodeData(para, item);\n      if (spec.data) {\n        if (!spec.node) {\n          if (spec.data instanceof TreeNode) {\n            spec.data.appendTo(this);\n          } else if (Array.isArray(spec.data)) {\n            this.append(spec.data);\n          } else {\n            this.append([spec.data]);\n          }\n        } else {\n          if (spec.data instanceof TreeNode) {\n            spec.data.appendTo(this, spec.node);\n          } else if (isArray_1(spec.data)) {\n            spec.node.append(spec.data);\n          } else {\n            spec.node.append([spec.data]);\n          }\n          spec.node.updateRelated();\n        }\n      }\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(value, item) {\n      var node = this.getNode(value);\n      if (node) {\n        node.insertBefore(item);\n      }\n    }\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(value, item) {\n      var node = this.getNode(value);\n      if (node) {\n        node.insertAfter(item);\n      }\n    }\n  }, {\n    key: \"refreshNodes\",\n    value: function refreshNodes() {\n      var children = this.children,\n        nodes = this.nodes;\n      nodes.length = 0;\n      children.forEach(function (node) {\n        var list = node.walk();\n        Array.prototype.push.apply(nodes, list);\n      });\n    }\n  }, {\n    key: \"reflow\",\n    value: function reflow(node) {\n      this.shouldReflow = true;\n      this.updated(node);\n    }\n  }, {\n    key: \"updated\",\n    value: function updated(node) {\n      var _this2 = this;\n      var updatedMap = this.updatedMap;\n      if (node) {\n        updatedMap.set(node[privateKey], \"changed\");\n      } else {\n        this.getNodes().forEach(function (itemNode) {\n          updatedMap.set(itemNode[privateKey], \"changed\");\n        });\n      }\n      if (this.updateTick) return;\n      this.updateTick = nextTick(function () {\n        _this2.updateTick = null;\n        if (_this2.shouldReflow) {\n          _this2.refreshNodes();\n          _this2.emit(\"reflow\");\n        }\n        _this2.lockFilterPathNodes();\n        var stateId = \"t\".concat(new Date().getTime());\n        var updatedList = Array.from(updatedMap.keys());\n        var updatedNodes = updatedList.map(function (nodePrivateKey) {\n          updatedMap.set(nodePrivateKey, stateId);\n          return _this2.privateMap.get(nodePrivateKey);\n        });\n        _this2.emit(\"update\", {\n          nodes: updatedNodes,\n          map: updatedMap\n        });\n        _this2.shouldReflow = false;\n        updatedMap.clear();\n      });\n    }\n  }, {\n    key: \"getActived\",\n    value: function getActived(map) {\n      var activedMap = map || this.activedMap;\n      return Array.from(activedMap.keys());\n    }\n  }, {\n    key: \"getActivedNodes\",\n    value: function getActivedNodes(item) {\n      var nodes = this.getNodes(item);\n      nodes = nodes.filter(function (node) {\n        return node.isActived();\n      });\n      return nodes;\n    }\n  }, {\n    key: \"replaceActived\",\n    value: function replaceActived(list) {\n      this.resetActived();\n      this.setActived(list);\n    }\n  }, {\n    key: \"setActived\",\n    value: function setActived(actived) {\n      var _this3 = this;\n      var activeMultiple = this.config.activeMultiple;\n      var list = actived.slice(0);\n      if (!activeMultiple) {\n        list.length = 1;\n      }\n      list.forEach(function (val) {\n        _this3.activedMap.set(val, true);\n        var node = _this3.getNode(val);\n        if (node) {\n          node.update();\n        }\n      });\n    }\n  }, {\n    key: \"resetActived\",\n    value: function resetActived() {\n      var actived = this.getActived();\n      this.activedMap.clear();\n      var relatedNodes = this.getRelatedNodes(actived);\n      relatedNodes.forEach(function (node) {\n        node.update();\n      });\n    }\n  }, {\n    key: \"getExpanded\",\n    value: function getExpanded(map) {\n      var expandedMap = map || this.expandedMap;\n      return Array.from(expandedMap.keys());\n    }\n  }, {\n    key: \"replaceExpanded\",\n    value: function replaceExpanded(list) {\n      var expanded = this.getExpanded();\n      var added = difference_1(list, expanded);\n      var removed = difference_1(expanded, list);\n      this.setExpandedDirectly(removed, false);\n      this.updateExpanded(removed);\n      this.setExpanded(added);\n    }\n  }, {\n    key: \"setExpanded\",\n    value: function setExpanded(list) {\n      this.setExpandedDirectly(list);\n      this.updateExpanded(list);\n    }\n  }, {\n    key: \"setExpandedDirectly\",\n    value: function setExpandedDirectly(list) {\n      var _this4 = this;\n      var expanded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      list.forEach(function (val) {\n        if (expanded) {\n          _this4.expandedMap.set(val, true);\n        } else {\n          _this4.expandedMap[\"delete\"](val);\n        }\n        var node = _this4.getNode(val);\n        if (node) {\n          node.afterExpanded();\n        }\n      });\n    }\n  }, {\n    key: \"resetExpanded\",\n    value: function resetExpanded() {\n      var expanded = this.getExpanded();\n      this.expandedMap.clear();\n      this.updateExpanded(expanded);\n    }\n  }, {\n    key: \"updateExpanded\",\n    value: function updateExpanded(list) {\n      var relatedNodes = this.getRelatedNodes(list, {\n        withParents: false\n      });\n      relatedNodes.forEach(function (node) {\n        node.update();\n      });\n    }\n  }, {\n    key: \"getChecked\",\n    value: function getChecked(map) {\n      var nodeMap = this.nodeMap,\n        config = this.config;\n      var valueMode = config.valueMode,\n        checkStrictly = config.checkStrictly;\n      var list = [];\n      var checkedMap = map || this.checkedMap;\n      nodeMap.forEach(function (node) {\n        if (!node.isChecked(checkedMap)) return;\n        if (valueMode === \"parentFirst\" && !checkStrictly) {\n          if (!node.parent || !node.parent.isChecked(checkedMap)) {\n            list.push(node.value);\n          }\n        } else if (valueMode === \"onlyLeaf\" && !checkStrictly) {\n          if (node.isLeaf()) {\n            list.push(node.value);\n          }\n        } else {\n          list.push(node.value);\n        }\n      });\n      return list;\n    }\n  }, {\n    key: \"getCheckedNodes\",\n    value: function getCheckedNodes(item) {\n      var nodes = this.getNodes(item);\n      nodes = nodes.filter(function (node) {\n        return node.isChecked();\n      });\n      return nodes;\n    }\n  }, {\n    key: \"replaceChecked\",\n    value: function replaceChecked(list) {\n      this.resetChecked();\n      this.setChecked(list);\n    }\n  }, {\n    key: \"setChecked\",\n    value: function setChecked(list) {\n      var _this5 = this;\n      var _this$config = this.config,\n        checkStrictly = _this$config.checkStrictly,\n        checkable = _this$config.checkable;\n      if (!checkable) return;\n      list.forEach(function (val) {\n        var node = _this5.getNode(val);\n        if (!node) return;\n        if (checkStrictly) {\n          _this5.checkedMap.set(val, true);\n          node.updateChecked();\n        } else {\n          var childrenNodes = node.walk();\n          childrenNodes.forEach(function (childNode) {\n            _this5.checkedMap.set(childNode.value, true);\n          });\n        }\n      });\n      if (!checkStrictly) {\n        var checkedValues = this.getChecked();\n        var relatedNodes = this.getRelatedNodes(checkedValues);\n        relatedNodes.forEach(function (node) {\n          node.updateChecked();\n        });\n      }\n    }\n  }, {\n    key: \"resetChecked\",\n    value: function resetChecked() {\n      var checked = this.getChecked();\n      var relatedNodes = this.getRelatedNodes(checked);\n      this.checkedMap.clear();\n      relatedNodes.forEach(function (node) {\n        node.updateChecked();\n      });\n    }\n  }, {\n    key: \"refreshState\",\n    value: function refreshState() {\n      var nodeMap = this.nodeMap;\n      nodeMap.forEach(function (node) {\n        node.update();\n      });\n    }\n  }, {\n    key: \"updateAll\",\n    value: function updateAll() {\n      var nodeMap = this.nodeMap;\n      nodeMap.forEach(function (node) {\n        node.update();\n        node.updateChecked();\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(value) {\n      var node = this.getNode(value);\n      if (node) {\n        node.remove();\n      }\n    }\n  }, {\n    key: \"removeAll\",\n    value: function removeAll() {\n      this.expandedMap.clear();\n      this.checkedMap.clear();\n      this.activedMap.clear();\n      this.filterMap.clear();\n      this.nodeMap.clear();\n      this.privateMap.clear();\n      this.updatedMap.clear();\n      this.nodes = [];\n      this.children = [];\n      this.reflow();\n    }\n  }, {\n    key: \"getRelatedNodes\",\n    value: function getRelatedNodes(list, options) {\n      var _this6 = this;\n      var conf = _objectSpread({\n        reverse: false,\n        withParents: true\n      }, options);\n      var map = /* @__PURE__ */new Map();\n      list.forEach(function (value) {\n        if (map.get(value)) return;\n        var node = _this6.getNode(value);\n        if (node) {\n          var parents = node.getParents().reverse();\n          var children = node.walk();\n          var related = [];\n          if (conf.withParents) {\n            related = parents.concat(children);\n          } else {\n            related = children;\n          }\n          related.forEach(function (relatedNode) {\n            map.set(relatedNode.value, relatedNode);\n          });\n        }\n      });\n      var relatedNodes = Array.from(map.values());\n      if (conf.reverse) {\n        relatedNodes = relatedNodes.reverse();\n      }\n      return relatedNodes;\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(name, state) {\n      var config = this.config,\n        emitter = this.emitter;\n      var methodName = camelCase_1(\"on-\".concat(name));\n      var method = config[methodName];\n      if (isFunction_1(method)) {\n        method(state);\n      }\n      emitter.emit(name, state);\n    }\n  }, {\n    key: \"lockFilterPathNodes\",\n    value: function lockFilterPathNodes() {\n      var config = this.config;\n      var allNodes = this.getNodes();\n      if (this.prevFilter) {\n        allNodes.forEach(function (node) {\n          if (node.vmIsLocked) {\n            node.lock(false);\n          }\n        });\n      }\n      var currentFilter = config.filter;\n      if (!currentFilter || !isFunction_1(currentFilter)) return;\n      this.prevFilter = config.filter;\n      allNodes.reverse().forEach(function (node) {\n        var parent = node.getParent();\n        if (!parent) return;\n        if (node.vmIsRest || node.vmIsLocked) {\n          if (!parent.vmIsLocked) {\n            parent.lock(true);\n          }\n        }\n      });\n    }\n  }]);\n}();\nexport { TreeStore, TreeStore as default };","map":{"version":3,"names":["nextTick","fn","pm","Promise","resolve","then","TreeStore","options","_classCallCheck","_defineProperty","config","_objectSpread","prefix","keys","expandAll","expandLevel","expandMutex","expandParent","activable","activeMultiple","checkable","checkStrictly","disabled","disableCheck","draggable","load","lazy","valueMode","filter","allowFoldNodeOnFilter","onLoad","onReflow","onUpdate","nodes","children","nodeMap","Map","privateMap","activedMap","expandedMap","checkedMap","updatedMap","filterMap","prevFilter","updateTick","shouldReflow","hasFilter","isFunction_1","emitter","mitt","_createClass","key","value","setConfig","hasChanged","Object","forEach","val","refreshState","getChildren","getNode","item","node","isString_1","isNumber_1","get","TreeNode","getIndex","indexOf","getParent","parent","getParents","parents","getNodeIndex","index","getNodes","slice","walk","conf","level","Infinity","nodeModel","getModel","isPlainObject_1","props","result","every","propEqual","append","list","_this","push","reflow","reload","removeAll","parseNodeData","para","data","spec","appendNodes","appendTo","Array","isArray","isArray_1","updateRelated","insertBefore","insertAfter","refreshNodes","length","prototype","apply","updated","_this2","set","privateKey","itemNode","emit","lockFilterPathNodes","stateId","concat","Date","getTime","updatedList","from","updatedNodes","map","nodePrivateKey","clear","getActived","getActivedNodes","isActived","replaceActived","resetActived","setActived","actived","_this3","update","relatedNodes","getRelatedNodes","getExpanded","replaceExpanded","expanded","added","difference_1","removed","setExpandedDirectly","updateExpanded","setExpanded","_this4","arguments","undefined","afterExpanded","resetExpanded","withParents","getChecked","isChecked","isLeaf","getCheckedNodes","replaceChecked","resetChecked","setChecked","_this5","_this$config","updateChecked","childrenNodes","childNode","checkedValues","checked","updateAll","remove","_this6","reverse","related","relatedNode","values","name","state","methodName","camelCase_1","method","allNodes","vmIsLocked","lock","currentFilter","vmIsRest"],"sources":["../../../../src/_common/js/tree/tree-store.ts"],"sourcesContent":["import isArray from 'lodash/isArray';\nimport isFunction from 'lodash/isFunction';\nimport isNumber from 'lodash/isNumber';\nimport isString from 'lodash/isString';\nimport difference from 'lodash/difference';\nimport camelCase from 'lodash/camelCase';\nimport isPlainObject from 'lodash/isPlainObject';\nimport mitt from 'mitt';\n\nimport { TreeNode, privateKey } from './tree-node';\nimport {\n  TreeNodeValue,\n  TypeIdMap,\n  TypeTargetNode,\n  TypeTreeNodeData,\n  TypeTreeItem,\n  TypeTreeStoreOptions,\n  TypeTreeFilter,\n  TypeTreeFilterOptions,\n  TypeRelatedNodesOptions,\n  TypeTreeEventState,\n  TypeUpdatedMap,\n} from './types';\n\nfunction nextTick(fn: () => void): Promise<void> {\n  const pm = Promise.resolve();\n  pm.then(fn);\n  return pm;\n}\n\n// 构建一个树的数据模型\n// 基本设计思想：写入时更新，减少读取消耗，以减少未来实现虚拟滚动所需的计算量\n// 任何一次数据写入，会触发相应节点的状态更新\n// public 方法，在 ui 组件中有可能在使用，会保障其输入输出实现\n// private 方法，可能会改动其输入输出\n\n/**\n * tree 数据模型\n * @class TreeStore\n * @param {object} options tree 组件选项\n * @param {string} [options.prefix=\"t\"] tree 组件内部属性前缀\n * @param {object} options.keys 取值映射对象，部分属性按照其 key/value 来取 treeNode 属性值\n * @param {string} [options.keys.label=\"label\"] 从 data 种取 label 值时读取的属性名称\n * @param {string} [options.keys.value=\"value\"] 从 data 种取 value 值时读取的属性名称\n * @param {string} [options.keys.children=\"children\"] 从 data 种取 children 值时读取的属性名称\n * @param {boolean} [options.expandAll=false] 初始化节点时，是否自动展开\n * @param {number} [options.expandLevel=0] 初始化节点时，自动展开的级别\n * @param {boolean} [options.expandMutex=false] 展开时，是否使用手风琴模式\n * @param {boolean} [options.expandParent=false] 展开节点时，是否自动展开父节点\n * @param {boolean} [options.activable=false] 是否可以激活节点\n * @param {boolean} [options.activeMultiple=false] 激活节点是否使用多选模式\n * @param {boolean} [options.checkable=false] 节点是否可选中\n * @param {boolean} [options.checkStrictly=false] 节点选中是否使用严格模式\n * @param {boolean} [options.disabled=false] 节点是否禁用\n * @param {boolean|function} [options.disableCheck=false] 节点被禁用的条件\n * @param {boolean} [options.draggable=false] 节点是否可拖动\n * @param {function} [options.load=null] 节点延迟加载函数\n * @param {boolean} [options.lazy=false] 节点是否使用延迟加载模式\n * @param {string} [options.valueMode=\"onlyLeaf\"] 节点选中取值模式\n * @param {function} [options.filter=null] 节点过滤函数\n * @param {function} [options.onLoad=null] 节点延迟加载完成时的回调函数\n * @param {function} [options.onReflow=null] 节点触发回流后的回调\n * @param {function} [options.onUpdate=null] 节点触发更新后的后调\n * @param {boolean} [options.allowFoldNodeOnFilter=false] 过滤时，是否允许折叠节点\n */\nexport class TreeStore {\n  // 根节点集合\n  public children: TreeNode[];\n\n  // 所有节点集合\n  public nodes: TreeNode[];\n\n  // 所有节点映射\n  public nodeMap: Map<TreeNodeValue, TreeNode>;\n\n  // 节点 私有 ID 映射\n  public privateMap: Map<TreeNodeValue, TreeNode>;\n\n  // 配置选项\n  public config: TypeTreeStoreOptions;\n\n  // 活动节点集合\n  public activedMap: TypeIdMap;\n\n  // 数据被更新的节点集合\n  public updatedMap: TypeUpdatedMap;\n\n  // 选中节点集合\n  public checkedMap: TypeIdMap;\n\n  // 展开节点的集合\n  public expandedMap: TypeIdMap;\n\n  // 符合过滤条件的节点的集合\n  public filterMap: TypeIdMap;\n\n  // 存在过滤器标志\n  public hasFilter: boolean;\n\n  // 事件派发器\n  public emitter: ReturnType<typeof mitt>;\n\n  // 数据更新计时器\n  private updateTick: Promise<void>;\n\n  // 识别是否需要重排\n  private shouldReflow: boolean;\n\n  // 树节点过滤器\n  private prevFilter: TypeTreeFilter;\n\n  public constructor(options: TypeTreeStoreOptions) {\n    const config: TypeTreeStoreOptions = {\n      prefix: 't',\n      keys: {},\n      expandAll: false,\n      expandLevel: 0,\n      expandMutex: false,\n      expandParent: false,\n      activable: false,\n      activeMultiple: false,\n      checkable: false,\n      checkStrictly: false,\n      disabled: false,\n      disableCheck: false,\n      draggable: false,\n      load: null,\n      lazy: false,\n      valueMode: 'onlyLeaf',\n      filter: null,\n      // 每次搜索条件变更，重置展开状态，路径节点展开，显示命中节点\n      // allowFoldNodeOnFilter 为 true 时，搜索条件不变的情况下，允许折叠路径节点\n      // 默认状态，allowFoldNodeOnFilter 为 false 时，路径节点无法折叠\n      allowFoldNodeOnFilter: false,\n      onLoad: null,\n      onReflow: null,\n      onUpdate: null,\n      ...options,\n    };\n    this.config = config;\n    this.nodes = [];\n    this.children = [];\n    this.nodeMap = new Map();\n    this.privateMap = new Map();\n    this.activedMap = new Map();\n    this.expandedMap = new Map();\n    this.checkedMap = new Map();\n    this.updatedMap = new Map();\n    this.filterMap = new Map();\n    this.prevFilter = null;\n    // 这个计时器确保频繁的 update 事件被归纳为1次完整数据更新后的触发\n    this.updateTick = null;\n    // 在子节点增删改查时，将此属性设置为 true，来触发视图更新\n    this.shouldReflow = false;\n    // 这个标志会被大量用到\n    this.hasFilter = isFunction(config.filter);\n    this.emitter = mitt();\n  }\n\n  /**\n   * 配置选项\n   * @param {object} options tree 组件选项\n   * @return void\n   */\n  public setConfig(options: TypeTreeStoreOptions) {\n    const { config } = this;\n    let hasChanged = false;\n    Object.keys(options).forEach((key) => {\n      const val = options[key];\n      if (val !== config[key]) {\n        hasChanged = true;\n        config[key] = val;\n      }\n    });\n    this.hasFilter = isFunction(config.filter);\n    if (hasChanged) {\n      // 在 td-tree 的 render 方法中调用 setConfig\n      // 这样减少了 watch 属性\n      // 仅在属性变更后刷新状态\n      // 这样可以避免触发渲染死循环\n      this.refreshState();\n    }\n  }\n\n  /**\n   * 获取根节点列表\n   * @return TreeNode[] 根节点对象数组\n   */\n  public getChildren(): TreeNode[] {\n    return this.children;\n  }\n\n  /**\n   * 获取指定节点对象\n   * @param {string|number|TreeNode} item 获取节点对象的条件，可以是节点 value，也可以是节点本身\n   * @return TreeNode 节点对象，如果判断树中没有符合条件的节点，返回 null\n   */\n  public getNode(item: TypeTargetNode): TreeNode {\n    let node = null;\n    if (isString(item) || isNumber(item)) {\n      node = this.nodeMap.get(item);\n    } else if (item instanceof TreeNode) {\n      node = this.nodeMap.get(item.value);\n    }\n    if (!node) node = null;\n    return node;\n  }\n\n  /**\n   * 获取节点在总节点列表中的位置\n   * @param {TreeNode} node 节点对象\n   * @return number 节点在总节点列表中的位置序号\n   */\n  public getIndex(node: TreeNode): number {\n    return this.nodes.indexOf(node);\n  }\n\n  /**\n   * 获取指定节点的父节点\n   * @param {string} value 节点值\n   * @return TreeNode 节点对象\n   */\n  public getParent(value: TypeTargetNode): TreeNode {\n    let parent = null;\n    const node = this.getNode(value);\n    if (node) {\n      parent = node.getParent();\n    }\n    return parent;\n  }\n\n  /**\n   * 获取指定节点的所有父节点\n   * @param {string} value 节点值\n   * @return TreeNode[] 父节点数组\n   */\n  public getParents(value: TypeTargetNode): TreeNode[] {\n    const node = this.getNode(value);\n    let parents: TreeNode[] = [];\n    if (node) {\n      parents = node.getParents();\n    }\n    return parents;\n  }\n\n  /**\n   * 获取指定节点在其所在 children 中的位置\n   * @param {string} value 节点值\n   * @return number 节点在 children 中的位置序号\n   */\n  public getNodeIndex(value: TypeTargetNode): number {\n    const node = this.getNode(value);\n    let index = -1;\n    if (node) {\n      index = node.getIndex();\n    }\n    return index;\n  }\n\n  /**\n   * 获取所有符合条件的节点，按回流排序后的顺序给出\n   * 以这些字段作为示例:\n   * - value: 节点值(ID)\n   * - TreeNode: 节点实例\n   * - level: 节点层级\n   * - filter: 节点过滤函数\n   * 支持下列使用方式\n   * - getNodes() 获取所有节点\n   * - getNodes(value) 获取节点值对应的目标节点下，包含自己在内的所有子节点\n   * - getNodes(TreeNode) 获取目标节点下，包含自己在内的所有子节点\n   * - getNodes(value, { level: 2 }) 获取目标节点下，层级在 2 以内的子节点\n   * - getNodes(value, { filter: node => (!node.checked) }) 获取目标节点下，未选中的节点\n   * - getNodes(value, { props: { actived: true } }) 获取目标节点下，已激活的节点\n   * @param {string | TreeNode} [item] 节点值，节点对象\n   * @param {object} [options] 节点过滤条件，可传递节点属性，过滤出属性一致的节点\n   * @param {number} [options.level=Infinity] 节点层级\n   * @param {function} [options.filter=null] 节点过滤条件函数\n   * @param {object} [options.props] 节点属性对象，作为过滤条件\n   * @return TreeNode[] 符合条件的节点数组\n   */\n  public getNodes(\n    item?: TypeTargetNode,\n    options?: TypeTreeFilterOptions,\n  ): TreeNode[] {\n    let nodes: TreeNode[] = [];\n    let val: TreeNodeValue = '';\n    if (isString(item) || isNumber(item)) {\n      val = item;\n    } else if (item instanceof TreeNode) {\n      val = item.value;\n    }\n    if (!val && val !== 0) {\n      nodes = this.nodes.slice(0);\n    } else {\n      const node = this.getNode(val);\n      if (node) {\n        nodes = node.walk();\n      }\n    }\n\n    if (options) {\n      const conf: TypeTreeFilterOptions = {\n        filter: null,\n        level: Infinity,\n        ...options,\n      };\n      if (isNumber(conf.level) && conf.level !== Infinity) {\n        nodes = nodes.filter((node) => node.level <= conf.level);\n      }\n      if (isFunction(conf.filter)) {\n        nodes = nodes.filter((node) => {\n          const nodeModel = node.getModel();\n          return conf.filter(nodeModel);\n        });\n      }\n      if (isPlainObject(conf.props)) {\n        nodes = nodes.filter((node) => {\n          const result = Object.keys(conf.props).every((key) => {\n            const propEqual = node[key] === conf.props[key];\n            return propEqual;\n          });\n          return result;\n        });\n      }\n    }\n    return nodes;\n  }\n\n  /**\n   * 添加新节点数据\n   * @param {object[]} list 节点数据对象数组\n   * @return void\n   */\n  public append(list: TypeTreeNodeData[]): void {\n    list.forEach((item) => {\n      const node = new TreeNode(this, item);\n      this.children.push(node);\n    });\n    this.reflow();\n  }\n\n  /**\n   * 清空当前树的数据，重新加载数据\n   * @param {object[]} list 节点数据对象数组\n   * @return void\n   */\n  public reload(list: TypeTreeNodeData[]): void {\n    this.removeAll();\n    this.append(list);\n  }\n\n  /**\n   * 解析节点数据，适配多种节点类型\n   * @param {string | TreeNode | object} para 树节点值，或者树节点，或者节点构造数据\n   * @param {object | TreeNode} item 节点构造数据, 或者节点构造数据数组，或者树节点\n   * @return spec 解析完成的数据结构\n   * - {TreeNode} spec.node 目标树节点\n   * - {object} spec.data 节点构造数据\n   */\n  private parseNodeData(\n    para: TreeNodeValue | TreeNode | TypeTreeNodeData,\n    item: TypeTreeNodeData | TreeNode,\n  ) {\n    let value: TreeNodeValue = '';\n    let node = null;\n    let data = null;\n\n    if (isString(para) || isNumber(para)) {\n      value = para;\n      node = this.getNode(value);\n      data = item;\n    } else if (para instanceof TreeNode) {\n      if (item) {\n        node = para;\n        data = item;\n      } else {\n        data = para;\n      }\n    } else {\n      data = para;\n    }\n    const spec = {\n      node,\n      data,\n    };\n    return spec;\n  }\n\n  /**\n   * 向指定节点追加节点或者数据\n   * 以这些字段作为示例: item: 节点数据, TreeNode: 节点实例, value: 节点值(ID)\n   * 支持下列使用方式\n   * - appendNodes(item) 直接传递节点构造数据，新增节点\n   * - appendNodes(TreeNode) 传递别的树的树节点，新增节点\n   * - appendNodes(value, item) 以节点值查找指定节点，并新增节点构造数据\n   * - appendNodes(value, TreeNode) 以节点值查找指定节点，并新增树节点\n   * - appendNodes(TreeNode, item) 向指定节点新增节点构造数据\n   * - appendNodes(TreeNode, TreeNode) 向指定节点新增树节点\n   * @param {string | TreeNode | object} para 树节点值，或者树节点，或者节点构造数据\n   * @param {object | TreeNode} [item] 节点构造数据, 或者节点构造数据数组，或者树节点\n   * @return void\n   */\n  public appendNodes(\n    para: TypeTargetNode | TypeTreeNodeData,\n    item?: TypeTreeNodeData | TreeNode,\n  ): void {\n    const spec = this.parseNodeData(para, item);\n    if (spec.data) {\n      if (!spec.node) {\n        // 在根节点插入\n        if (spec.data instanceof TreeNode) {\n          spec.data.appendTo(this);\n        } else if (Array.isArray(spec.data)) {\n          this.append(spec.data);\n        } else {\n          this.append([spec.data]);\n        }\n      } else {\n        // 插入到目标节点之下\n        if (spec.data instanceof TreeNode) {\n          spec.data.appendTo(this, spec.node);\n        } else if (isArray(spec.data)) {\n          spec.node.append(spec.data);\n        } else {\n          spec.node.append([spec.data]);\n        }\n        spec.node.updateRelated();\n      }\n    }\n  }\n\n  /**\n   * 在目标节点之前插入节点\n   * @param {string | TreeNode} value 节点值，或者树节点\n   * @param {object | TreeNode} item 节点构造数据, 或者树节点\n   * @return void\n   */\n  public insertBefore(value: TypeTargetNode, item: TypeTreeItem): void {\n    const node = this.getNode(value);\n    if (node) {\n      node.insertBefore(item);\n    }\n  }\n\n  /**\n   * 在目标节点之后插入节点\n   * @param {string | TreeNode} value 节点值，或者树节点\n   * @param {object | TreeNode} item 节点构造数据, 或者树节点\n   * @return void\n   */\n  public insertAfter(value: TypeTargetNode, item: TypeTreeItem): void {\n    const node = this.getNode(value);\n    if (node) {\n      node.insertAfter(item);\n    }\n  }\n\n  /**\n   * 更新树结构\n   * - 清空 nodes 数组，然后遍历所有根节点重新插入 node\n   * - 这个操作将会为树结构数据提供一个一纬数组索引\n   * @return void\n   */\n  public refreshNodes(): void {\n    const { children, nodes } = this;\n    nodes.length = 0;\n    children.forEach((node) => {\n      const list = node.walk();\n      Array.prototype.push.apply(nodes, list);\n    });\n  }\n\n  /**\n   * 标记节点重排\n   * - 应该仅在树节点增删改查时调用\n   * - 节点重排会在延时后触发 refreshNodes 方法的调用\n   * @param {TreeNode} [node] 触发重排的树节点\n   * @return void\n   */\n  public reflow(node?: TreeNode): void {\n    this.shouldReflow = true;\n    this.updated(node);\n  }\n\n  /**\n   * 触发更新事件\n   * - 节点属性变更时调用\n   * - 统一延时后，处理需要在其他节点状态更新后再处理的逻辑，减少这类逻辑的重复调用开销\n   * - 统一延时后，派发事件，通知树已更新完毕，以及回流完毕，触发 vue 视图渲染操作\n   * @param {TreeNode} [node] 触发更新的树节点\n   * @return void\n   */\n  public updated(node?: TreeNode): void {\n    const { updatedMap } = this;\n    if (node) {\n      // 传入节点，则为指定节点的更新\n      updatedMap.set(node[privateKey], 'changed');\n    } else {\n      // reflow 流程不传入节点，需要更新所有节点\n      this.getNodes().forEach((itemNode) => {\n        updatedMap.set(itemNode[privateKey], 'changed');\n      });\n    }\n\n    if (this.updateTick) return;\n    this.updateTick = nextTick(() => {\n      this.updateTick = null;\n\n      // 检查节点是否需要回流，重排数组\n      if (this.shouldReflow) {\n        this.refreshNodes();\n        this.emit('reflow');\n      }\n\n      // 检查节点是否有被过滤，锁定路径节点\n      // 在此之前要遍历节点生成一个经过排序的节点数组\n      // 以便于优化锁定检查算法\n      this.lockFilterPathNodes();\n\n      // stateId 用于单个节点状态监控\n      const stateId = `t${new Date().getTime()}`;\n      const updatedList = Array.from(updatedMap.keys());\n      const updatedNodes = updatedList.map((nodePrivateKey) => {\n        updatedMap.set(nodePrivateKey, stateId);\n        return this.privateMap.get(nodePrivateKey);\n      });\n\n      // 统计需要更新状态的节点，派发更新事件\n      this.emit('update', {\n        nodes: updatedNodes,\n        map: updatedMap,\n      });\n\n      // 每次回流检查完毕，还原检查状态\n      this.shouldReflow = false;\n      updatedMap.clear();\n    });\n  }\n\n  /**\n   * 获取激活节点集合\n   * @param {Map} [map] 预设激活节点 map, 用于受控操作时预先获取结果而不直接操作节点状态\n   * @return string[] 激活节点值数组\n   */\n  public getActived(map?: TypeIdMap): TreeNodeValue[] {\n    const activedMap = map || this.activedMap;\n    return Array.from(activedMap.keys());\n  }\n\n  /**\n   * 获取指定范围的激活节点\n   * - 范围是目标节点在内所有子节点\n   * @param {string | TreeNode} [item] 目标节点值，或者目标节点本身\n   * @return TreeNode[] 激活节点数组\n   */\n  public getActivedNodes(item?: TypeTargetNode): TreeNode[] {\n    let nodes = this.getNodes(item);\n    nodes = nodes.filter((node) => node.isActived());\n    return nodes;\n  }\n\n  /**\n   * 替换激活态\n   * @param {string[]} list 目标节点值数组\n   * @return void\n   */\n  public replaceActived(list: TreeNodeValue[]): void {\n    this.resetActived();\n    this.setActived(list);\n  }\n\n  /**\n   * 设置激活态\n   * @param {string[]} list 目标节点值数组\n   * @return void\n   */\n  public setActived(actived: TreeNodeValue[]): void {\n    const { activeMultiple } = this.config;\n    const list = actived.slice(0);\n    if (!activeMultiple) {\n      list.length = 1;\n    }\n    list.forEach((val) => {\n      this.activedMap.set(val, true);\n      const node = this.getNode(val);\n      if (node) {\n        node.update();\n      }\n    });\n  }\n\n  /**\n   * 清空所有节点的激活状态\n   * @return void\n   */\n  public resetActived(): void {\n    const actived = this.getActived();\n    this.activedMap.clear();\n    const relatedNodes = this.getRelatedNodes(actived);\n    relatedNodes.forEach((node) => {\n      node.update();\n    });\n  }\n\n  /**\n   * 获取展开节点集合\n   * @param {Map} [map] 预设展开节点 map, 用于受控操作时预先获取结果而不直接操作节点状态\n   * @return void\n   */\n  public getExpanded(map?: TypeIdMap): TreeNodeValue[] {\n    const expandedMap = map || this.expandedMap;\n    return Array.from(expandedMap.keys());\n  }\n\n  /**\n   * 替换展开节点\n   * @param {string[]} list 目标节点值数组\n   * @return void\n   */\n  public replaceExpanded(list: TreeNodeValue[]): void {\n    const expanded = this.getExpanded();\n    const added = difference(list, expanded);\n    const removed = difference(expanded, list);\n    this.setExpandedDirectly(removed, false);\n    this.updateExpanded(removed);\n    this.setExpanded(added);\n  }\n\n  /**\n   * 批量设置展开节点\n   * - 注意这个状态设置操作会忽略互斥属性\n   * @param {string[]} list 目标节点值数组\n   * @return void\n   */\n  public setExpanded(list: TreeNodeValue[]): void {\n    this.setExpandedDirectly(list);\n    this.updateExpanded(list);\n  }\n\n  /**\n   * 直接设置节点展开状态\n   * - 注意这个状态设置操作会忽略互斥属性\n   * @param {string[]} list 目标节点值数组\n   * @param {boolean} [expanded=true] 展开状态\n   * @return void\n   */\n  public setExpandedDirectly(list: TreeNodeValue[], expanded = true): void {\n    list.forEach((val) => {\n      if (expanded) {\n        this.expandedMap.set(val, true);\n      } else {\n        this.expandedMap.delete(val);\n      }\n      const node = this.getNode(val);\n      if (node) {\n        node.afterExpanded();\n      }\n    });\n  }\n\n  /**\n   * 清除所有节点的展开状态\n   * @return void\n   */\n  public resetExpanded(): void {\n    const expanded = this.getExpanded();\n    this.expandedMap.clear();\n    this.updateExpanded(expanded);\n  }\n\n  /**\n   * 更新展开节点相关节点的状态\n   * - 节点展开状态变更后，上下游节点可能存在状态变更，统一纳入待更新队列\n   * @param {string[]} list 目标节点值数组\n   * @return void\n   */\n  public updateExpanded(list: TreeNodeValue[]): void {\n    const relatedNodes = this.getRelatedNodes(list, {\n      withParents: false,\n    });\n    relatedNodes.forEach((node) => {\n      node.update();\n    });\n  }\n\n  /**\n   * 获取选中态节点值数组\n   * @param {Map} [map] 预设选中节点 map, 用于受控操作时预先获取结果而不直接操作节点状态\n   * @return string[] 选中态节点 value 数组\n   */\n  public getChecked(map?: TypeIdMap): TreeNodeValue[] {\n    const { nodeMap, config } = this;\n    const { valueMode, checkStrictly } = config;\n    const list: TreeNodeValue[] = [];\n    const checkedMap = map || this.checkedMap;\n    nodeMap.forEach((node) => {\n      // 判断未选中，直接忽略\n      if (!node.isChecked(checkedMap)) return;\n      if (valueMode === 'parentFirst' && !checkStrictly) {\n        // valueMode 为 parentFirst\n        // 仅取值父节点\n        if (!node.parent || !node.parent.isChecked(checkedMap)) {\n          list.push(node.value);\n        }\n      } else if (valueMode === 'onlyLeaf' && !checkStrictly) {\n        // valueMode 为 onlyLeaf\n        // 仅取值叶子节点\n        if (node.isLeaf()) {\n          list.push(node.value);\n        }\n      } else {\n        // valueMode 为 all\n        // 取值所有选中节点\n        list.push(node.value);\n      }\n    });\n    return list;\n  }\n\n  /**\n   * 获取指定节点下的选中节点\n   * @param {string | TreeNode} [item] 目标节点值，或者目标节点\n   * @return TreeNode[] 选中节点数组\n   */\n  public getCheckedNodes(item?: TypeTargetNode): TreeNode[] {\n    let nodes = this.getNodes(item);\n    nodes = nodes.filter((node) => node.isChecked());\n    return nodes;\n  }\n\n  /**\n   * 替换选中态列表\n   * @param {string[]} list 目标节点值数组\n   * @return void\n   */\n  public replaceChecked(list: TreeNodeValue[]): void {\n    this.resetChecked();\n    this.setChecked(list);\n  }\n\n  /**\n   * 批量设置选中态\n   * @param {string[]} list 目标节点值数组\n   * @return void\n   */\n  public setChecked(list: TreeNodeValue[]): void {\n    const { checkStrictly, checkable } = this.config;\n    if (!checkable) return;\n    list.forEach((val: TreeNodeValue) => {\n      const node = this.getNode(val);\n      if (!node) return;\n      if (checkStrictly) {\n        this.checkedMap.set(val, true);\n        node.updateChecked();\n      } else {\n        const childrenNodes = node.walk();\n        childrenNodes.forEach((childNode) => {\n          this.checkedMap.set(childNode.value, true);\n        });\n      }\n    });\n    if (!checkStrictly) {\n      const checkedValues = this.getChecked();\n      const relatedNodes = this.getRelatedNodes(checkedValues);\n      relatedNodes.forEach((node) => {\n        node.updateChecked();\n      });\n    }\n  }\n\n  /**\n   * 清除所有节点选中态\n   * @return void\n   */\n  public resetChecked(): void {\n    const checked = this.getChecked();\n    const relatedNodes = this.getRelatedNodes(checked);\n    this.checkedMap.clear();\n    relatedNodes.forEach((node) => {\n      node.updateChecked();\n    });\n  }\n\n  /**\n   * 更新所有树节点状态，但不更新选中态\n   * 用于不影响选中态时候的更新，减少递归循环造成的时间消耗\n   * @return void\n   */\n  public refreshState(): void {\n    const { nodeMap } = this;\n    // 树在初始化未回流时，nodes 数组为空\n    // 所以遍历 nodeMap 确保初始化阶段 refreshState 方法也可以触发全部节点的更新\n    nodeMap.forEach((node) => {\n      node.update();\n    });\n  }\n\n  /**\n   * 更新全部节点状态\n   * @return void\n   */\n  public updateAll(): void {\n    const { nodeMap } = this;\n    nodeMap.forEach((node) => {\n      node.update();\n      node.updateChecked();\n    });\n  }\n\n  /**\n   * 移除指定节点\n   * @param {string} value 目标节点值\n   * @return void\n   */\n  public remove(value?: TypeTargetNode): void {\n    const node = this.getNode(value);\n    if (node) {\n      node.remove();\n    }\n  }\n\n  /**\n   * 移除所有节点\n   * @return void\n   */\n  public removeAll(): void {\n    this.expandedMap.clear();\n    this.checkedMap.clear();\n    this.activedMap.clear();\n    this.filterMap.clear();\n    this.nodeMap.clear();\n    this.privateMap.clear();\n    this.updatedMap.clear();\n    this.nodes = [];\n    this.children = [];\n    this.reflow();\n  }\n\n  /**\n   * 获取节点状态变化可能影响的关联节点\n   * - 用于实现最小遍历集合\n   * @param {string[]} list 目标节点值数组\n   * @param {object} [options] 操作选项\n   * @oaran {boolean} [options.reverse=false] 倒序排列遍历节点\n   * @param {boolean} [options.withParents=true] 包含所有父节点\n   * @return TreeNode[] 关联节点数组\n   */\n  public getRelatedNodes(\n    list: TreeNodeValue[],\n    options?: TypeRelatedNodesOptions,\n  ): TreeNode[] {\n    const conf = {\n      // 默认倒序排列，从底层节点开始遍历\n      reverse: false,\n      // 默认遍历父节点\n      withParents: true,\n      ...options,\n    };\n    const map = new Map();\n    list.forEach((value) => {\n      if (map.get(value)) return;\n      const node = this.getNode(value);\n      if (node) {\n        const parents = node.getParents().reverse();\n        const children = node.walk();\n        let related = [];\n        if (conf.withParents) {\n          related = parents.concat(children);\n        } else {\n          related = children;\n        }\n        // 用 map 实现节点去重\n        related.forEach((relatedNode) => {\n          map.set(relatedNode.value, relatedNode);\n        });\n      }\n    });\n    let relatedNodes = Array.from(map.values());\n    if (conf.reverse) {\n      relatedNodes = relatedNodes.reverse();\n    }\n    return relatedNodes;\n  }\n\n  /**\n   * 触发绑定的事件\n   * - store.emitter 可以绑定事件回调，用于多个组件共同监听事件\n   * @param {string} name 事件名称\n   * @param {Event} [state] 事件对象\n   * @param {TreeNode} [state.node] 事件关联节点\n   * @param {TreeNode[]} [state.nodes] 事件关联节点数组\n   * @param {Map} [state.map] 事件关联节点映射\n   * @param {object[]} [state.data] 事件关联节点数据\n   * @return void\n   */\n  public emit(name: string, state?: TypeTreeEventState): void {\n    const { config, emitter } = this;\n    const methodName = camelCase(`on-${name}`);\n    const method = config[methodName];\n    if (isFunction(method)) {\n      method(state);\n    }\n    emitter.emit(name, state);\n  }\n\n  /**\n   * 锁定过滤节点的路径节点\n   * - 使得路径节点自动展开\n   * @return void\n   */\n  private lockFilterPathNodes(): void {\n    const { config } = this;\n    const allNodes = this.getNodes();\n\n    if (this.prevFilter) {\n      // 过滤条件清空时，也需要清理锁定节点\n      // 所在判断过滤条件是否存在之前，就要调用这里的清理逻辑\n      // 不想在每次渲染时都做这个清空判断\n      // 所以判断一下之前是否有进行过滤\n      allNodes.forEach((node: TreeNode) => {\n        // 先清空所有锁定状态\n        if (node.vmIsLocked) {\n          // lock 方法内部有状态计算\n          // 所以要减少 lock 方法调用次数\n          node.lock(false);\n        }\n      });\n    }\n\n    const currentFilter = config.filter;\n    // 当前没有过滤器\n    // 则无需处理锁定节点\n    if (!currentFilter || !isFunction(currentFilter)) return;\n    this.prevFilter = config.filter;\n\n    // 全部节点要经过排序，才能使用这个遍历\n    // 比起每个过滤节点调用 getParents 方法检查父节点状态\n    // 复杂度 O(N*log(N)) => O(N)\n    allNodes.reverse().forEach((node: TreeNode) => {\n      // 数组颠倒后，等于是从每个节点的子节点开始判断\n      // 想象为从展开树的最底部向上遍历\n      const parent = node.getParent();\n      if (!parent) return;\n      if (node.vmIsRest || node.vmIsLocked) {\n        // 当前节点被过滤条件命中\n        // 或者当前节点被锁定\n        // 则需要判定父节点状态\n        if (!parent.vmIsLocked) {\n          // 父节点已被锁定，则忽略动作\n          // lock 方法有内置状态判断\n          parent.lock(true);\n        }\n      }\n    });\n  }\n}\n\nexport default TreeStore;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA,SAASA,SAASC,EAA+B;EACzC,IAAAC,EAAA,GAAKC,OAAA,CAAQC,OAAQ;EAC3BF,EAAA,CAAGG,IAAA,CAAKJ,EAAE;EACH,OAAAC,EAAA;AACT;AAqCO,IAAMI,SAAU;EA8Cd,SAAAA,UAAYC,OAA+B;IAAAC,eAAA,OAAAF,SAAA;IAAAG,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAChD,IAAMC,MAA+B,GAAAC,aAAA;MACnCC,MAAQ;MACRC,IAAA,EAAM,EAAC;MACPC,SAAW;MACXC,WAAa;MACbC,WAAa;MACbC,YAAc;MACdC,SAAW;MACXC,cAAgB;MAChBC,SAAW;MACXC,aAAe;MACfC,QAAU;MACVC,YAAc;MACdC,SAAW;MACXC,IAAM;MACNC,IAAM;MACNC,SAAW;MACXC,MAAQ;MAIRC,qBAAuB;MACvBC,MAAQ;MACRC,QAAU;MACVC,QAAU;IAAA,GACPzB,OAAA,CACL;IACA,KAAKG,MAAS,GAAAA,MAAA;IACd,KAAKuB,KAAA,GAAQ,EAAC;IACd,KAAKC,QAAA,GAAW,EAAC;IACZ,KAAAC,OAAA,sBAAcC,GAAI;IAClB,KAAAC,UAAA,sBAAiBD,GAAI;IACrB,KAAAE,UAAA,sBAAiBF,GAAI;IACrB,KAAAG,WAAA,sBAAkBH,GAAI;IACtB,KAAAI,UAAA,sBAAiBJ,GAAI;IACrB,KAAAK,UAAA,sBAAiBL,GAAI;IACrB,KAAAM,SAAA,sBAAgBN,GAAI;IACzB,KAAKO,UAAa;IAElB,KAAKC,UAAa;IAElB,KAAKC,YAAe;IAEf,KAAAC,SAAA,GAAYC,YAAW,CAAArC,MAAA,CAAOkB,MAAM;IACzC,KAAKoB,OAAA,GAAUC,IAAK;EACtB;EAAA,OAAAC,YAAA,CAAA5C,SAAA;IAAA6C,GAAA;IAAAC,KAAA,EAOO,SAAAC,UAAU9C,OAA+B;MACxC,IAAEG,MAAA,GAAW,KAAXA,MAAA;MACR,IAAI4C,UAAa;MACjBC,MAAA,CAAO1C,IAAK,CAAAN,OAAO,CAAE,CAAAiD,OAAA,CAAQ,UAACL,GAAQ;QACpC,IAAMM,GAAA,GAAMlD,OAAQ,CAAA4C,GAAA;QAChB,IAAAM,GAAA,KAAQ/C,MAAA,CAAOyC,GAAM;UACVG,UAAA;UACb5C,MAAA,CAAOyC,GAAO,IAAAM,GAAA;QAChB;MACF,CAAC;MACI,KAAAX,SAAA,GAAYC,YAAW,CAAArC,MAAA,CAAOkB,MAAM;MACzC,IAAI0B,UAAY;QAKd,KAAKI,YAAa;MACpB;IACF;EAAA;IAAAP,GAAA;IAAAC,KAAA,EAMO,SAAAO,WAA0BA,CAAA;MAC/B,OAAO,IAAK,CAAAzB,QAAA;IACd;EAAA;IAAAiB,GAAA;IAAAC,KAAA,EAOO,SAAAQ,QAAQC,IAAgC;MAC7C,IAAIC,IAAO;MACX,IAAIC,UAAS,CAAAF,IAAI,CAAK,IAAAG,UAAA,CAASH,IAAI,CAAG;QAC7BC,IAAA,QAAK3B,OAAQ,CAAA8B,GAAA,CAAIJ,IAAI;MAC9B,WAAWA,IAAA,YAAgBK,QAAU;QACnCJ,IAAA,GAAO,IAAK,CAAA3B,OAAA,CAAQ8B,GAAI,CAAAJ,IAAA,CAAKT,KAAK;MACpC;MACA,IAAI,CAACU,IAAA,EAAaA,IAAA;MACX,OAAAA,IAAA;IACT;EAAA;IAAAX,GAAA;IAAAC,KAAA,EAOO,SAAAe,SAASL,IAAwB;MAC/B,YAAK7B,KAAM,CAAAmC,OAAA,CAAQN,IAAI;IAChC;EAAA;IAAAX,GAAA;IAAAC,KAAA,EAOO,SAAAiB,UAAUjB,KAAiC;MAChD,IAAIkB,MAAS;MACP,IAAAR,IAAA,GAAO,IAAK,CAAAF,OAAA,CAAQR,KAAK;MAC/B,IAAIU,IAAM;QACRQ,MAAA,GAASR,IAAA,CAAKO,SAAU;MAC1B;MACO,OAAAC,MAAA;IACT;EAAA;IAAAnB,GAAA;IAAAC,KAAA,EAOO,SAAAmB,WAAWnB,KAAmC;MAC7C,IAAAU,IAAA,GAAO,IAAK,CAAAF,OAAA,CAAQR,KAAK;MAC/B,IAAIoB,OAAA,GAAsB,EAAC;MAC3B,IAAIV,IAAM;QACRU,OAAA,GAAUV,IAAA,CAAKS,UAAW;MAC5B;MACO,OAAAC,OAAA;IACT;EAAA;IAAArB,GAAA;IAAAC,KAAA,EAOO,SAAAqB,aAAarB,KAA+B;MAC3C,IAAAU,IAAA,GAAO,IAAK,CAAAF,OAAA,CAAQR,KAAK;MAC/B,IAAIsB,KAAQ;MACZ,IAAIZ,IAAM;QACRY,KAAA,GAAQZ,IAAA,CAAKK,QAAS;MACxB;MACO,OAAAO,KAAA;IACT;EAAA;IAAAvB,GAAA;IAAAC,KAAA,EAuBO,SAAAuB,SACLd,IAAA,EACAtD,OACY;MACZ,IAAI0B,KAAA,GAAoB,EAAC;MACzB,IAAIwB,GAAqB;MACzB,IAAIM,UAAS,CAAAF,IAAI,CAAK,IAAAG,UAAA,CAASH,IAAI,CAAG;QAC9BJ,GAAA,GAAAI,IAAA;MACR,WAAWA,IAAA,YAAgBK,QAAU;QACnCT,GAAA,GAAMI,IAAK,CAAAT,KAAA;MACb;MACI,KAACK,GAAO,IAAAA,GAAA,KAAQ,CAAG;QACbxB,KAAA,QAAKA,KAAM,CAAA2C,KAAA,CAAM,CAAC;MAC5B,CAAO;QACC,IAAAd,IAAA,GAAO,IAAK,CAAAF,OAAA,CAAQH,GAAG;QAC7B,IAAIK,IAAM;UACR7B,KAAA,GAAQ6B,IAAA,CAAKe,IAAK;QACpB;MACF;MAEA,IAAItE,OAAS;QACX,IAAMuE,IAA8B,GAAAnE,aAAA;UAClCiB,MAAQ;UACRmD,KAAO,EAAAC;QAAA,GACJzE,OAAA,CACL;QACA,IAAIyD,UAAA,CAASc,IAAK,CAAAC,KAAK,CAAK,IAAAD,IAAA,CAAKC,KAAA,KAAUC,QAAU;UACnD/C,KAAA,GAAQA,KAAA,CAAML,MAAO,WAACkC,IAAA;mBAASA,IAAK,CAAAiB,KAAA,IAASD,IAAA,CAAKC,KAAK;WAAA;QACzD;QACI,IAAAhC,YAAA,CAAW+B,IAAK,CAAAlD,MAAM,CAAG;UACnBK,KAAA,GAAAA,KAAA,CAAML,MAAO,WAACkC,IAAS;YACvB,IAAAmB,SAAA,GAAYnB,IAAA,CAAKoB,QAAS;YACzB,OAAAJ,IAAA,CAAKlD,MAAA,CAAOqD,SAAS;UAC9B,CAAC;QACH;QACI,IAAAE,eAAA,CAAcL,IAAK,CAAAM,KAAK,CAAG;UACrBnD,KAAA,GAAAA,KAAA,CAAML,MAAO,WAACkC,IAAS;YACvB,IAAAuB,MAAA,GAAS9B,MAAA,CAAO1C,IAAK,CAAAiE,IAAA,CAAKM,KAAK,CAAE,CAAAE,KAAA,CAAM,UAACnC,GAAQ;cACpD,IAAMoC,SAAY,GAAAzB,IAAA,CAAKX,GAAS,MAAA2B,IAAA,CAAKM,KAAM,CAAAjC,GAAA;cACpC,OAAAoC,SAAA;YACT,CAAC;YACM,OAAAF,MAAA;UACT,CAAC;QACH;MACF;MACO,OAAApD,KAAA;IACT;EAAA;IAAAkB,GAAA;IAAAC,KAAA,EAOO,SAAAoC,OAAOC,IAAgC;MAAA,IAAAC,KAAA;MACvCD,IAAA,CAAAjC,OAAA,CAAQ,UAACK,IAAS;QACrB,IAAMC,IAAO,OAAII,QAAS,CAAAwB,KAAA,EAAM7B,IAAI;QAC/B6B,KAAA,CAAAxD,QAAA,CAASyD,IAAA,CAAK7B,IAAI;MACzB,CAAC;MACD,KAAK8B,MAAO;IACd;EAAA;IAAAzC,GAAA;IAAAC,KAAA,EAOO,SAAAyC,OAAOJ,IAAgC;MAC5C,KAAKK,SAAU;MACf,KAAKN,MAAA,CAAOC,IAAI;IAClB;EAAA;IAAAtC,GAAA;IAAAC,KAAA,EAUQ,SAAA2C,cACNC,IAAA,EACAnC,IACA;MACA,IAAIT,KAAuB;MAC3B,IAAIU,IAAO;MACX,IAAImC,IAAO;MAEX,IAAIlC,UAAS,CAAAiC,IAAI,CAAK,IAAAhC,UAAA,CAASgC,IAAI,CAAG;QAC5B5C,KAAA,GAAA4C,IAAA;QACDlC,IAAA,QAAKF,OAAA,CAAQR,KAAK;QAClB6C,IAAA,GAAApC,IAAA;MACT,WAAWmC,IAAA,YAAgB9B,QAAU;QACnC,IAAIL,IAAM;UACDC,IAAA,GAAAkC,IAAA;UACAC,IAAA,GAAApC,IAAA;QACT,CAAO;UACEoC,IAAA,GAAAD,IAAA;QACT;MACF,CAAO;QACEC,IAAA,GAAAD,IAAA;MACT;MACA,IAAME,IAAO;QACXpC,IAAA,EAAAA,IAAA;QACAmC,IAAA,EAAAA;OACF;MACO,OAAAC,IAAA;IACT;EAAA;IAAA/C,GAAA;IAAAC,KAAA,EAgBO,SAAA+C,YACLH,IAAA,EACAnC,IACM;MACN,IAAMqC,IAAO,QAAKH,aAAc,CAAAC,IAAA,EAAMnC,IAAI;MAC1C,IAAIqC,IAAA,CAAKD,IAAM;QACT,KAACC,IAAA,CAAKpC,IAAM;UAEV,IAAAoC,IAAA,CAAKD,IAAA,YAAgB/B,QAAU;YAC5BgC,IAAA,CAAAD,IAAA,CAAKG,QAAA,CAAS,IAAI;WACd,UAAAC,KAAA,CAAMC,OAAQ,CAAAJ,IAAA,CAAKD,IAAI,CAAG;YAC9B,KAAAT,MAAA,CAAOU,IAAA,CAAKD,IAAI;UACvB,CAAO;YACL,KAAKT,MAAO,EAACU,IAAK,CAAAD,IAAI,CAAC;UACzB;QACF,CAAO;UAED,IAAAC,IAAA,CAAKD,IAAA,YAAgB/B,QAAU;YACjCgC,IAAA,CAAKD,IAAK,CAAAG,QAAA,CAAS,IAAM,EAAAF,IAAA,CAAKpC,IAAI;WACzB,UAAAyC,SAAA,CAAQL,IAAK,CAAAD,IAAI,CAAG;YACxBC,IAAA,CAAApC,IAAA,CAAK0B,MAAO,CAAAU,IAAA,CAAKD,IAAI;UAC5B,CAAO;YACLC,IAAA,CAAKpC,IAAK,CAAA0B,MAAA,CAAO,CAACU,IAAA,CAAKD,IAAI,CAAC;UAC9B;UACAC,IAAA,CAAKpC,IAAA,CAAK0C,aAAc;QAC1B;MACF;IACF;EAAA;IAAArD,GAAA;IAAAC,KAAA,EAQO,SAAAqD,aAAarD,KAAA,EAAuBS,IAA0B;MAC7D,IAAAC,IAAA,GAAO,IAAK,CAAAF,OAAA,CAAQR,KAAK;MAC/B,IAAIU,IAAM;QACRA,IAAA,CAAK2C,YAAA,CAAa5C,IAAI;MACxB;IACF;EAAA;IAAAV,GAAA;IAAAC,KAAA,EAQO,SAAAsD,YAAYtD,KAAA,EAAuBS,IAA0B;MAC5D,IAAAC,IAAA,GAAO,IAAK,CAAAF,OAAA,CAAQR,KAAK;MAC/B,IAAIU,IAAM;QACRA,IAAA,CAAK4C,WAAA,CAAY7C,IAAI;MACvB;IACF;EAAA;IAAAV,GAAA;IAAAC,KAAA,EAQO,SAAAuD,YAAqBA,CAAA;MACpB,IAAEzE,QAAU,GAAU,KAApBA,QAAU;QAAAD,KAAA,GAAU,KAAVA,KAAA;MAClBA,KAAA,CAAM2E,MAAS;MACN1E,QAAA,CAAAsB,OAAA,CAAQ,UAACM,IAAS;QACnB,IAAA2B,IAAA,GAAO3B,IAAA,CAAKe,IAAK;QACvBwB,KAAA,CAAMQ,SAAU,CAAAlB,IAAA,CAAKmB,KAAM,CAAA7E,KAAA,EAAOwD,IAAI;MACxC,CAAC;IACH;EAAA;IAAAtC,GAAA;IAAAC,KAAA,EASO,SAAAwC,OAAO9B,IAAuB;MACnC,KAAKjB,YAAe;MACpB,KAAKkE,OAAA,CAAQjD,IAAI;IACnB;EAAA;IAAAX,GAAA;IAAAC,KAAA,EAUO,SAAA2D,QAAQjD,IAAuB;MAAA,IAAAkD,MAAA;MAC9B,IAAEvE,UAAA,GAAe,KAAfA,UAAA;MACR,IAAIqB,IAAM;QAEGrB,UAAA,CAAAwE,GAAA,CAAInD,IAAK,CAAAoD,UAAA,GAAa,SAAS;MAC5C,CAAO;QAEL,KAAKvC,QAAS,GAAEnB,OAAQ,WAAC2D,QAAa;UACzB1E,UAAA,CAAAwE,GAAA,CAAIE,QAAS,CAAAD,UAAA,GAAa,SAAS;QAChD,CAAC;MACH;MAEA,IAAI,IAAK,CAAAtE,UAAA,EAAY;MAChB,KAAAA,UAAA,GAAa5C,QAAA,CAAS,YAAM;QAC/BgH,MAAA,CAAKpE,UAAa;QAGlB,IAAIoE,MAAA,CAAKnE,YAAc;UACrBmE,MAAA,CAAKL,YAAa;UAClBK,MAAA,CAAKI,IAAA,CAAK,QAAQ;QACpB;QAKAJ,MAAA,CAAKK,mBAAoB;QAGzB,IAAMC,OAAU,OAAAC,MAAA,CAAI,IAAIC,IAAA,GAAOC,OAAQ;QACvC,IAAMC,WAAc,GAAArB,KAAA,CAAMsB,IAAK,CAAAlF,UAAA,CAAW5B,IAAA,EAAM;QAChD,IAAM+G,YAAe,GAAAF,WAAA,CAAYG,GAAI,WAACC,cAAmB;UAC5CrF,UAAA,CAAAwE,GAAA,CAAIa,cAAA,EAAgBR,OAAO;UAC/B,OAAAN,MAAA,CAAK3E,UAAW,CAAA4B,GAAA,CAAI6D,cAAc;QAC3C,CAAC;QAGDd,MAAA,CAAKI,IAAA,CAAK,QAAU;UAClBnF,KAAO,EAAA2F,YAAA;UACPC,GAAK,EAAApF;QACP,CAAC;QAGDuE,MAAA,CAAKnE,YAAe;QACpBJ,UAAA,CAAWsF,KAAM;MACnB,CAAC;IACH;EAAA;IAAA5E,GAAA;IAAAC,KAAA,EAOO,SAAA4E,WAAWH,GAAkC;MAC5C,IAAAvF,UAAA,GAAauF,GAAA,IAAO,IAAK,CAAAvF,UAAA;MAC/B,OAAO+D,KAAM,CAAAsB,IAAA,CAAKrF,UAAW,CAAAzB,IAAA,EAAM;IACrC;EAAA;IAAAsC,GAAA;IAAAC,KAAA,EAQO,SAAA6E,gBAAgBpE,IAAmC;MACpD,IAAA5B,KAAA,GAAQ,IAAK,CAAA0C,QAAA,CAASd,IAAI;MAC9B5B,KAAA,GAAQA,KAAA,CAAML,MAAO,WAACkC,IAAS;QAAA,OAAAA,IAAA,CAAKoE,SAAA,EAAW;OAAA;MACxC,OAAAjG,KAAA;IACT;EAAA;IAAAkB,GAAA;IAAAC,KAAA,EAOO,SAAA+E,eAAe1C,IAA6B;MACjD,KAAK2C,YAAa;MAClB,KAAKC,UAAA,CAAW5C,IAAI;IACtB;EAAA;IAAAtC,GAAA;IAAAC,KAAA,EAOO,SAAAiF,WAAWC,OAAgC;MAAA,IAAAC,MAAA;MAC1C,IAAEpH,cAAe,GAAI,IAAK,CAAAT,MAAA,CAAxBS,cAAe;MACjB,IAAAsE,IAAA,GAAO6C,OAAQ,CAAA1D,KAAA,CAAM,CAAC;MAC5B,IAAI,CAACzD,cAAgB;QACnBsE,IAAA,CAAKmB,MAAS;MAChB;MACKnB,IAAA,CAAAjC,OAAA,CAAQ,UAACC,GAAQ;QACf8E,MAAA,CAAAjG,UAAA,CAAW2E,GAAI,CAAAxD,GAAA,EAAK,IAAI;QACvB,IAAAK,IAAA,GAAOyE,MAAK,CAAA3E,OAAA,CAAQH,GAAG;QAC7B,IAAIK,IAAM;UACRA,IAAA,CAAK0E,MAAO;QACd;MACF,CAAC;IACH;EAAA;IAAArF,GAAA;IAAAC,KAAA,EAMO,SAAAgF,YAAqBA,CAAA;MACpB,IAAAE,OAAA,GAAU,KAAKN,UAAW;MAChC,KAAK1F,UAAA,CAAWyF,KAAM;MAChB,IAAAU,YAAA,GAAe,IAAK,CAAAC,eAAA,CAAgBJ,OAAO;MACpCG,YAAA,CAAAjF,OAAA,CAAQ,UAACM,IAAS;QAC7BA,IAAA,CAAK0E,MAAO;MACd,CAAC;IACH;EAAA;IAAArF,GAAA;IAAAC,KAAA,EAOO,SAAAuF,YAAYd,GAAkC;MAC7C,IAAAtF,WAAA,GAAcsF,GAAA,IAAO,IAAK,CAAAtF,WAAA;MAChC,OAAO8D,KAAM,CAAAsB,IAAA,CAAKpF,WAAY,CAAA1B,IAAA,EAAM;IACtC;EAAA;IAAAsC,GAAA;IAAAC,KAAA,EAOO,SAAAwF,gBAAgBnD,IAA6B;MAC5C,IAAAoD,QAAA,GAAW,KAAKF,WAAY;MAC5B,IAAAG,KAAA,GAAQC,YAAW,CAAAtD,IAAA,EAAMoD,QAAQ;MACjC,IAAAG,OAAA,GAAUD,YAAW,CAAAF,QAAA,EAAUpD,IAAI;MACpC,KAAAwD,mBAAA,CAAoBD,OAAA,EAAS,KAAK;MACvC,KAAKE,cAAA,CAAeF,OAAO;MAC3B,KAAKG,WAAA,CAAYL,KAAK;IACxB;EAAA;IAAA3F,GAAA;IAAAC,KAAA,EAQO,SAAA+F,YAAY1D,IAA6B;MAC9C,KAAKwD,mBAAA,CAAoBxD,IAAI;MAC7B,KAAKyD,cAAA,CAAezD,IAAI;IAC1B;EAAA;IAAAtC,GAAA;IAAAC,KAAA,EASO,SAAA6F,oBAAoBxD,IAAuB,EAAuB;MAAA,IAAA2D,MAAA;MAAA,IAAvBP,QAAA,GAAAQ,SAAA,CAAAzC,MAAA,QAAAyC,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAW,IAAY;MAClE5D,IAAA,CAAAjC,OAAA,CAAQ,UAACC,GAAQ;QACpB,IAAIoF,QAAU;UACPO,MAAA,CAAA7G,WAAA,CAAY0E,GAAI,CAAAxD,GAAA,EAAK,IAAI;QAChC,CAAO;UACA2F,MAAA,CAAA7G,WAAA,WAAmBkB,GAAG;QAC7B;QACM,IAAAK,IAAA,GAAOsF,MAAK,CAAAxF,OAAA,CAAQH,GAAG;QAC7B,IAAIK,IAAM;UACRA,IAAA,CAAKyF,aAAc;QACrB;MACF,CAAC;IACH;EAAA;IAAApG,GAAA;IAAAC,KAAA,EAMO,SAAAoG,aAAsBA,CAAA;MACrB,IAAAX,QAAA,GAAW,KAAKF,WAAY;MAClC,KAAKpG,WAAA,CAAYwF,KAAM;MACvB,KAAKmB,cAAA,CAAeL,QAAQ;IAC9B;EAAA;IAAA1F,GAAA;IAAAC,KAAA,EAQO,SAAA8F,eAAezD,IAA6B;MAC3C,IAAAgD,YAAA,GAAe,IAAK,CAAAC,eAAA,CAAgBjD,IAAM;QAC9CgE,WAAa;MACf,CAAC;MACYhB,YAAA,CAAAjF,OAAA,CAAQ,UAACM,IAAS;QAC7BA,IAAA,CAAK0E,MAAO;MACd,CAAC;IACH;EAAA;IAAArF,GAAA;IAAAC,KAAA,EAOO,SAAAsG,WAAW7B,GAAkC;MAC5C,IAAE1F,OAAS,GAAW,KAApBA,OAAS;QAAAzB,MAAA,GAAW,KAAXA,MAAA;MACX,IAAEiB,SAAW,GAAkBjB,MAAA,CAA7BiB,SAAW;QAAAN,aAAA,GAAkBX,MAAA,CAAlBW,aAAA;MACnB,IAAMoE,IAAA,GAAwB,EAAC;MACzB,IAAAjD,UAAA,GAAaqF,GAAA,IAAO,IAAK,CAAArF,UAAA;MACvBL,OAAA,CAAAqB,OAAA,CAAQ,UAACM,IAAS;QAEpB,KAACA,IAAK,CAAA6F,SAAA,CAAUnH,UAAU,GAAG;QAC7B,IAAAb,SAAA,KAAc,aAAiB,KAACN,aAAe;UAG7C,KAACyC,IAAA,CAAKQ,MAAU,KAACR,IAAA,CAAKQ,MAAO,CAAAqF,SAAA,CAAUnH,UAAU,CAAG;YACjDiD,IAAA,CAAAE,IAAA,CAAK7B,IAAA,CAAKV,KAAK;UACtB;SACS,UAAAzB,SAAA,KAAc,UAAc,KAACN,aAAe;UAGjD,IAAAyC,IAAA,CAAK8F,MAAA,EAAU;YACZnE,IAAA,CAAAE,IAAA,CAAK7B,IAAA,CAAKV,KAAK;UACtB;QACF,CAAO;UAGAqC,IAAA,CAAAE,IAAA,CAAK7B,IAAA,CAAKV,KAAK;QACtB;MACF,CAAC;MACM,OAAAqC,IAAA;IACT;EAAA;IAAAtC,GAAA;IAAAC,KAAA,EAOO,SAAAyG,gBAAgBhG,IAAmC;MACpD,IAAA5B,KAAA,GAAQ,IAAK,CAAA0C,QAAA,CAASd,IAAI;MAC9B5B,KAAA,GAAQA,KAAA,CAAML,MAAO,WAACkC,IAAS;QAAA,OAAAA,IAAA,CAAK6F,SAAA,EAAW;OAAA;MACxC,OAAA1H,KAAA;IACT;EAAA;IAAAkB,GAAA;IAAAC,KAAA,EAOO,SAAA0G,eAAerE,IAA6B;MACjD,KAAKsE,YAAa;MAClB,KAAKC,UAAA,CAAWvE,IAAI;IACtB;EAAA;IAAAtC,GAAA;IAAAC,KAAA,EAOO,SAAA4G,WAAWvE,IAA6B;MAAA,IAAAwE,MAAA;MAC7C,IAAAC,YAAA,GAAqC,IAAK,CAAAxJ,MAAA;QAAlCW,aAAA,GAAA6I,YAAA,CAAA7I,aAAA;QAAeD,SAAU,GAAA8I,YAAA,CAAV9I,SAAU;MACjC,IAAI,CAACA,SAAA,EAAW;MACXqE,IAAA,CAAAjC,OAAA,CAAQ,UAACC,GAAuB;QAC7B,IAAAK,IAAA,GAAOmG,MAAK,CAAArG,OAAA,CAAQH,GAAG;QAC7B,IAAI,CAACK,IAAA,EAAM;QACX,IAAIzC,aAAe;UACZ4I,MAAA,CAAAzH,UAAA,CAAWyE,GAAI,CAAAxD,GAAA,EAAK,IAAI;UAC7BK,IAAA,CAAKqG,aAAc;QACrB,CAAO;UACC,IAAAC,aAAA,GAAgBtG,IAAA,CAAKe,IAAK;UAClBuF,aAAA,CAAA5G,OAAA,CAAQ,UAAC6G,SAAc;YACnCJ,MAAA,CAAKzH,UAAW,CAAAyE,GAAA,CAAIoD,SAAU,CAAAjH,KAAA,EAAO,IAAI;UAC3C,CAAC;QACH;MACF,CAAC;MACD,IAAI,CAAC/B,aAAe;QACZ,IAAAiJ,aAAA,GAAgB,KAAKZ,UAAW;QAChC,IAAAjB,YAAA,GAAe,IAAK,CAAAC,eAAA,CAAgB4B,aAAa;QAC1C7B,YAAA,CAAAjF,OAAA,CAAQ,UAACM,IAAS;UAC7BA,IAAA,CAAKqG,aAAc;QACrB,CAAC;MACH;IACF;EAAA;IAAAhH,GAAA;IAAAC,KAAA,EAMO,SAAA2G,YAAqBA,CAAA;MACpB,IAAAQ,OAAA,GAAU,KAAKb,UAAW;MAC1B,IAAAjB,YAAA,GAAe,IAAK,CAAAC,eAAA,CAAgB6B,OAAO;MACjD,KAAK/H,UAAA,CAAWuF,KAAM;MACTU,YAAA,CAAAjF,OAAA,CAAQ,UAACM,IAAS;QAC7BA,IAAA,CAAKqG,aAAc;MACrB,CAAC;IACH;EAAA;IAAAhH,GAAA;IAAAC,KAAA,EAOO,SAAAM,YAAqBA,CAAA;MACpB,IAAEvB,OAAA,GAAY,KAAZA,OAAA;MAGAA,OAAA,CAAAqB,OAAA,CAAQ,UAACM,IAAS;QACxBA,IAAA,CAAK0E,MAAO;MACd,CAAC;IACH;EAAA;IAAArF,GAAA;IAAAC,KAAA,EAMO,SAAAoH,SAAkBA,CAAA;MACjB,IAAErI,OAAA,GAAY,KAAZA,OAAA;MACAA,OAAA,CAAAqB,OAAA,CAAQ,UAACM,IAAS;QACxBA,IAAA,CAAK0E,MAAO;QACZ1E,IAAA,CAAKqG,aAAc;MACrB,CAAC;IACH;EAAA;IAAAhH,GAAA;IAAAC,KAAA,EAOO,SAAAqH,OAAOrH,KAA8B;MACpC,IAAAU,IAAA,GAAO,IAAK,CAAAF,OAAA,CAAQR,KAAK;MAC/B,IAAIU,IAAM;QACRA,IAAA,CAAK2G,MAAO;MACd;IACF;EAAA;IAAAtH,GAAA;IAAAC,KAAA,EAMO,SAAA0C,SAAkBA,CAAA;MACvB,KAAKvD,WAAA,CAAYwF,KAAM;MACvB,KAAKvF,UAAA,CAAWuF,KAAM;MACtB,KAAKzF,UAAA,CAAWyF,KAAM;MACtB,KAAKrF,SAAA,CAAUqF,KAAM;MACrB,KAAK5F,OAAA,CAAQ4F,KAAM;MACnB,KAAK1F,UAAA,CAAW0F,KAAM;MACtB,KAAKtF,UAAA,CAAWsF,KAAM;MACtB,KAAK9F,KAAA,GAAQ,EAAC;MACd,KAAKC,QAAA,GAAW,EAAC;MACjB,KAAK0D,MAAO;IACd;EAAA;IAAAzC,GAAA;IAAAC,KAAA,EAWO,SAAAsF,gBACLjD,IAAA,EACAlF,OACY;MAAA,IAAAmK,MAAA;MACZ,IAAM5F,IAAO,GAAAnE,aAAA;QAEXgK,OAAS;QAETlB,WAAa;MAAA,GACVlJ,OAAA,CACL;MACM,IAAAsH,GAAA,sBAAUzF,GAAI;MACfqD,IAAA,CAAAjC,OAAA,CAAQ,UAACJ,KAAU;QAClB,IAAAyE,GAAA,CAAI5D,GAAA,CAAIb,KAAK,GAAG;QACd,IAAAU,IAAA,GAAO4G,MAAK,CAAA9G,OAAA,CAAQR,KAAK;QAC/B,IAAIU,IAAM;UACR,IAAMU,OAAU,GAAAV,IAAA,CAAKS,UAAW,GAAEoG,OAAQ;UACpC,IAAAzI,QAAA,GAAW4B,IAAA,CAAKe,IAAK;UAC3B,IAAI+F,OAAA,GAAU,EAAC;UACf,IAAI9F,IAAA,CAAK2E,WAAa;YACVmB,OAAA,GAAApG,OAAA,CAAQ+C,MAAA,CAAOrF,QAAQ;UACnC,CAAO;YACK0I,OAAA,GAAA1I,QAAA;UACZ;UAEQ0I,OAAA,CAAApH,OAAA,CAAQ,UAACqH,WAAgB;YAC3BhD,GAAA,CAAAZ,GAAA,CAAI4D,WAAY,CAAAzH,KAAA,EAAOyH,WAAW;UACxC,CAAC;QACH;MACF,CAAC;MACD,IAAIpC,YAAe,GAAApC,KAAA,CAAMsB,IAAK,CAAAE,GAAA,CAAIiD,MAAA,EAAQ;MAC1C,IAAIhG,IAAA,CAAK6F,OAAS;QAChBlC,YAAA,GAAeA,YAAA,CAAakC,OAAQ;MACtC;MACO,OAAAlC,YAAA;IACT;EAAA;IAAAtF,GAAA;IAAAC,KAAA,EAaO,SAAAgE,KAAK2D,IAAA,EAAcC,KAAkC;MACpD,IAAEtK,MAAQ,GAAY,KAApBA,MAAQ;QAAAsC,OAAA,GAAY,KAAZA,OAAA;MACV,IAAAiI,UAAA,GAAaC,WAAU,OAAA3D,MAAA,CAAMwD,IAAM;MACzC,IAAMI,MAAA,GAASzK,MAAO,CAAAuK,UAAA;MAClB,IAAAlI,YAAA,CAAWoI,MAAM,CAAG;QACtBA,MAAA,CAAOH,KAAK;MACd;MACQhI,OAAA,CAAAoE,IAAA,CAAK2D,IAAA,EAAMC,KAAK;IAC1B;EAAA;IAAA7H,GAAA;IAAAC,KAAA,EAOQ,SAAAiE,mBAA4BA,CAAA;MAC5B,IAAE3G,MAAA,GAAW,KAAXA,MAAA;MACF,IAAA0K,QAAA,GAAW,KAAKzG,QAAS;MAE/B,IAAI,KAAKhC,UAAY;QAKVyI,QAAA,CAAA5H,OAAA,CAAQ,UAACM,IAAmB;UAEnC,IAAIA,IAAA,CAAKuH,UAAY;YAGnBvH,IAAA,CAAKwH,IAAA,CAAK,KAAK;UACjB;QACF,CAAC;MACH;MAEA,IAAMC,aAAA,GAAgB7K,MAAO,CAAAkB,MAAA;MAG7B,IAAI,CAAC2J,aAAA,IAAiB,CAACxI,YAAA,CAAWwI,aAAa,GAAG;MAClD,KAAK5I,UAAA,GAAajC,MAAO,CAAAkB,MAAA;MAKzBwJ,QAAA,CAAST,OAAQ,GAAEnH,OAAQ,WAACM,IAAmB;QAGvC,IAAAQ,MAAA,GAASR,IAAA,CAAKO,SAAU;QAC9B,IAAI,CAACC,MAAA,EAAQ;QACT,IAAAR,IAAA,CAAK0H,QAAY,IAAA1H,IAAA,CAAKuH,UAAY;UAIhC,KAAC/G,MAAA,CAAO+G,UAAY;YAGtB/G,MAAA,CAAOgH,IAAA,CAAK,IAAI;UAClB;QACF;MACF,CAAC;IACH;EAAA;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}