{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\n/**\n * tdesign v1.10.5\n * (c) 2024 tdesign\n * @license MIT\n */\n\nimport { i as isString_1 } from '../../../_chunks/dep-03a7fb6c.mjs';\nimport { i as isNull_1 } from '../../../_chunks/dep-73384992.mjs';\nimport { t as tinycolor } from '../../../_chunks/dep-9ac991f3.mjs';\nimport '../../../_chunks/dep-eca422c3.mjs';\nimport '../../../_chunks/dep-bf7257e7.mjs';\nimport '../../../_chunks/dep-4659d73b.mjs';\nimport '../../../_chunks/dep-eae2a67e.mjs';\nimport '../../../_chunks/dep-626c497d.mjs';\nimport '../../../_chunks/dep-29ef8419.mjs';\nvar combineRegExp = function combineRegExp(regexpList, flags) {\n  var source = \"\";\n  for (var i = 0; i < regexpList.length; i++) {\n    if (isString_1(regexpList[i])) {\n      source += regexpList[i];\n    } else {\n      source += regexpList[i].source;\n    }\n  }\n  return new RegExp(source, flags);\n};\nvar generateRegExp = function generateRegExp() {\n  var searchFlags = \"gi\";\n  var rAngle = /(?:[+-]?\\d*\\.?\\d+)(?:deg|grad|rad|turn)/;\n  var rSideCornerCapture = /to\\s+((?:(?:left|right|top|bottom)(?:\\s+(?:top|bottom|left|right))?))/;\n  var rComma = /\\s*,\\s*/;\n  var rColorHex = /#(?:[a-f0-9]{6}|[a-f0-9]{3})/;\n  var rDigits3 = /\\(\\s*(?:\\d{1,3}\\s*,\\s*){2}\\d{1,3}\\s*\\)/;\n  var rDigits4 = /\\(\\s*(?:\\d{1,3}\\s*,\\s*){2}\\d{1,3}\\s*,\\s*\\d*\\.?\\d+\\)/;\n  var rValue = /(?:[+-]?\\d*\\.?\\d+)(?:%|[a-z]+)?/;\n  var rKeyword = /[_a-z-][_a-z0-9-]*/;\n  var rColor = combineRegExp([\"(?:\", rColorHex, \"|\", \"(?:rgb|hsl)\", rDigits3, \"|\", \"(?:rgba|hsla)\", rDigits4, \"|\", rKeyword, \")\"], \"\");\n  var rColorStop = combineRegExp([rColor, \"(?:\\\\s+\", rValue, \"(?:\\\\s+\", rValue, \")?)?\"], \"\");\n  var rColorStopList = combineRegExp([\"(?:\", rColorStop, rComma, \")*\", rColorStop], \"\");\n  var rLineCapture = combineRegExp([\"(?:(\", rAngle, \")|\", rSideCornerCapture, \")\"], \"\");\n  var rGradientSearch = combineRegExp([\"(?:(\", rLineCapture, \")\", rComma, \")?(\", rColorStopList, \")\"], searchFlags);\n  var rColorStopSearch = combineRegExp([\"\\\\s*(\", rColor, \")\", \"(?:\\\\s+\", \"(\", rValue, \"))?\", \"(?:\", rComma, \"\\\\s*)?\"], searchFlags);\n  return {\n    gradientSearch: rGradientSearch,\n    colorStopSearch: rColorStopSearch\n  };\n};\nvar parseGradient = function parseGradient(regExpLib, input) {\n  var result;\n  var matchColorStop;\n  var stopResult;\n  regExpLib.gradientSearch.lastIndex = 0;\n  var matchGradient = regExpLib.gradientSearch.exec(input);\n  if (!isNull_1(matchGradient)) {\n    result = {\n      original: matchGradient[0],\n      colorStopList: []\n    };\n    if (matchGradient[1]) {\n      result.line = matchGradient[1];\n    }\n    if (matchGradient[2]) {\n      result.angle = matchGradient[2];\n    }\n    if (matchGradient[3]) {\n      result.sideCorner = matchGradient[3];\n    }\n    regExpLib.colorStopSearch.lastIndex = 0;\n    matchColorStop = regExpLib.colorStopSearch.exec(matchGradient[4]);\n    while (!isNull_1(matchColorStop)) {\n      stopResult = {\n        color: matchColorStop[1]\n      };\n      if (matchColorStop[2]) {\n        stopResult.position = matchColorStop[2];\n      }\n      result.colorStopList.push(stopResult);\n      matchColorStop = regExpLib.colorStopSearch.exec(matchGradient[4]);\n    }\n  }\n  return result;\n};\nvar REGEXP_LIB = generateRegExp();\nvar REG_GRADIENT = /.*gradient\\s*\\(((?:\\([^)]*\\)|[^)(]*)*)\\)/gim;\nvar isGradientColor = function isGradientColor(input) {\n  REG_GRADIENT.lastIndex = 0;\n  return REG_GRADIENT.exec(input);\n};\nvar sideCornerDegreeMap = {\n  top: 0,\n  right: 90,\n  bottom: 180,\n  left: 270,\n  \"top left\": 225,\n  \"left top\": 225,\n  \"top right\": 135,\n  \"right top\": 135,\n  \"bottom left\": 315,\n  \"left bottom\": 315,\n  \"bottom right\": 45,\n  \"right bottom\": 45\n};\nvar parseGradientString = function parseGradientString(input) {\n  var match = isGradientColor(input);\n  if (!match) {\n    return false;\n  }\n  var gradientColors = {\n    points: [],\n    degree: 0\n  };\n  var result = parseGradient(REGEXP_LIB, match[1]);\n  if (result.original.trim() !== match[1].trim()) {\n    return false;\n  }\n  var points = result.colorStopList.map(function (_ref) {\n    var color = _ref.color,\n      position = _ref.position;\n    var point = /* @__PURE__ */Object.create(null);\n    point.color = tinycolor(color).toRgbString();\n    point.left = parseFloat(position);\n    return point;\n  });\n  gradientColors.points = points;\n  var degree = parseInt(result.angle, 10);\n  if (Number.isNaN(degree)) {\n    degree = sideCornerDegreeMap[result.sideCorner] || 90;\n  }\n  gradientColors.degree = degree;\n  return gradientColors;\n};\nexport { parseGradientString as default, isGradientColor, parseGradientString };","map":{"version":3,"names":["combineRegExp","regexpList","flags","source","i","length","isString_1","RegExp","generateRegExp","searchFlags","rAngle","rSideCornerCapture","rComma","rColorHex","rDigits3","rDigits4","rValue","rKeyword","rColor","rColorStop","rColorStopList","rLineCapture","rGradientSearch","rColorStopSearch","gradientSearch","colorStopSearch","parseGradient","regExpLib","input","result","matchColorStop","stopResult","lastIndex","matchGradient","exec","isNull_1","original","colorStopList","line","angle","sideCorner","color","position","push","REGEXP_LIB","REG_GRADIENT","isGradientColor","sideCornerDegreeMap","top","right","bottom","left","parseGradientString","match","gradientColors","points","degree","trim","map","_ref","point","Object","create","tinycolor","toRgbString","parseFloat","parseInt","Number","isNaN"],"sources":["../../../../src/_common/js/color-picker/gradient.ts"],"sourcesContent":["import isString from 'lodash/isString';\nimport isNull from 'lodash/isNull';\n/* eslint-disable no-param-reassign */\n/**\n * 用于反解析渐变字符串为对象\n * https://stackoverflow.com/questions/20215440/parse-css-gradient-rule-with-javascript-regex\n */\nimport tinyColor from 'tinycolor2';\n\n/**\n * Utility combine multiple regular expressions.\n *\n * @param {RegExp[]|string[]} regexpList List of regular expressions or strings.\n * @param {string} flags Normal RegExp flags.\n */\nconst combineRegExp = (regexpList: (string | RegExp)[], flags: string): RegExp => {\n  let source = '';\n  for (let i = 0; i < regexpList.length; i++) {\n    if (isString(regexpList[i])) {\n      source += regexpList[i];\n    } else {\n      source += (regexpList[i] as RegExp).source;\n    }\n  }\n  return new RegExp(source, flags);\n};\n\ninterface RegExpLib {\n  gradientSearch: RegExp;\n  colorStopSearch: RegExp;\n}\n\ninterface ColorStop {\n  color: string;\n  position?: string;\n}\n\ninterface ParseGradientResult {\n  original: string;\n  colorStopList?: ColorStop[];\n  line?: string;\n  angle?: string;\n  sideCorner?: string;\n}\n\n/**\n * Generate the required regular expressions once.\n *\n * Regular Expressions are easier to manage this way and can be well described.\n *\n * @result {object} Object containing regular expressions.\n */\nconst generateRegExp = (): RegExpLib => {\n  // Note any variables with \"Capture\" in name include capturing bracket set(s).\n  const searchFlags = 'gi'; // ignore case for angles, \"rgb\" etc\n  const rAngle = /(?:[+-]?\\d*\\.?\\d+)(?:deg|grad|rad|turn)/; // Angle +ive, -ive and angle types\n  // optional 2nd part\n  const rSideCornerCapture = /to\\s+((?:(?:left|right|top|bottom)(?:\\s+(?:top|bottom|left|right))?))/;\n  const rComma = /\\s*,\\s*/; // Allow space around comma.\n  const rColorHex = /#(?:[a-f0-9]{6}|[a-f0-9]{3})/; // 3 or 6 character form\n  const rDigits3 = /\\(\\s*(?:\\d{1,3}\\s*,\\s*){2}\\d{1,3}\\s*\\)/;\n  const // \"(1, 2, 3)\"\n    rDigits4 = /\\(\\s*(?:\\d{1,3}\\s*,\\s*){2}\\d{1,3}\\s*,\\s*\\d*\\.?\\d+\\)/;\n  const // \"(1, 2, 3, 4)\"\n    rValue = /(?:[+-]?\\d*\\.?\\d+)(?:%|[a-z]+)?/;\n  const // \".9\", \"-5px\", \"100%\".\n    rKeyword = /[_a-z-][_a-z0-9-]*/;\n  const // \"red\", \"transparent\".\n    rColor = combineRegExp(\n      ['(?:', rColorHex, '|', '(?:rgb|hsl)', rDigits3, '|', '(?:rgba|hsla)', rDigits4, '|', rKeyword, ')'],\n      '',\n    );\n  const rColorStop = combineRegExp([rColor, '(?:\\\\s+', rValue, '(?:\\\\s+', rValue, ')?)?'], '');\n  const // Single Color Stop, optional %, optional length.\n    rColorStopList = combineRegExp(['(?:', rColorStop, rComma, ')*', rColorStop], '');\n  const // List of color stops min 1.\n    rLineCapture = combineRegExp(['(?:(', rAngle, ')|', rSideCornerCapture, ')'], '');\n  const // Angle or SideCorner\n    rGradientSearch = combineRegExp(['(?:(', rLineCapture, ')', rComma, ')?(', rColorStopList, ')'], searchFlags);\n  const // Capture 1:\"line\", 2:\"angle\" (optional), 3:\"side corner\" (optional) and 4:\"stop list\".\n    rColorStopSearch = combineRegExp(\n      ['\\\\s*(', rColor, ')', '(?:\\\\s+', '(', rValue, '))?', '(?:', rComma, '\\\\s*)?'],\n      searchFlags,\n    ); // Capture 1:\"color\" and 2:\"position\" (optional).\n\n  return {\n    gradientSearch: rGradientSearch,\n    colorStopSearch: rColorStopSearch,\n  };\n};\n\n/**\n * Actually parse the input gradient parameters string into an object for reusability.\n *\n *\n * @note Really this only supports the standard syntax not historical versions, see MDN for details\n *       https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient\n *\n * @param regExpLib\n * @param {string} input\n * @returns {object|undefined}\n */\nconst parseGradient = (regExpLib: RegExpLib, input: string) => {\n  let result: ParseGradientResult;\n  let matchColorStop: any;\n  let stopResult: ColorStop;\n\n  // reset search position, because we reuse regex.\n  regExpLib.gradientSearch.lastIndex = 0;\n\n  const matchGradient = regExpLib.gradientSearch.exec(input);\n  if (!isNull(matchGradient)) {\n    result = {\n      original: matchGradient[0],\n      colorStopList: [],\n    };\n\n    // Line (Angle or Side-Corner).\n    if (matchGradient[1]) {\n      // eslint-disable-next-line prefer-destructuring\n      result.line = matchGradient[1];\n    }\n    // Angle or undefined if side-corner.\n    if (matchGradient[2]) {\n      // eslint-disable-next-line prefer-destructuring\n      result.angle = matchGradient[2];\n    }\n    // Side-corner or undefined if angle.\n    if (matchGradient[3]) {\n      // eslint-disable-next-line prefer-destructuring\n      result.sideCorner = matchGradient[3];\n    }\n\n    // reset search position, because we reuse regex.\n    regExpLib.colorStopSearch.lastIndex = 0;\n\n    // Loop though all the color-stops.\n    matchColorStop = regExpLib.colorStopSearch.exec(matchGradient[4]);\n    while (!isNull(matchColorStop)) {\n      stopResult = {\n        color: matchColorStop[1],\n      };\n\n      // Position (optional).\n      if (matchColorStop[2]) {\n        // eslint-disable-next-line prefer-destructuring\n        stopResult.position = matchColorStop[2];\n      }\n      result.colorStopList.push(stopResult);\n\n      // Continue searching from previous position.\n      matchColorStop = regExpLib.colorStopSearch.exec(matchGradient[4]);\n    }\n  }\n\n  // Can be undefined if match not found.\n  return result;\n};\n\nexport interface GradientColorPoint {\n  id?: string;\n  color?: string;\n  left?: number;\n}\n\nexport interface GradientColors {\n  points: GradientColorPoint[];\n  degree: number;\n}\n\nconst REGEXP_LIB = generateRegExp();\nconst REG_GRADIENT = /.*gradient\\s*\\(((?:\\([^)]*\\)|[^)(]*)*)\\)/gim;\n\n/**\n * 验证是否是渐变字符串\n * @param input\n * @returns\n */\nexport const isGradientColor = (input: string): null | RegExpExecArray => {\n  REG_GRADIENT.lastIndex = 0;\n  return REG_GRADIENT.exec(input);\n};\n\n// 边界字符串和角度关系\nconst sideCornerDegreeMap = {\n  top: 0,\n  right: 90,\n  bottom: 180,\n  left: 270,\n  'top left': 225,\n  'left top': 225,\n  'top right': 135,\n  'right top': 135,\n  'bottom left': 315,\n  'left bottom': 315,\n  'bottom right': 45,\n  'right bottom': 45,\n};\n\n/**\n * 解析渐变字符串为 GradientColors 对象\n * @param input\n * @returns\n */\nexport const parseGradientString = (input: string): GradientColors | boolean => {\n  const match = isGradientColor(input);\n  if (!match) {\n    return false;\n  }\n  const gradientColors: GradientColors = {\n    points: [],\n    degree: 0,\n  };\n\n  const result: ParseGradientResult = parseGradient(REGEXP_LIB, match[1]);\n  if (result.original.trim() !== match[1].trim()) {\n    return false;\n  }\n  const points: GradientColorPoint[] = result.colorStopList.map(({ color, position }) => {\n    const point = Object.create(null);\n    point.color = tinyColor(color).toRgbString();\n    point.left = parseFloat(position);\n    return point;\n  });\n  gradientColors.points = points;\n  let degree = parseInt(result.angle, 10);\n  if (Number.isNaN(degree)) {\n    degree = sideCornerDegreeMap[result.sideCorner] || 90;\n  }\n  gradientColors.degree = degree;\n\n  return gradientColors;\n};\n\nexport default parseGradientString;\n"],"mappings":";;;;;;;;;;;;;;;;;AAeA,IAAMA,aAAA,GAAgB,SAAhBA,cAAiBC,UAAA,EAAiCC,KAA0B;EAChF,IAAIC,MAAS;EACb,SAASC,CAAI,MAAGA,CAAI,GAAAH,UAAA,CAAWI,MAAA,EAAQD,CAAK;IACtC,IAAAE,UAAA,CAASL,UAAW,CAAAG,CAAA,CAAE,CAAG;MAC3BD,MAAA,IAAUF,UAAW,CAAAG,CAAA;IACvB,CAAO;MACLD,MAAA,IAAWF,UAAA,CAAWG,CAAc,EAAAD,MAAA;IACtC;EACF;EACO,WAAII,MAAO,CAAAJ,MAAA,EAAQD,KAAK;AACjC;AA2BA,IAAMM,cAAA,GAAiB,SAAjBA,eAAA,EAAkC;EAEtC,IAAMC,WAAc;EACpB,IAAMC,MAAS;EAEf,IAAMC,kBAAqB;EAC3B,IAAMC,MAAS;EACf,IAAMC,SAAY;EAClB,IAAMC,QAAW;EACjB,IACEC,QAAW;EACb,IACEC,MAAS;EACX,IACEC,QAAW;EACb,IACEC,MAAS,GAAAlB,aAAA,CACP,CAAC,KAAO,EAAAa,SAAA,EAAW,GAAK,iBAAeC,QAAU,OAAK,eAAiB,EAAAC,QAAA,EAAU,GAAK,EAAAE,QAAA,EAAU,GAAG,GACnG,EACF;EACI,IAAAE,UAAA,GAAanB,aAAc,EAACkB,MAAQ,aAAWF,MAAA,EAAQ,SAAW,EAAAA,MAAA,EAAQ,MAAM,GAAG,EAAE;EAEzF,IAAAI,cAAA,GAAiBpB,aAAA,CAAc,CAAC,OAAOmB,UAAA,EAAYP,MAAQ,QAAMO,UAAU,GAAG,EAAE;EAEhF,IAAAE,YAAA,GAAerB,aAAA,CAAc,CAAC,QAAQU,MAAA,EAAQ,IAAM,EAAAC,kBAAA,EAAoB,GAAG,GAAG,EAAE;EAEhF,IAAAW,eAAA,GAAkBtB,aAAc,EAAC,MAAQ,EAAAqB,YAAA,EAAc,GAAK,EAAAT,MAAA,EAAQ,KAAO,EAAAQ,cAAA,EAAgB,GAAG,GAAGX,WAAW;EAC9G,IACEc,gBAAmB,GAAAvB,aAAA,CACjB,CAAC,OAAS,EAAAkB,MAAA,EAAQ,GAAK,aAAW,KAAKF,MAAQ,SAAO,KAAO,EAAAJ,MAAA,EAAQ,QAAQ,GAC7EH,WACF;EAEK;IACLe,cAAgB,EAAAF,eAAA;IAChBG,eAAiB,EAAAF;GACnB;AACF;AAaA,IAAMG,aAAA,GAAgB,SAAhBA,cAAiBC,SAAA,EAAsBC,KAAkB;EACzD,IAAAC,MAAA;EACA,IAAAC,cAAA;EACA,IAAAC,UAAA;EAGJJ,SAAA,CAAUH,cAAA,CAAeQ,SAAY;EAErC,IAAMC,aAAgB,GAAAN,SAAA,CAAUH,cAAe,CAAAU,IAAA,CAAKN,KAAK;EACrD,KAACO,QAAO,CAAAF,aAAa,CAAG;IACjBJ,MAAA;MACPO,QAAA,EAAUH,aAAc;MACxBI,aAAA,EAAe;KACjB;IAGA,IAAIJ,aAAA,CAAc,CAAI;MAEpBJ,MAAA,CAAOS,IAAA,GAAOL,aAAc;IAC9B;IAEA,IAAIA,aAAA,CAAc,CAAI;MAEpBJ,MAAA,CAAOU,KAAA,GAAQN,aAAc;IAC/B;IAEA,IAAIA,aAAA,CAAc,CAAI;MAEpBJ,MAAA,CAAOW,UAAA,GAAaP,aAAc;IACpC;IAGAN,SAAA,CAAUF,eAAA,CAAgBO,SAAY;IAGtCF,cAAA,GAAiBH,SAAU,CAAAF,eAAA,CAAgBS,IAAK,CAAAD,aAAA,CAAc,CAAE;IACzD,QAACE,QAAO,CAAAL,cAAc,CAAG;MACjBC,UAAA;QACXU,KAAA,EAAOX,cAAe;OACxB;MAGA,IAAIA,cAAA,CAAe,CAAI;QAErBC,UAAA,CAAWW,QAAA,GAAWZ,cAAe;MACvC;MACOD,MAAA,CAAAQ,aAAA,CAAcM,IAAA,CAAKZ,UAAU;MAGpCD,cAAA,GAAiBH,SAAU,CAAAF,eAAA,CAAgBS,IAAK,CAAAD,aAAA,CAAc,CAAE;IAClE;EACF;EAGO,OAAAJ,MAAA;AACT;AAaA,IAAMe,UAAA,GAAapC,cAAe;AAClC,IAAMqC,YAAe;IAORC,eAAA,GAAkB,SAAlBA,gBAAmBlB,KAA0C;EACxEiB,YAAA,CAAab,SAAY;EAClB,OAAAa,YAAA,CAAaX,IAAA,CAAKN,KAAK;AAChC;AAGA,IAAMmB,mBAAsB;EAC1BC,GAAK;EACLC,KAAO;EACPC,MAAQ;EACRC,IAAM;EACN,UAAY;EACZ,UAAY;EACZ,WAAa;EACb,WAAa;EACb,aAAe;EACf,aAAe;EACf,cAAgB;EAChB,cAAgB;AAClB;IAOaC,mBAAA,GAAsB,SAAtBA,oBAAuBxB,KAA4C;EACxE,IAAAyB,KAAA,GAAQP,eAAA,CAAgBlB,KAAK;EACnC,IAAI,CAACyB,KAAO;IACH;EACT;EACA,IAAMC,cAAiC;IACrCC,MAAA,EAAQ,EAAC;IACTC,MAAQ;GACV;EAEA,IAAM3B,MAA8B,GAAAH,aAAA,CAAckB,UAAY,EAAAS,KAAA,CAAM,CAAE;EACtE,IAAIxB,MAAA,CAAOO,QAAS,CAAAqB,IAAA,OAAWJ,KAAM,IAAGI,IAAA,EAAQ;IACvC;EACT;EACM,IAAAF,MAAA,GAA+B1B,MAAA,CAAOQ,aAAc,CAAAqB,GAAA,CAAI,UAAAC,IAAA,EAAyB;IAAA,IAAtBlB,KAAA,GAAAkB,IAAA,CAAAlB,KAAA;MAAOC,QAAA,GAAAiB,IAAA,CAAAjB,QAAA;IAChE,IAAAkB,KAAA,kBAAeC,MAAA,CAAAC,MAAA,CAAO,IAAI;IAChCF,KAAA,CAAMnB,KAAQ,GAAAsB,SAAA,CAAUtB,KAAK,EAAEuB,WAAY;IACrCJ,KAAA,CAAAT,IAAA,GAAOc,UAAA,CAAWvB,QAAQ;IACzB,OAAAkB,KAAA;EACT,CAAC;EACDN,cAAA,CAAeC,MAAS,GAAAA,MAAA;EACxB,IAAIC,MAAS,GAAAU,QAAA,CAASrC,MAAO,CAAAU,KAAA,EAAO,EAAE;EAClC,IAAA4B,MAAA,CAAOC,KAAM,CAAAZ,MAAM,CAAG;IACfA,MAAA,GAAAT,mBAAA,CAAoBlB,MAAA,CAAOW,UAAe;EACrD;EACAc,cAAA,CAAeE,MAAS,GAAAA,MAAA;EAEjB,OAAAF,cAAA;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}