{"ast":null,"code":"/**\n * tdesign v1.10.5\n * (c) 2024 tdesign\n * @license MIT\n */\n\nimport { _ as _objectWithoutProperties } from '../_chunks/dep-5d3f7c0e.mjs';\nimport { unref, getCurrentScope, onScopeDispose, watch } from 'vue';\nvar _excluded = [\"window\"];\nvar defaultWindow = typeof window !== \"undefined\" ? window : void 0;\nfunction unrefElement(elRef) {\n  var _plain$$el;\n  var plain = unref(elRef);\n  return (_plain$$el = plain === null || plain === void 0 ? void 0 : plain.$el) !== null && _plain$$el !== void 0 ? _plain$$el : plain;\n}\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\nfunction useMutationObserver(target, callback) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$window = options.window,\n    window2 = _options$window === void 0 ? defaultWindow : _options$window,\n    mutationOptions = _objectWithoutProperties(options, _excluded);\n  var observer;\n  var isSupported = window2 && \"MutationObserver\" in window2;\n  var cleanup = function cleanup() {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  var stopWatch = watch(function () {\n    return unrefElement(target);\n  }, function (el) {\n    cleanup();\n    if (isSupported && window2 && el) {\n      observer = new MutationObserver(callback);\n      observer.observe(el, mutationOptions);\n    }\n  }, {\n    immediate: true\n  });\n  var stop = function stop() {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported: isSupported,\n    stop: stop\n  };\n}\nexport { defaultWindow, tryOnScopeDispose, unrefElement, useMutationObserver };","map":{"version":3,"names":["defaultWindow","window","unrefElement","elRef","_plain$$el","plain","unref","$el","tryOnScopeDispose","fn","getCurrentScope","onScopeDispose","useMutationObserver","target","callback","options","arguments","length","undefined","_options$window","window2","mutationOptions","_objectWithoutProperties","_excluded","observer","isSupported","cleanup","disconnect","stopWatch","watch","el","MutationObserver","observe","immediate","stop"],"sources":["../../src/watermark/hooks.ts"],"sourcesContent":["import type { ComponentPublicInstance, Ref } from 'vue';\nimport { unref, watch, getCurrentScope, onScopeDispose } from 'vue';\n\nexport const defaultWindow = typeof window !== 'undefined' ? window : undefined;\nexport interface ConfigurableWindow {\n  window?: Window;\n}\n// eslint-disable-next-line no-undef\nexport interface MutationObserverOptions extends MutationObserverInit, ConfigurableWindow {}\nexport type MaybeRef<T> = T | Ref<T>;\nexport type VueInstance = ComponentPublicInstance;\nexport type MaybeElementRef<T extends MaybeElement = MaybeElement> = MaybeRef<T>;\nexport type MaybeElement = HTMLElement | SVGElement | VueInstance | undefined | null;\nexport type UnRefElementReturn<T extends MaybeElement = MaybeElement> = T extends VueInstance\n  ? Exclude<MaybeElement, VueInstance>\n  : T | undefined;\n\nexport type Fn = () => void;\n\nexport function unrefElement<T extends MaybeElement>(elRef: MaybeElementRef<T>): UnRefElementReturn<T> {\n  const plain = unref(elRef);\n  return (plain as VueInstance)?.$el ?? plain;\n}\nexport function tryOnScopeDispose(fn: Fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\n\nexport function useMutationObserver(\n  target: MaybeElementRef,\n  // eslint-disable-next-line no-undef\n  callback: MutationCallback,\n  options: MutationObserverOptions = {},\n) {\n  const { window = defaultWindow, ...mutationOptions } = options;\n  let observer: MutationObserver | undefined;\n  const isSupported = window && 'MutationObserver' in window;\n\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = undefined;\n    }\n  };\n\n  const stopWatch = watch(\n    () => unrefElement(target),\n    (el) => {\n      cleanup();\n\n      if (isSupported && window && el) {\n        observer = new MutationObserver(callback);\n        observer.observe(el, mutationOptions);\n      }\n    },\n    { immediate: true },\n  );\n\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n\n  tryOnScopeDispose(stop);\n\n  return {\n    isSupported,\n    stop,\n  };\n}\n\nexport type UseMutationObserverReturn = ReturnType<typeof useMutationObserver>;\n"],"mappings":";;;;;;;;;AAGO,IAAMA,aAAgB,UAAOC,MAAW,mBAAcA,MAAS;AAgB/D,SAASC,aAAqCC,KAAkD;EAAA,IAAAC,UAAA;EAC/F,IAAAC,KAAA,GAAQC,KAAA,CAAMH,KAAK;EACzB,QAAAC,UAAA,GAAQC,KAAA,aAAAA,KAAA,uBAAAA,KAAA,CAAuBE,GAAO,cAAAH,UAAA,cAAAA,UAAA,GAAAC,KAAA;AACxC;AACO,SAASG,kBAAkBC,EAAQ;EACxC,IAAIC,eAAA,EAAmB;IACrBC,cAAA,CAAeF,EAAE;IACV;EACT;EACO;AACT;AAEO,SAASG,mBACdA,CAAAC,MAAA,EAEAC,QACA,EACA;EAAA,IADAC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAmC,EACnC;EACA,IAAAG,eAAA,GAAuDJ,OAAA,CAA/Cd,MAAA;IAAAmB,OAAS,GAAAD,eAAA,cAAAnB,aAAA,GAAAmB,eAAA;IAAkBE,eAAA,GAAAC,wBAAA,CAAoBP,OAAA,EAAAQ,SAAA;EACnD,IAAAC,QAAA;EACE,IAAAC,WAAA,GAAcL,OAAA,IAAU,kBAAsB,IAAAA,OAAA;EAEpD,IAAMM,OAAA,GAAU,SAAVA,QAAA,EAAgB;IACpB,IAAIF,QAAU;MACZA,QAAA,CAASG,UAAW;MACTH,QAAA;IACb;GACF;EAEA,IAAMI,SAAY,GAAAC,KAAA,CAChB;IAAA,OAAM3B,YAAA,CAAaW,MAAM;GACzB,YAACiB,EAAO;IACEJ,OAAA;IAEJ,IAAAD,WAAA,IAAeL,OAAA,IAAUU,EAAI;MACpBN,QAAA,OAAIO,gBAAA,CAAiBjB,QAAQ;MAC/BU,QAAA,CAAAQ,OAAA,CAAQF,EAAA,EAAIT,eAAe;IACtC;EACF,GACA;IAAEY,SAAA,EAAW;EAAK,CACpB;EAEA,IAAMC,IAAA,GAAO,SAAPA,KAAA,EAAa;IACTR,OAAA;IACEE,SAAA;GACZ;EAEApB,iBAAA,CAAkB0B,IAAI;EAEf;IACLT,WAAA,EAAAA,WAAA;IACAS,IAAA,EAAAA;GACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}