{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\n/**\n * tdesign v1.10.5\n * (c) 2024 tdesign\n * @license MIT\n */\n\nimport { _ as _toConsumableArray } from '../_chunks/dep-4a990ea3.mjs';\nimport { _ as _slicedToArray } from '../_chunks/dep-5efe53d1.mjs';\nimport { ref, computed, watch } from 'vue';\nimport useResizeObserver from './useResizeObserver.mjs';\nimport '../_chunks/dep-eca422c3.mjs';\nimport { i as isSymbol_1 } from '../_chunks/dep-ab4bb9b8.mjs';\nimport { i as identity_1 } from '../_chunks/dep-400ec705.mjs';\nimport { t as throttle_1 } from '../_chunks/dep-525a54df.mjs';\nimport '../_chunks/dep-593f2b67.mjs';\nimport '../_chunks/dep-4659d73b.mjs';\nimport '../_chunks/dep-bf7257e7.mjs';\nimport '../_chunks/dep-29ef8419.mjs';\nimport '../_chunks/dep-5993931e.mjs';\nimport '../_chunks/dep-2b09875b.mjs';\nimport '../_chunks/dep-cda4f568.mjs';\nimport '../_chunks/dep-8dfc9324.mjs';\nvar isSymbol = isSymbol_1;\n\n/**\n * The base implementation of methods like `_.max` and `_.min` which accepts a\n * `comparator` to determine the extremum value.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The iteratee invoked per iteration.\n * @param {Function} comparator The comparator used to compare values.\n * @returns {*} Returns the extremum value.\n */\nfunction baseExtremum$2(array, iteratee, comparator) {\n  var index = -1,\n    length = array.length;\n  while (++index < length) {\n    var value = array[index],\n      current = iteratee(value);\n    if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) {\n      var computed = current,\n        result = value;\n    }\n  }\n  return result;\n}\nvar _baseExtremum = baseExtremum$2;\n\n/**\n * The base implementation of `_.gt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is greater than `other`,\n *  else `false`.\n */\nfunction baseGt$1(value, other) {\n  return value > other;\n}\nvar _baseGt = baseGt$1;\nvar baseExtremum$1 = _baseExtremum,\n  baseGt = _baseGt,\n  identity$2 = identity_1;\n\n/**\n * Computes the maximum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the maximum value.\n * @example\n *\n * _.max([4, 2, 8, 6]);\n * // => 8\n *\n * _.max([]);\n * // => undefined\n */\nfunction max(array) {\n  return array && array.length ? baseExtremum$1(array, identity$2, baseGt) : undefined;\n}\nvar max_1 = max;\n\n/**\n * The base implementation of `_.lt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is less than `other`,\n *  else `false`.\n */\nfunction baseLt$1(value, other) {\n  return value < other;\n}\nvar _baseLt = baseLt$1;\nvar baseExtremum = _baseExtremum,\n  baseLt = _baseLt,\n  identity$1 = identity_1;\n\n/**\n * Computes the minimum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the minimum value.\n * @example\n *\n * _.min([4, 2, 8, 6]);\n * // => 2\n *\n * _.min([]);\n * // => undefined\n */\nfunction min(array) {\n  return array && array.length ? baseExtremum(array, identity$1, baseLt) : undefined;\n}\nvar min_1 = min;\n\n/**\n * The base implementation of `_.sum` and `_.sumBy` without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {number} Returns the sum.\n */\nfunction baseSum$1(array, iteratee) {\n  var result,\n    index = -1,\n    length = array.length;\n  while (++index < length) {\n    var current = iteratee(array[index]);\n    if (current !== undefined) {\n      result = result === undefined ? current : result + current;\n    }\n  }\n  return result;\n}\nvar _baseSum = baseSum$1;\nvar baseSum = _baseSum,\n  identity = identity_1;\n\n/**\n * Computes the sum of the values in `array`.\n *\n * @static\n * @memberOf _\n * @since 3.4.0\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {number} Returns the sum.\n * @example\n *\n * _.sum([4, 2, 8, 6]);\n * // => 20\n */\nfunction sum(array) {\n  return array && array.length ? baseSum(array, identity) : 0;\n}\nvar sum_1 = sum;\nvar useVirtualScroll = function useVirtualScroll(container, params) {\n  var _params$value$data, _params$value$scroll;\n  var visibleData = ref([]);\n  var translateY = ref((((_params$value$data = params.value.data) === null || _params$value$data === void 0 ? void 0 : _params$value$data.length) || 0) * (((_params$value$scroll = params.value.scroll) === null || _params$value$scroll === void 0 ? void 0 : _params$value$scroll.rowHeight) || 50));\n  var scrollHeight = ref(0);\n  var trHeightList = [];\n  var containerHeight = ref(0);\n  var containerWidth = ref(0);\n  var startAndEndIndex = ref([0, 15]);\n  var tScroll = computed(function () {\n    var _scroll$isFixedRowHei, _scroll$fixedRows;\n    var scroll = params.value.scroll;\n    if (!scroll) return {};\n    return {\n      bufferSize: scroll.bufferSize || 10,\n      isFixedRowHeight: (_scroll$isFixedRowHei = scroll.isFixedRowHeight) !== null && _scroll$isFixedRowHei !== void 0 ? _scroll$isFixedRowHei : false,\n      rowHeight: scroll.rowHeight || 47,\n      threshold: scroll.threshold || 100,\n      type: scroll.type,\n      fixedRows: (_scroll$fixedRows = scroll.fixedRows) !== null && _scroll$fixedRows !== void 0 ? _scroll$fixedRows : [0, 0]\n    };\n  });\n  var isVirtualScroll = computed(function () {\n    var data = params.value.data;\n    return tScroll.value.type === \"virtual\" && tScroll.value.threshold < data.length;\n  });\n  function getVisibleRangeConfig() {\n    var _container$value$scro, _container$value;\n    var scrollTop = (_container$value$scro = (_container$value = container.value) === null || _container$value === void 0 ? void 0 : _container$value.scrollTop) !== null && _container$value$scro !== void 0 ? _container$value$scro : 0;\n    var fixedStart = tScroll.value.fixedRows[0];\n    var prevBufferHeightList = [];\n    var hiddenHeight = 0;\n    var visibleStart = -1;\n    var visibleEnd = -1;\n    var totalHeight = 0;\n    for (var i = 0, len = params.value.data.length; i < len; i++) {\n      var _trHeightList$i;\n      var rowHeight = (_trHeightList$i = trHeightList[i]) !== null && _trHeightList$i !== void 0 ? _trHeightList$i : tScroll.value.rowHeight;\n      totalHeight = totalHeight + rowHeight;\n      if (totalHeight > scrollTop && visibleStart === -1) {\n        visibleStart = i;\n        if (visibleStart - tScroll.value.bufferSize > 0) {\n          hiddenHeight = totalHeight - rowHeight - sum_1(prevBufferHeightList);\n        }\n      }\n      if (visibleStart === -1) {\n        prevBufferHeightList.push(rowHeight);\n        if (prevBufferHeightList.length > tScroll.value.bufferSize) {\n          prevBufferHeightList.shift();\n        }\n      }\n      if (visibleEnd === -1 && (totalHeight > containerHeight.value + scrollTop || i === params.value.data.length - 1)) {\n        visibleEnd = i;\n      }\n      if (visibleStart !== -1 && visibleEnd !== -1) {\n        break;\n      }\n    }\n    var startIndex = max_1([visibleStart - tScroll.value.bufferSize, 0]);\n    var endIndex = min_1([visibleEnd + tScroll.value.bufferSize, params.value.data.length]);\n    var stickyHeight = sum_1(trHeightList.slice(0, Math.min(startIndex, fixedStart)));\n    return {\n      startIndex: startIndex,\n      endIndex: endIndex,\n      translateY: hiddenHeight - stickyHeight\n    };\n  }\n  var updateVisibleData = throttle_1(function () {\n    var _getVisibleRangeConfi = getVisibleRangeConfig(),\n      startIndex = _getVisibleRangeConfi.startIndex,\n      endIndex = _getVisibleRangeConfi.endIndex,\n      translateYValue = _getVisibleRangeConfi.translateY;\n    var fixedRows = tScroll.value.fixedRows;\n    var _fixedRows = _slicedToArray(fixedRows, 2),\n      fixedStart = _fixedRows[0],\n      fixedEnd = _fixedRows[1];\n    var fixedStartData = fixedStart ? params.value.data.slice(0, fixedStart) : [];\n    if (fixedStart && startIndex < fixedStart) {\n      fixedStartData = fixedStartData.slice(0, startIndex);\n    }\n    var fixedEndData = fixedEnd ? params.value.data.slice(params.value.data.length - fixedEnd) : [];\n    var bottomStartIndex = endIndex - params.value.data.length + 1 + (fixedEnd !== null && fixedEnd !== void 0 ? fixedEnd : 0);\n    if (fixedEnd && bottomStartIndex > 0) {\n      fixedEndData = fixedEndData.slice(bottomStartIndex);\n    }\n    if (startAndEndIndex.value.join() !== [startIndex, endIndex].join() && startIndex >= 0) {\n      translateY.value = translateYValue;\n      visibleData.value = fixedStartData.concat(params.value.data.slice(startIndex, endIndex), fixedEndData);\n      startAndEndIndex.value = [startIndex, endIndex];\n    }\n  }, 100);\n  var handleRowMounted = function handleRowMounted(rowData) {\n    var _rowData$ref$value;\n    if (!isVirtualScroll.value || !rowData || tScroll.value.isFixedRowHeight || !container.value) return;\n    var trHeight = ((_rowData$ref$value = rowData.ref.value) === null || _rowData$ref$value === void 0 ? void 0 : _rowData$ref$value.getBoundingClientRect().height) || tScroll.value.rowHeight;\n    var rowIndex = rowData.data.VIRTUAL_SCROLL_INDEX;\n    if (trHeightList[rowIndex] !== trHeight) {\n      var diff = trHeight - trHeightList[rowIndex];\n      trHeightList[rowIndex] = trHeight;\n      scrollHeight.value = scrollHeight.value + diff;\n    }\n  };\n  var handleScroll = function handleScroll() {\n    if (!isVirtualScroll.value) return;\n    updateVisibleData();\n  };\n  var refreshVirtualScroll = function refreshVirtualScroll(_ref) {\n    var _ref2 = _slicedToArray(_ref, 1),\n      contentRect = _ref2[0].contentRect;\n    if (params.value.preventResizeRefresh) return;\n    var maxScrollbarWidth = 16;\n    if (Math.abs(contentRect.width - containerWidth.value) > maxScrollbarWidth && !!container.value) {\n      container.value.scrollTop = 0;\n      translateY.value = 0;\n    }\n    containerWidth.value = contentRect.width;\n    containerHeight.value = contentRect.height;\n  };\n  var addIndexToData = function addIndexToData(data) {\n    data.forEach(function (item, index) {\n      item[\"VIRTUAL_SCROLL_INDEX\"] = index;\n    });\n  };\n  var updateScrollTop = function updateScrollTop(_ref3) {\n    var index = _ref3.index,\n      _ref3$top = _ref3.top,\n      top = _ref3$top === void 0 ? 0 : _ref3$top,\n      behavior = _ref3.behavior;\n    var scrollTop = sum_1(trHeightList.slice(0, index + 1)) - top;\n    container.value.scrollTo({\n      top: scrollTop,\n      behavior: behavior || \"auto\"\n    });\n  };\n  var scrollToElement = function scrollToElement(p) {\n    updateScrollTop(p);\n    if (!tScroll.value.isFixedRowHeight) {\n      var _p$time;\n      var duration = (_p$time = p.time) !== null && _p$time !== void 0 ? _p$time : 60;\n      var timer = setTimeout(function () {\n        updateScrollTop(p);\n        clearTimeout(timer);\n      }, duration);\n    }\n  };\n  useResizeObserver(computed(function () {\n    return isVirtualScroll.value ? container.value : void 0;\n  }), refreshVirtualScroll);\n  watch(function () {\n    return [_toConsumableArray(params.value.data), tScroll.value, isVirtualScroll.value, container.value];\n  }, function () {\n    if (!isVirtualScroll.value || !container.value) return;\n    var data = params.value.data;\n    addIndexToData(data);\n    containerHeight.value = container.value.getBoundingClientRect().height;\n    if (trHeightList.length !== params.value.data.length) {\n      var initHeightList = Array.from(trHeightList);\n      initHeightList.length = params.value.data.length;\n      initHeightList.fill(tScroll.value.rowHeight || 47);\n      trHeightList = initHeightList;\n    }\n    scrollHeight.value = sum_1(trHeightList);\n    startAndEndIndex.value = [0, 0];\n    updateVisibleData();\n  }, {\n    immediate: true\n  });\n  watch(function () {\n    return containerHeight.value;\n  }, function () {\n    updateVisibleData();\n  });\n  return {\n    visibleData: visibleData,\n    translateY: translateY,\n    scrollHeight: scrollHeight,\n    isVirtualScroll: isVirtualScroll,\n    handleScroll: handleScroll,\n    handleRowMounted: handleRowMounted,\n    scrollToElement: scrollToElement\n  };\n};\nexport { useVirtualScroll as default };","map":{"version":3,"names":["isSymbol","isSymbol_1","baseExtremum$2","array","iteratee","comparator","index","length","value","current","computed","undefined","result","_baseExtremum","baseGt$1","other","_baseGt","baseExtremum$1","baseGt","identity$2","identity_1","max","max_1","baseLt$1","_baseLt","baseExtremum","baseLt","identity$1","min","min_1","baseSum$1","_baseSum","baseSum","identity","sum","sum_1","useVirtualScroll","container","params","_params$value$data","_params$value$scroll","visibleData","ref","translateY","data","scroll","rowHeight","scrollHeight","trHeightList","containerHeight","containerWidth","startAndEndIndex","tScroll","_scroll$isFixedRowHei","_scroll$fixedRows","bufferSize","isFixedRowHeight","threshold","type","fixedRows","isVirtualScroll","getVisibleRangeConfig","_container$value$scro","_container$value","scrollTop","fixedStart","prevBufferHeightList","hiddenHeight","visibleStart","visibleEnd","totalHeight","i","len","_trHeightList$i","push","shift","startIndex","endIndex","stickyHeight","slice","Math","updateVisibleData","throttle_1","_getVisibleRangeConfi","translateYValue","_fixedRows","_slicedToArray","fixedEnd","fixedStartData","fixedEndData","bottomStartIndex","join","concat","handleRowMounted","rowData","_rowData$ref$value","trHeight","getBoundingClientRect","height","rowIndex","VIRTUAL_SCROLL_INDEX","diff","handleScroll","refreshVirtualScroll","_ref","_ref2","contentRect","preventResizeRefresh","maxScrollbarWidth","abs","width","addIndexToData","forEach","item","updateScrollTop","_ref3","top","_ref3$top","behavior","scrollTo","scrollToElement","p","_p$time","duration","time","timer","setTimeout","clearTimeout","useResizeObserver","watch","_toConsumableArray","initHeightList","Array","from","fill","immediate"],"sources":["../../node_modules/lodash/_baseExtremum.js","../../node_modules/lodash/_baseGt.js","../../node_modules/lodash/max.js","../../node_modules/lodash/_baseLt.js","../../node_modules/lodash/min.js","../../node_modules/lodash/_baseSum.js","../../node_modules/lodash/sum.js","../../src/hooks/useVirtualScrollNew.ts"],"sourcesContent":["var isSymbol = require('./isSymbol');\n\n/**\n * The base implementation of methods like `_.max` and `_.min` which accepts a\n * `comparator` to determine the extremum value.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The iteratee invoked per iteration.\n * @param {Function} comparator The comparator used to compare values.\n * @returns {*} Returns the extremum value.\n */\nfunction baseExtremum(array, iteratee, comparator) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var value = array[index],\n        current = iteratee(value);\n\n    if (current != null && (computed === undefined\n          ? (current === current && !isSymbol(current))\n          : comparator(current, computed)\n        )) {\n      var computed = current,\n          result = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseExtremum;\n","/**\n * The base implementation of `_.gt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is greater than `other`,\n *  else `false`.\n */\nfunction baseGt(value, other) {\n  return value > other;\n}\n\nmodule.exports = baseGt;\n","var baseExtremum = require('./_baseExtremum'),\n    baseGt = require('./_baseGt'),\n    identity = require('./identity');\n\n/**\n * Computes the maximum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the maximum value.\n * @example\n *\n * _.max([4, 2, 8, 6]);\n * // => 8\n *\n * _.max([]);\n * // => undefined\n */\nfunction max(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseGt)\n    : undefined;\n}\n\nmodule.exports = max;\n","/**\n * The base implementation of `_.lt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is less than `other`,\n *  else `false`.\n */\nfunction baseLt(value, other) {\n  return value < other;\n}\n\nmodule.exports = baseLt;\n","var baseExtremum = require('./_baseExtremum'),\n    baseLt = require('./_baseLt'),\n    identity = require('./identity');\n\n/**\n * Computes the minimum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the minimum value.\n * @example\n *\n * _.min([4, 2, 8, 6]);\n * // => 2\n *\n * _.min([]);\n * // => undefined\n */\nfunction min(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseLt)\n    : undefined;\n}\n\nmodule.exports = min;\n","/**\n * The base implementation of `_.sum` and `_.sumBy` without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {number} Returns the sum.\n */\nfunction baseSum(array, iteratee) {\n  var result,\n      index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var current = iteratee(array[index]);\n    if (current !== undefined) {\n      result = result === undefined ? current : (result + current);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseSum;\n","var baseSum = require('./_baseSum'),\n    identity = require('./identity');\n\n/**\n * Computes the sum of the values in `array`.\n *\n * @static\n * @memberOf _\n * @since 3.4.0\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {number} Returns the sum.\n * @example\n *\n * _.sum([4, 2, 8, 6]);\n * // => 20\n */\nfunction sum(array) {\n  return (array && array.length)\n    ? baseSum(array, identity)\n    : 0;\n}\n\nmodule.exports = sum;\n","/**\n * 基于原作者（@louiszhai）的思路二次开发，为保证其他组件暂不受影响，单独开一个文件\n * 新增支持以下 3 个特性\n * 1. 支持不同表格高度\n * 2. 支持滚动到特定元素，方便 Select 等组件展开时直接定位到选中元素\n * 3. 支持数据变化不重置，方便支持树形结构虚拟滚动\n */\nimport { ref, computed, watch, Ref } from 'vue';\nimport { TScroll } from '../common';\nimport useResizeObserver from './useResizeObserver';\nimport max from 'lodash/max';\nimport min from 'lodash/min';\nimport sum from 'lodash/sum';\nimport throttle from 'lodash/throttle';\n\nexport type UseVirtualScrollParams = Ref<{\n  /** 列数据 */\n  data: { [key: string]: any }[];\n  scroll: TScroll & {\n    /** 固定行（冻结行），示例：[M, N]，表示冻结头 M 行和尾 N 行。M 和 N 值为 0 时，表示不冻结行 */\n    fixedRows?: Array<number>;\n  };\n  preventResizeRefresh?: boolean;\n}>;\n\nexport interface ScrollToElementParams {\n  /** 跳转元素下标 */\n  index: number;\n  /** 跳转元素距离顶部的距离 */\n  top?: number;\n  /** 单个元素高度非固定场景下，即 isFixedRowHeight = false。延迟设置元素位置，一般用于依赖不同高度异步渲染等场景，单位：毫秒 */\n  time?: number;\n  behavior?: 'auto' | 'smooth';\n}\n\nconst useVirtualScroll = (container: Ref<HTMLElement | null>, params: UseVirtualScrollParams) => {\n  /** 注意测试：数据长度为空；数据长度小于表格高度等情况。即期望只有数据量达到一定程度才允许开启虚拟滚动 */\n  const visibleData = ref<any[]>([]);\n  // 用于显示表格列\n  const translateY = ref((params.value.data?.length || 0) * (params.value.scroll?.rowHeight || 50));\n  // 滚动高度，用于显示滚动条\n  const scrollHeight = ref(0);\n  // 已经通过节点渲染计算出来的各自行高\n  // 不要使用响应式，数据量大时会产生卡顿\n  let trHeightList: number[] = [];\n  const containerHeight = ref(0);\n  const containerWidth = ref(0);\n  const startAndEndIndex = ref<[number, number]>([0, 15]);\n\n  // 设置初始值\n  const tScroll = computed(() => {\n    const { scroll } = params.value;\n    if (!scroll) return {};\n    return {\n      bufferSize: scroll.bufferSize || 10,\n      isFixedRowHeight: scroll.isFixedRowHeight ?? false,\n      rowHeight: scroll.rowHeight || 47,\n      threshold: scroll.threshold || 100,\n      type: scroll.type,\n      fixedRows: scroll.fixedRows ?? [0, 0],\n    };\n  });\n\n  // 当前场景是否满足开启虚拟滚动的条件\n  const isVirtualScroll = computed(() => {\n    const { data } = params.value;\n    return tScroll.value.type === 'virtual' && tScroll.value.threshold < data.length;\n  });\n\n  // 一次循环遍历中计算可视范围的相关信息，减少大数据量时的遍历开销\n  function getVisibleRangeConfig() {\n    const scrollTop = container.value?.scrollTop ?? 0;\n    const fixedStart = tScroll.value.fixedRows[0];\n\n    // 记录前置 buffer 的高度\n    const prevBufferHeightList: number[] = [];\n    // 没有被渲染的行的高度，用于设定容器的 translateY\n    let hiddenHeight = 0;\n\n    let visibleStart = -1;\n    let visibleEnd = -1;\n\n    let totalHeight = 0;\n\n    for (let i = 0, len = params.value.data.length; i < len; i++) {\n      const rowHeight = trHeightList[i] ?? tScroll.value.rowHeight;\n      totalHeight = totalHeight + rowHeight;\n      // 获取第一个可视范围内的元素\n      if (totalHeight > scrollTop && visibleStart === -1) {\n        visibleStart = i;\n        if (visibleStart - tScroll.value.bufferSize > 0) {\n          hiddenHeight = totalHeight - rowHeight - sum(prevBufferHeightList);\n        }\n      }\n      if (visibleStart === -1) {\n        prevBufferHeightList.push(rowHeight);\n        if (prevBufferHeightList.length > tScroll.value.bufferSize) {\n          prevBufferHeightList.shift();\n        }\n      }\n      // 获取最后一个可视范围内的元素\n      if (\n        visibleEnd === -1 &&\n        (totalHeight > containerHeight.value + scrollTop || i === params.value.data.length - 1)\n      ) {\n        visibleEnd = i;\n      }\n\n      if (visibleStart !== -1 && visibleEnd !== -1) {\n        // 不再统计高度\n        break;\n      }\n    }\n\n    // 前后偏移 buffer\n    const startIndex = max([visibleStart - tScroll.value.bufferSize, 0]);\n    const endIndex = min([visibleEnd + tScroll.value.bufferSize, params.value.data.length]);\n\n    // 以 sticky 定位渲染的固定行，会占据高度，影响整体高度\n    const stickyHeight = sum(trHeightList.slice(0, Math.min(startIndex, fixedStart)));\n\n    return {\n      startIndex,\n      endIndex,\n      translateY: hiddenHeight - stickyHeight,\n    };\n  }\n\n  const updateVisibleData = throttle(() => {\n    // 计算前后的buffer偏移后的渲染数据\n    const { startIndex, endIndex, translateY: translateYValue } = getVisibleRangeConfig();\n\n    // 需要考虑固定行的情况\n    const fixedRows = tScroll.value.fixedRows;\n    const [fixedStart, fixedEnd] = fixedRows;\n    let fixedStartData = fixedStart ? params.value.data.slice(0, fixedStart) : [];\n    if (fixedStart && startIndex < fixedStart) {\n      fixedStartData = fixedStartData.slice(0, startIndex);\n    }\n    let fixedEndData = fixedEnd ? params.value.data.slice(params.value.data.length - fixedEnd) : [];\n    const bottomStartIndex = endIndex - params.value.data.length + 1 + (fixedEnd ?? 0);\n    if (fixedEnd && bottomStartIndex > 0) {\n      fixedEndData = fixedEndData.slice(bottomStartIndex);\n    }\n\n    if (startAndEndIndex.value.join() !== [startIndex, endIndex].join() && startIndex >= 0) {\n      translateY.value = translateYValue;\n      visibleData.value = fixedStartData.concat(params.value.data.slice(startIndex, endIndex), fixedEndData);\n      startAndEndIndex.value = [startIndex, endIndex];\n    }\n  }, 100);\n\n  // 固定高度场景，不需要通过行渲染获取高度（仅非固定高度场景需要）\n  const handleRowMounted = (rowData: any) => {\n    if (!isVirtualScroll.value || !rowData || tScroll.value.isFixedRowHeight || !container.value) return;\n    const trHeight = rowData.ref.value?.getBoundingClientRect().height || tScroll.value.rowHeight;\n    const rowIndex = rowData.data.VIRTUAL_SCROLL_INDEX;\n\n    if (trHeightList[rowIndex] !== trHeight) {\n      const diff = trHeight - trHeightList[rowIndex];\n      trHeightList[rowIndex] = trHeight;\n      // 采用 diff 的方式更新，不再遍历数组\n      scrollHeight.value = scrollHeight.value + diff;\n    }\n  };\n\n  const handleScroll = () => {\n    if (!isVirtualScroll.value) return;\n    updateVisibleData();\n  };\n\n  const refreshVirtualScroll = ([{ contentRect }]: [ResizeObserverEntry]) => {\n    // 如果宽度发生变化，重置滚动位置\n    if (params.value.preventResizeRefresh) return;\n    const maxScrollbarWidth = 16;\n    if (Math.abs(contentRect.width - containerWidth.value) > maxScrollbarWidth && !!container.value) {\n      container.value.scrollTop = 0;\n      translateY.value = 0;\n    }\n    containerWidth.value = contentRect.width;\n    // 高度更新后，由 height 独立的 watch 触发可视区域的更新\n    containerHeight.value = contentRect.height;\n  };\n\n  const addIndexToData = (data: any[]) => {\n    data.forEach((item, index) => {\n      // eslint-disable-next-line\n      item['VIRTUAL_SCROLL_INDEX'] = index;\n    });\n  };\n\n  const updateScrollTop = ({ index, top = 0, behavior }: ScrollToElementParams) => {\n    const scrollTop = sum(trHeightList.slice(0, index + 1)) - top;\n\n    container.value.scrollTo({\n      top: scrollTop,\n      behavior: behavior || 'auto',\n    });\n  };\n\n  /**\n   * 滚动到指定元素（对外暴露的方法，谨慎修改）\n   */\n  const scrollToElement = (p: ScrollToElementParams) => {\n    updateScrollTop(p);\n    // 不同行高的表格需要异步计算\n    if (!tScroll.value.isFixedRowHeight) {\n      const duration = p.time ?? 60;\n      const timer = setTimeout(() => {\n        updateScrollTop(p);\n        clearTimeout(timer);\n      }, duration);\n    }\n  };\n\n  // 如果初始化时 isVirtualScroll 为 false，undefined 的 ref 会导致无法监听元素高度变化\n  useResizeObserver(\n    computed(() => (isVirtualScroll.value ? container.value : undefined)),\n    refreshVirtualScroll,\n  );\n\n  // 固定高度场景，可直接通过数据长度计算出最大滚动高度\n  watch(\n    () => [[...params.value.data], tScroll.value, isVirtualScroll.value, container.value],\n    () => {\n      if (!isVirtualScroll.value || !container.value) return;\n      const { data } = params.value;\n      addIndexToData(data);\n\n      // 有可能初始化时，resize 监听没触发，尝试设置初始化容器高度\n      containerHeight.value = container.value.getBoundingClientRect().height;\n\n      if (trHeightList.length !== params.value.data.length) {\n        // 暂时对于 table 和 tree 场景，信任之前缓存的行高\n        // 后续优化可能提供一个参数，进行监听从而清除记录的行高会更好\n        const initHeightList: number[] = Array.from(trHeightList);\n        // 数据长度如果发生变化，裁剪高度记录的数组，避免算出异常的总高度\n        initHeightList.length = params.value.data.length;\n        initHeightList.fill(tScroll.value.rowHeight || 47);\n        trHeightList = initHeightList;\n      }\n\n      scrollHeight.value = sum(trHeightList);\n\n      // 清除记录的滚动顺序\n      startAndEndIndex.value = [0, 0];\n      updateVisibleData();\n    },\n    { immediate: true },\n  );\n\n  // 当容器高度变化后，重新计算可视区域数据\n  watch(\n    () => containerHeight.value,\n    () => {\n      updateVisibleData();\n    },\n  );\n\n  return {\n    visibleData,\n    translateY,\n    scrollHeight,\n    isVirtualScroll,\n    handleScroll,\n    handleRowMounted,\n    scrollToElement,\n  };\n};\n\nexport type VirtualScrollConfig = ReturnType<typeof useVirtualScroll>;\n\nexport default useVirtualScroll;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}