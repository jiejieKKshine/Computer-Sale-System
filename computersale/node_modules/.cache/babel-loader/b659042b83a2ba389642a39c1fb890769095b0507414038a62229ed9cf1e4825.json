{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\n/**\n * tdesign v1.10.5\n * (c) 2024 tdesign\n * @license MIT\n */\n\nimport { _ as _defineProperty } from '../_chunks/dep-fa52aa21.mjs';\nimport { reactive, computed, ref, nextTick, watch, onMounted, toRefs } from 'vue';\nimport '../_chunks/dep-4659d73b.mjs';\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nvar useVirtualScroll = function useVirtualScroll(_ref) {\n  var data = _ref.data,\n    container = _ref.container,\n    _ref$fixedHeight = _ref.fixedHeight,\n    fixedHeight = _ref$fixedHeight === void 0 ? false : _ref$fixedHeight,\n    _ref$lineHeight = _ref.lineHeight,\n    lineHeight = _ref$lineHeight === void 0 ? 30 : _ref$lineHeight,\n    _ref$bufferSize = _ref.bufferSize,\n    bufferSize = _ref$bufferSize === void 0 ? 20 : _ref$bufferSize,\n    _ref$threshold = _ref.threshold,\n    threshold = _ref$threshold === void 0 ? 100 : _ref$threshold;\n  var state = reactive({\n    visibleData: [],\n    cachedHeight: [],\n    cachedScrollY: []\n  });\n  var isVirtual = computed(function () {\n    return data.value.length > threshold;\n  });\n  var updateId = ref(0);\n  var trs = /* @__PURE__ */new Map();\n  var visibleCount = 0;\n  var beforeScrollTop = 0;\n  var index = 0;\n  var offset = 0;\n  var start = 0;\n  var last = 0;\n  var reset = function reset() {\n    data.value.forEach(function (item, i) {\n      item.$index = i;\n      if (fixedHeight) {\n        state.cachedScrollY[i] = i * lineHeight;\n      }\n    });\n    if (!fixedHeight) {\n      state.cachedScrollY[data.value.length - 1] = void 0;\n    }\n  };\n  reset();\n  var scrollHeight = computed(function () {\n    var cachedHeight = state.cachedHeight;\n    var length = cachedHeight.length;\n    if (length) {\n      var maxScrollY = cachedHeight.reduce(function (sum, v) {\n        return sum + v || lineHeight;\n      }, 0);\n      if (cachedHeight.length === data.value.length) {\n        return maxScrollY;\n      }\n      var average = maxScrollY / cachedHeight.length;\n      return maxScrollY + (data.value.length - cachedHeight.length) * average;\n    }\n    return isVirtual.value ? data.value.length * lineHeight : 0;\n  });\n  var translateY = computed(function () {\n    var visibleData = state.visibleData;\n    var firstRow = visibleData[0];\n    if (firstRow) {\n      return visibleData.length === 1 ? 0 : state.cachedScrollY[firstRow.$index];\n    }\n    return 0;\n  });\n  var updateVisibleData = function updateVisibleData() {\n    last = Math.min(start + visibleCount + bufferSize * 2, data.value.length);\n    state.visibleData = data.value.slice(start, last);\n  };\n  var calculateScrollY = function calculateScrollY() {\n    var _anchorDom$getBoundin;\n    var anchorDom = trs.get(index);\n    if (!anchorDom) {\n      return;\n    }\n    var anchorDomHeight = anchorDom === null || anchorDom === void 0 || (_anchorDom$getBoundin = anchorDom.getBoundingClientRect()) === null || _anchorDom$getBoundin === void 0 ? void 0 : _anchorDom$getBoundin.height;\n    state.cachedScrollY[index] = container.value.scrollTop - offset;\n    state.cachedHeight[index] = anchorDomHeight;\n    for (var i = index + 1; i <= ((_state$visibleData = state.visibleData[state.visibleData.length - 1]) === null || _state$visibleData === void 0 ? void 0 : _state$visibleData.$index); i++) {\n      var _state$visibleData;\n      var tr = trs.get(i);\n      var _ref2 = (tr === null || tr === void 0 ? void 0 : tr.getBoundingClientRect()) || {},\n        height = _ref2.height;\n      state.cachedHeight[i] = height;\n      var scrollY = state.cachedScrollY[i - 1] + state.cachedHeight[i - 1];\n      state.cachedScrollY.splice(i, 1, scrollY);\n    }\n    for (var _i = index - 1; _i >= ((_state$visibleData$ = state.visibleData[0]) === null || _state$visibleData$ === void 0 ? void 0 : _state$visibleData$.$index); _i--) {\n      var _state$visibleData$;\n      var _tr = trs.get(_i);\n      var _ref3 = (_tr === null || _tr === void 0 ? void 0 : _tr.getBoundingClientRect()) || {},\n        _height = _ref3.height;\n      state.cachedHeight[_i] = _height;\n      var _scrollY = state.cachedScrollY[_i + 1] - state.cachedHeight[_i];\n      state.cachedScrollY.splice(_i, 1, _scrollY);\n    }\n    if (state.cachedScrollY[0] > 0) {\n      var distance = state.cachedScrollY[0];\n      var length = Math.min(last, data.value.length);\n      for (var _i2 = 0; _i2 < length; _i2++) {\n        state.cachedScrollY.splice(_i2, 1, state.cachedScrollY[_i2] - distance);\n      }\n      var scrollTop = state.cachedScrollY[index - 1] ? state.cachedScrollY[index - 1] + offset : offset;\n      container.value.scrollTop = scrollTop;\n      beforeScrollTop = scrollTop;\n    }\n    if (state.cachedScrollY[start] < 0) {\n      var s = state.cachedHeight.slice(0, Math.max(0, index)).reduce(function (sum, v) {\n        return sum + v;\n      }, 0) + offset;\n      container.value.scrollTop = s;\n      beforeScrollTop = s;\n      if (s === 0) {\n        index = 0;\n        offset = 0;\n      }\n    }\n    nextTick(function () {\n      var _container$value = container.value,\n        scrollTop = _container$value.scrollTop,\n        scrollHeight2 = _container$value.scrollHeight,\n        clientHeight = _container$value.clientHeight;\n      if (scrollTop + clientHeight === scrollHeight2) {\n        for (var _i3 = last - 1; _i3 >= start; _i3--) {\n          if (_i3 === last - 1) {\n            state.cachedScrollY.splice(_i3, 1, scrollHeight2.value - state.cachedHeight[_i3]);\n          } else {\n            state.cachedScrollY.splice(_i3, 1, state.cachedScrollY[_i3 + 1] - state.cachedHeight[_i3]);\n          }\n        }\n      }\n    });\n  };\n  var handleScroll = function handleScroll() {\n    if (!isVirtual.value) return;\n    var scrollTop = container.value.scrollTop;\n    var distance = scrollTop - beforeScrollTop;\n    beforeScrollTop = scrollTop;\n    distance += offset;\n    var lastIndex = index;\n    if (!distance) return;\n    if (distance >= 0) {\n      while (lastIndex < data.value.length && distance > (state.cachedHeight[lastIndex] || lineHeight)) {\n        if (!state.cachedHeight[lastIndex]) {\n          state.cachedHeight[lastIndex] = lineHeight;\n        }\n        distance -= state.cachedHeight[lastIndex];\n        lastIndex++;\n      }\n      if (lastIndex >= data.value.length) {\n        index = data.value.length - 1;\n        offset = 0;\n      } else {\n        index = lastIndex;\n        offset = distance;\n      }\n      var _container$value2 = container.value,\n        clientHeight = _container$value2.clientHeight,\n        scrollHeight2 = _container$value2.scrollHeight;\n      if (scrollTop + clientHeight === scrollHeight2) {\n        index = data.value.length - visibleCount + 1;\n      }\n      if (start <= index - bufferSize) {\n        start = Math.min(data.value.length - visibleCount, index - bufferSize);\n        if (start < 0) {\n          start = 0;\n        }\n      }\n    } else {\n      while (distance < 0) {\n        lastIndex--;\n        if (!state.cachedHeight[lastIndex]) {\n          state.cachedHeight[lastIndex] = lineHeight;\n        }\n        distance += state.cachedHeight[lastIndex];\n      }\n      if (lastIndex < 0) {\n        index = 0;\n        offset = 0;\n      } else {\n        index = lastIndex;\n        offset = distance;\n      }\n      calculateScrollY();\n      if (start > index - bufferSize) {\n        start = Math.max(0, index - bufferSize);\n      }\n    }\n    updateVisibleData();\n  };\n  !fixedHeight && watch(updateId, calculateScrollY, {\n    flush: \"post\"\n  });\n  var handleRowMounted = function handleRowMounted() {\n    if (!isVirtual.value) return;\n    updateId.value++;\n  };\n  watch(data, function () {\n    reset();\n    state.visibleData = [];\n    state.cachedScrollY = [];\n    state.cachedHeight = [];\n    beforeScrollTop = 0;\n    index = 0;\n    offset = 0;\n    start = 0;\n    trs.clear();\n    if (data.value.length <= threshold) {\n      state.visibleData = data.value;\n    } else {\n      updateVisibleData();\n    }\n    container.value && (container.value.scrollTop = 0);\n  });\n  var mounted = false;\n  var refreshContainer = function refreshContainer() {\n    if (mounted) {\n      visibleCount = Math.ceil(container.value.offsetHeight / lineHeight);\n      updateVisibleData();\n    }\n  };\n  onMounted(function () {\n    if (!window || !window.IntersectionObserver) {\n      return;\n    }\n    var ob = new window.IntersectionObserver(function (entries) {\n      var entry = entries[0];\n      if (entry.isIntersecting || entry.intersectionRatio) {\n        mounted = true;\n        isVirtual.value && refreshContainer();\n        ob.unobserve(container.value);\n      }\n    });\n    container.value && ob.observe(container.value);\n  });\n  return _objectSpread(_objectSpread({\n    trs: trs,\n    scrollHeight: scrollHeight\n  }, toRefs(state)), {}, {\n    translateY: translateY,\n    handleScroll: handleScroll,\n    handleRowMounted: handleRowMounted,\n    refreshContainer: refreshContainer,\n    fixedHeight: fixedHeight,\n    calculateScrollY: calculateScrollY\n  });\n};\nexport { useVirtualScroll as default };","map":{"version":3,"names":["useVirtualScroll","_ref","data","container","_ref$fixedHeight","fixedHeight","_ref$lineHeight","lineHeight","_ref$bufferSize","bufferSize","_ref$threshold","threshold","state","reactive","visibleData","cachedHeight","cachedScrollY","isVirtual","computed","value","length","updateId","ref","trs","Map","visibleCount","beforeScrollTop","index","offset","start","last","reset","forEach","item","i","$index","scrollHeight","maxScrollY","reduce","sum","v","average","translateY","firstRow","updateVisibleData","Math","min","slice","calculateScrollY","_anchorDom$getBoundin","anchorDom","get","anchorDomHeight","getBoundingClientRect","height","scrollTop","_state$visibleData","tr","_ref2","scrollY","splice","_i","_state$visibleData$","_tr","_ref3","_height","_scrollY","distance","_i2","s","max","nextTick","_container$value","scrollHeight2","clientHeight","_i3","handleScroll","lastIndex","_container$value2","watch","flush","handleRowMounted","clear","mounted","refreshContainer","ceil","offsetHeight","onMounted","window","IntersectionObserver","ob","entries","entry","isIntersecting","intersectionRatio","unobserve","observe","_objectSpread","toRefs"],"sources":["../../src/hooks/useVirtualScroll.ts"],"sourcesContent":["/* eslint-disable */\n/**\n * 当前虚拟滚动存在的问题\n * 1. 反复拖动滚动条，底部会出现奇怪的高度\n * 2. 表格高度发生变化时，底部也会出现奇怪的高度\n * 3. 无法直接定位滚动到某个元素，进而无法实现 Select 组件直接滚动到选中项\n */\nimport { ref, toRefs, reactive, onMounted, computed, watch, nextTick } from 'vue';\n\n// 虚拟滚动Hooks的完整实现，只所以封装成hooks，主要是为了方便跟其他组件搭配使用，比如说表格或者下拉框\nconst useVirtualScroll = ({\n  data,\n  container,\n  fixedHeight = false,\n  lineHeight = 30,\n  bufferSize = 20,\n  threshold = 100,\n}: {\n  data: any;\n  container: any;\n  fixedHeight: boolean;\n  lineHeight: number;\n  bufferSize: number;\n  threshold: number;\n}) => {\n  const state = reactive({\n    visibleData: [],\n    cachedHeight: [],\n    cachedScrollY: [],\n  });\n  const isVirtual = computed(() => data.value.length > threshold);\n  const updateId = ref(0);\n  const trs = new Map(); // 当前展示的行元素和数据\n\n  let visibleCount = 0; // 可见的节点数量\n  let beforeScrollTop = 0; // 上一次的滚动条位置\n  let index = 0; // 偏移行数\n  let offset = 0; // 少于一行行高的偏移量\n  let start = 0; // 第一条显示的行\n  let last = 0; // 最后一条显示的行\n  // let revising = false; // 是否正在修正滚动条\n\n  const reset = () => {\n    data.value.forEach((item: any, i: number) => {\n      item.$index = i;\n      if (fixedHeight) {\n        state.cachedScrollY[i] = i * lineHeight;\n      }\n    });\n    if (!fixedHeight) {\n      state.cachedScrollY[data.value.length - 1] = undefined; // 初始化cachedScrollY数组的长度\n    }\n  };\n  reset();\n\n  // 计算虚拟滚动列表总高度，需要动态修正\n  const scrollHeight = computed(() => {\n    const { cachedHeight } = state;\n    const { length } = cachedHeight;\n    if (length) {\n      const maxScrollY = cachedHeight.reduce((sum, v) => sum + v || lineHeight, 0); // 当前总高度\n      if (cachedHeight.length === data.value.length) {\n        return maxScrollY;\n      }\n      const average = maxScrollY / cachedHeight.length; // 平均高度\n      return maxScrollY + (data.value.length - cachedHeight.length) * average; // 预估总高度\n    }\n    return isVirtual.value ? data.value.length * lineHeight : 0;\n  });\n  const translateY = computed(() => {\n    const { visibleData } = state;\n    const firstRow = visibleData[0];\n    if (firstRow) {\n      // 修复只有一个元素时存在偏移的问题\n      return visibleData.length === 1 ? 0 : state.cachedScrollY[firstRow.$index];\n    }\n    return 0;\n  });\n\n  // 更新可视区域的节点数据\n  const updateVisibleData = () => {\n    last = Math.min(start + visibleCount + bufferSize * 2, data.value.length);\n    state.visibleData = data.value.slice(start, last);\n  };\n  // 计算每行对应的scrollTop值\n  const calculateScrollY = () => {\n    const anchorDom = trs.get(index); // 获取锚点元素\n    if (!anchorDom) {\n      return; // 快速调整高度时，新的元素可能来不及加载，暂时跳过更新\n    }\n    const anchorDomHeight = anchorDom?.getBoundingClientRect()?.height; // 获取锚点元素的高\n    state.cachedScrollY[index] = container.value.scrollTop - offset; // 锚点元素scrollY= 容器滚动高度 - 锚点元素的offset\n    state.cachedHeight[index] = anchorDomHeight;\n\n    for (let i = index + 1; i <= state.visibleData[state.visibleData.length - 1]?.$index; i++) {\n      // 计算锚点后面的元素scrollY\n      const tr = trs.get(i);\n      const { height } = tr?.getBoundingClientRect() || {};\n      state.cachedHeight[i] = height;\n      const scrollY = state.cachedScrollY[i - 1] + state.cachedHeight[i - 1]; // 当前元素的y 是前一个元素的y+前一个元素高度\n      // state.cachedScrollY[i] = scrollY;\n      state.cachedScrollY.splice(i, 1, scrollY); // 兼容vue2的composition api\n    }\n\n    for (let i = index - 1; i >= state.visibleData[0]?.$index; i--) {\n      const tr = trs.get(i);\n      const { height } = tr?.getBoundingClientRect() || {};\n      state.cachedHeight[i] = height;\n      const scrollY = state.cachedScrollY[i + 1] - state.cachedHeight[i]; // 当前元素的y是下一个元素y - 当前元素高度\n      // state.cachedScrollY[i] = scrollY;\n      state.cachedScrollY.splice(i, 1, scrollY);\n    }\n    if (state.cachedScrollY[0] > 0) {\n      // 修正滚动过快时，滚动到顶部时，滚动条多余的问题\n      // revising = true;\n      const distance = state.cachedScrollY[0]; // 第一个元素scrollY即为多出的量\n      const length = Math.min(last, data.value.length);\n      for (let i = 0; i < length; i++) {\n        // state.cachedScrollY[i] -= distance;\n        state.cachedScrollY.splice(i, 1, state.cachedScrollY[i] - distance);\n      }\n\n      const scrollTop = state.cachedScrollY[index - 1] ? state.cachedScrollY[index - 1] + offset : offset;\n      container.value.scrollTop = scrollTop;\n      beforeScrollTop = scrollTop;\n      // revising = false;\n    }\n    // 修正拖动过快时，滚动到顶端时，滚动条不足的偏差\n    if (state.cachedScrollY[start] < 0) {\n      // revising = true;\n      const s = state.cachedHeight.slice(0, Math.max(0, index)).reduce((sum, v) => sum + v, 0) + offset;\n      container.value.scrollTop = s;\n      beforeScrollTop = s;\n      if (s === 0) {\n        index = 0;\n        offset = 0;\n      }\n      // revising = false;\n    }\n    nextTick(() => {\n      // setTimeout是为了保证快速拖动到底部时，以下逻辑能够正常执行\n      const { scrollTop, scrollHeight, clientHeight } = container.value;\n      if (scrollTop + clientHeight === scrollHeight) {\n        // 滚动到底部时，修正底部有空余的问题\n        // revising = true;\n        for (let i = last - 1; i >= start; i--) {\n          if (i === last - 1) {\n            // state.cachedScrollY[i] = scrollHeight.value - state.cachedHeight[i];\n            state.cachedScrollY.splice(i, 1, scrollHeight.value - state.cachedHeight[i]);\n          } else {\n            // state.cachedScrollY[i] = state.cachedScrollY[i + 1] - state.cachedHeight[i];\n            state.cachedScrollY.splice(i, 1, state.cachedScrollY[i + 1] - state.cachedHeight[i]);\n          }\n        }\n        // revising = false;\n      }\n    });\n  };\n\n  // 滚动时动态计算和渲染\n  const handleScroll = () => {\n    if (!isVirtual.value) return;\n    // if (revising) {\n    //   return false; // 修正滚动条时，暂停滚动逻辑\n    // }\n    const { scrollTop } = container.value;\n    let distance = scrollTop - beforeScrollTop; // 滚动差值\n    beforeScrollTop = scrollTop;\n    distance += offset;\n    let lastIndex = index;\n    // !disatance 可能为横向滚动，不做任何计算\n    if (!distance) return;\n    if (distance >= 0) {\n      // 向下滚动\n      while (lastIndex < data.value.length && distance > (state.cachedHeight[lastIndex] || lineHeight)) {\n        if (!state.cachedHeight[lastIndex]) {\n          state.cachedHeight[lastIndex] = lineHeight;\n        }\n        distance -= state.cachedHeight[lastIndex];\n        lastIndex++;\n      }\n      if (lastIndex >= data.value.length) {\n        index = data.value.length - 1;\n        offset = 0;\n      } else {\n        index = lastIndex;\n        offset = distance;\n      }\n      const { clientHeight, scrollHeight } = container.value;\n      if (scrollTop + clientHeight === scrollHeight) {\n        // 滚动条到底了\n        index = data.value.length - visibleCount + 1;\n        // calculateScrollY();\n      }\n      if (start <= index - bufferSize) {\n        // 计算第一个挂载元素\n        start = Math.min(data.value.length - visibleCount, index - bufferSize);\n        if (start < 0) {\n          start = 0;\n        }\n      }\n    } else {\n      // 向上滚动\n      while (distance < 0) {\n        lastIndex--;\n        if (!state.cachedHeight[lastIndex]) {\n          state.cachedHeight[lastIndex] = lineHeight;\n        }\n        distance += state.cachedHeight[lastIndex];\n      }\n      if (lastIndex < 0) {\n        index = 0;\n        offset = 0;\n      } else {\n        index = lastIndex;\n        offset = distance;\n      }\n      calculateScrollY();\n      if (start > index - bufferSize) {\n        // 计算第一个挂载元素\n        start = Math.max(0, index - bufferSize);\n      }\n    }\n    updateVisibleData();\n  };\n\n  !fixedHeight && watch(updateId, calculateScrollY, { flush: 'post' });\n  const handleRowMounted = () => {\n    if (!isVirtual.value) return;\n    updateId.value++;\n  };\n  watch(data, () => {\n    reset();\n    state.visibleData = [];\n    state.cachedScrollY = [];\n    state.cachedHeight = [];\n    beforeScrollTop = 0;\n    index = 0;\n    offset = 0;\n    start = 0;\n    // revising = false;\n    trs.clear();\n    if (data.value.length <= threshold) {\n      state.visibleData = data.value;\n    } else {\n      updateVisibleData();\n    }\n\n    container.value && (container.value.scrollTop = 0);\n  });\n  let mounted = false;\n  const refreshContainer = () => {\n    if (mounted) {\n      visibleCount = Math.ceil(container.value.offsetHeight / lineHeight);\n      updateVisibleData();\n    }\n  };\n  onMounted(() => {\n    if (!window || !window.IntersectionObserver) {\n      return;\n    }\n    const ob = new window.IntersectionObserver((entries) => {\n      const entry = entries[0];\n      if (entry.isIntersecting || entry.intersectionRatio) {\n        mounted = true;\n        isVirtual.value && refreshContainer();\n        ob.unobserve(container.value);\n      }\n    });\n    container.value && ob.observe(container.value);\n  });\n  return {\n    trs,\n    scrollHeight,\n    ...toRefs(state),\n    translateY,\n    handleScroll,\n    handleRowMounted,\n    refreshContainer,\n    fixedHeight,\n    calculateScrollY,\n  };\n};\nexport default useVirtualScroll;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}