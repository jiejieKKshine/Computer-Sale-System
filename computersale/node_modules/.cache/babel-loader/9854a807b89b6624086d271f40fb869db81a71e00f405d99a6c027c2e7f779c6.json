{"ast":null,"code":"/**\n * tdesign v1.10.5\n * (c) 2024 tdesign\n * @license MIT\n */\n\nimport { ref, reactive } from 'vue';\nfunction useDragSorter(props) {\n  var sortOnDraggable = props.sortOnDraggable,\n    onDragSort = props.onDragSort,\n    onDragOverCheck = props.onDragOverCheck;\n  var draggingIndex = ref(-1);\n  var dragStartData = ref(null);\n  var isDropped = ref(null);\n  var startInfo = reactive({\n    nodeX: 0,\n    nodeWidth: 0,\n    mouseX: 0\n  });\n  var onDragOver = function onDragOver(e, index, record) {\n    e.preventDefault();\n    if (draggingIndex.value === index || draggingIndex.value === -1) return;\n    var target = e.target;\n    if (onDragOverCheck !== null && onDragOverCheck !== void 0 && onDragOverCheck.targetClassNameRegExp && !(onDragOverCheck !== null && onDragOverCheck !== void 0 && onDragOverCheck.targetClassNameRegExp.test(target.className))) {\n      return;\n    }\n    if (onDragOverCheck !== null && onDragOverCheck !== void 0 && onDragOverCheck.x && target) {\n      if (!startInfo.nodeWidth) return;\n      var _target$getBoundingCl = target.getBoundingClientRect(),\n        x = _target$getBoundingCl.x,\n        width = _target$getBoundingCl.width;\n      var targetNodeMiddleX = x + width / 2;\n      var draggingNodeLeft = e.clientX - (startInfo.mouseX - startInfo.nodeX);\n      var draggingNodeRight = draggingNodeLeft + startInfo.nodeWidth;\n      var overlap = false;\n      if (draggingNodeLeft > x && draggingNodeLeft < x + width) {\n        overlap = draggingNodeLeft < targetNodeMiddleX;\n      } else {\n        overlap = draggingNodeRight > targetNodeMiddleX;\n      }\n      if (!overlap) return;\n    }\n    onDragSort === null || onDragSort === void 0 || onDragSort({\n      currentIndex: draggingIndex.value,\n      current: dragStartData,\n      target: record,\n      targetIndex: index\n    });\n    draggingIndex.value = index;\n  };\n  if (!sortOnDraggable) {\n    return {};\n  }\n  function onDragStart(e, index, record) {\n    draggingIndex.value = index;\n    dragStartData.value = record;\n    var target = e.target;\n    if (onDragOverCheck && target) {\n      var _target$getBoundingCl2 = target.getBoundingClientRect(),\n        x = _target$getBoundingCl2.x,\n        width = _target$getBoundingCl2.width;\n      startInfo.nodeX = x;\n      startInfo.nodeWidth = width;\n      startInfo.mouseX = e.clientX;\n    }\n  }\n  function _onDrop() {\n    isDropped.value = true;\n  }\n  function onDragEnd() {\n    if (!isDropped.value) {}\n    isDropped.value = false;\n    draggingIndex.value = -1;\n    dragStartData.value = null;\n  }\n  function getDragProps(index, record) {\n    if (sortOnDraggable) {\n      return {\n        draggable: true,\n        onDragstart: function onDragstart(e) {\n          onDragStart(e, index, record);\n        },\n        onDragover: function onDragover(e) {\n          onDragOver(e, index, record);\n        },\n        onDrop: function onDrop() {\n          _onDrop();\n        },\n        onDragend: function onDragend() {\n          onDragEnd();\n        }\n      };\n    }\n    return {};\n  }\n  return {\n    onDragStart: onDragStart,\n    onDragOver: onDragOver,\n    onDrop: _onDrop,\n    onDragEnd: onDragEnd,\n    getDragProps: getDragProps,\n    dragging: draggingIndex.value !== -1\n  };\n}\nexport { useDragSorter as default };","map":{"version":3,"names":["useDragSorter","props","sortOnDraggable","onDragSort","onDragOverCheck","draggingIndex","ref","dragStartData","isDropped","startInfo","reactive","nodeX","nodeWidth","mouseX","onDragOver","e","index","record","preventDefault","value","target","targetClassNameRegExp","test","className","x","_target$getBoundingCl","getBoundingClientRect","width","targetNodeMiddleX","draggingNodeLeft","clientX","draggingNodeRight","overlap","currentIndex","current","targetIndex","onDragStart","_target$getBoundingCl2","_onDrop","onDragEnd","getDragProps","draggable","onDragstart","onDragover","onDrop","onDragend","dragging"],"sources":["../../../src/tag-input/hooks/useDragSorter.ts"],"sourcesContent":["import { ref, reactive } from 'vue';\nimport { DragSortProps, DragSortInnerProps } from '../interface';\n\nexport default function useDragSorter<T>(props: DragSortProps<T>): DragSortInnerProps {\n  const { sortOnDraggable, onDragSort, onDragOverCheck } = props;\n  const draggingIndex = ref(-1);\n  const dragStartData = ref(null);\n  const isDropped = ref(null);\n  const startInfo = reactive({ nodeX: 0, nodeWidth: 0, mouseX: 0 });\n\n  const onDragOver = (e: DragEvent, index: number, record: T) => {\n    e.preventDefault();\n    if (draggingIndex.value === index || draggingIndex.value === -1) return;\n    const target = e.target as HTMLElement;\n    if (onDragOverCheck?.targetClassNameRegExp && !onDragOverCheck?.targetClassNameRegExp.test(target.className)) {\n      return;\n    }\n\n    if (onDragOverCheck?.x && target) {\n      if (!startInfo.nodeWidth) return;\n\n      const { x, width } = target.getBoundingClientRect();\n      const targetNodeMiddleX = x + width / 2;\n      const draggingNodeLeft = e.clientX - (startInfo.mouseX - startInfo.nodeX);\n      const draggingNodeRight = draggingNodeLeft + startInfo.nodeWidth;\n\n      let overlap = false;\n      if (draggingNodeLeft > x && draggingNodeLeft < x + width) {\n        overlap = draggingNodeLeft < targetNodeMiddleX;\n      } else {\n        overlap = draggingNodeRight > targetNodeMiddleX;\n      }\n\n      if (!overlap) return;\n    }\n\n    onDragSort?.({\n      currentIndex: draggingIndex.value,\n      current: dragStartData,\n      target: record,\n      targetIndex: index,\n    });\n\n    draggingIndex.value = index;\n  };\n\n  if (!sortOnDraggable) {\n    return {};\n  }\n\n  function onDragStart(e: DragEvent, index: number, record: T) {\n    draggingIndex.value = index;\n    dragStartData.value = record;\n    const target = e.target as HTMLElement;\n    if (onDragOverCheck && target) {\n      const { x, width } = target.getBoundingClientRect();\n      startInfo.nodeX = x;\n      startInfo.nodeWidth = width;\n      startInfo.mouseX = e.clientX;\n    }\n  }\n\n  function onDrop() {\n    isDropped.value = true;\n  }\n\n  function onDragEnd() {\n    if (!isDropped.value) {\n      // 取消排序，待扩展 api，输出 dragStartData\n    }\n    isDropped.value = false;\n    draggingIndex.value = -1;\n    dragStartData.value = null;\n  }\n\n  function getDragProps(index: number, record: T) {\n    if (sortOnDraggable) {\n      return {\n        draggable: true,\n        onDragstart: (e: DragEvent) => {\n          onDragStart(e, index, record);\n        },\n        onDragover: (e: DragEvent) => {\n          onDragOver(e, index, record);\n        },\n        onDrop: () => {\n          onDrop();\n        },\n        onDragend: () => {\n          onDragEnd();\n        },\n      };\n    }\n    return {};\n  }\n\n  return { onDragStart, onDragOver, onDrop, onDragEnd, getDragProps, dragging: draggingIndex.value !== -1 };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}